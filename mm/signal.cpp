/**
 * @file
 * @brief Memory manager signal handling.
 *
 * Signals are asynchronous events generated by system calls or hardware
 * sources. This module evaluates pending signals, delivers them to the
 * appropriate processes, and applies default actions such as core dumps.
 *
 * The primary entry points are:
 * - ::do_signal()  -- implement the `signal` system call
 * - ::do_kill()    -- deliver a signal to a process or process group
 * - ::do_ksig()    -- handle signals originating in the kernel
 * - ::sig_proc()   -- interrupt or terminate a signalled process
 * - ::do_alarm()   -- set or cancel interval timers
 * - ::set_alarm()  -- helper used by ::do_alarm()
 * - ::do_pause()   -- suspend a process until it receives a signal
 * - ::unpause()    -- resume a process blocked on a signal
 */

#include "../h/signal.hpp"
#include "../h/callnr.hpp"
#include "../h/com.hpp"
#include "../h/const.hpp"
#include "../h/error.hpp"
#include "../h/stat.h"
#include "../h/type.hpp"
#include "const.hpp"
#include "glo.hpp"
#include "mproc.hpp"
#include "param.hpp"
#include "token.hpp"
#include <algorithm> // For std::min
#include <array>     // For std::array
#include <bitset>    // For std::bitset
#include <csignal>   // For standard signal definitions
#include <cstddef>   // For std::size_t, nullptr
#include <cstdint>   // For uint16_t, int64_t etc.
#include <ranges>    // For std::ranges::contains

namespace {
/// Buffer size for core dumps.
constexpr int DUMP_SIZE{256};
/// Mode to use on core image files.
constexpr int CORE_MODE{0777};
/// Bit set in status when core dumped.
constexpr int DUMPED{0200};

/**
 * @brief Signals that trigger creation of a core dump.
 */
constexpr std::array<int, 9> CORE_DUMP_SIGNALS{SIGQUIT, SIGILL, SIGTRAP, SIGIOT, SIGEMT,
                                               SIGFPE,  SIGBUS, SIGSEGV, SIGSYS};

/**
 * @brief Check whether @p sig should generate a core file.
 * @param sig Signal number to
 * query.
 * @return `true` if the signal produces a core dump.
 */
constexpr bool is_core_dump_signal(int sig) noexcept {
    return std::ranges::contains(CORE_DUMP_SIGNALS, sig);
}
} // namespace

static message m_sig; // PRIVATE -> static

// Forward declarations for static functions if needed
[[nodiscard]] static int check_sig(int proc_id, int sig_nr, uint16_t send_uid) noexcept;
static void dump_core(struct mproc *rmp) noexcept;

/**
 * @brief Install a handler or disposition for a signal.
 *
 * Updates the calling process's
 * bookkeeping so that future deliveries of
 * `sig` are either ignored, handled by a user function,
 * or reset to the
 * default action.
 *
 * @return ::ErrorCode::EINVAL if @p sig is invalid;
 * otherwise ::OK.
 */
[[nodiscard]] PUBLIC int do_signal() noexcept {

    uint16_t mask; // Was int, for mp_ignore/mp_catch (unshort -> uint16_t)

    // sig from message (m6_i1) is int. func from message (m6_f1) is int(*)().
    if (sig < 1 || sig > NR_SIGS)
        return (ErrorCode::EINVAL);
    if (sig == SIGKILL)
        return (OK);                              /* SIGKILL may not ignored/caught */
    mask = static_cast<uint16_t>(1 << (sig - 1)); /* singleton set with 'sig' bit on */

    /* All this func does is set the bit maps for subsequent sig processing. */
    if (func == SIG_IGN) { // SIG_IGN is (int(*)())1
        mp->mp_ignore |= mask;
        mp->mp_catch &= ~mask;
    } else if (func == SIG_DFL) { // SIG_DFL is (int(*)())0
        mp->mp_ignore &= ~mask;
        mp->mp_catch &= ~mask;
    } else {
        mp->mp_ignore &= ~mask;
        mp->mp_catch |= mask;
        mp->mp_func = func; // mp_func is int(*)(), func is int(*)()
    }
    return (OK);
}

/**
 * @brief Send a signal to a target process or process group.
 *
 * The call validates
 * permissions and delegates delivery to ::check_sig().
 *
 * @return Result of ::check_sig().
 */
[[nodiscard]] PUBLIC int do_kill() noexcept {
    /* Perform the kill(pid, kill_sig) system call. */
    // pid from message (m1_i1) is int. kill_sig from message (m1_i2) is int.
    // mp->mp_effuid is uid (uint16_t).
    return check_sig(pid, kill_sig, mp->mp_effuid);
}

/**
 * @brief Handle a batch of signals originating from the kernel.
 *
 * The kernel communicates
 * pending signals via a bit mask. This routine
 * decodes the mask and forwards each signal to
 * ::check_sig().
 *
 * @return ::ErrorCode::EPERM if the caller is not the kernel or file
 *
 * system; otherwise ::OK.
 */
[[nodiscard]] PUBLIC int do_ksig() noexcept {
    /* Certain signals, such as segmentation violations and DEL, originate in the
     * kernel.  When the kernel detects such signals, it sets bits in a bit map.
     * As soon is MM is awaiting new work, the kernel sends MM a message containing
     * the process slot and bit map.  That message comes here.  The File System
     * also uses this mechanism to signal writing on broken pipes (SIGPIPE).
     */

    register struct mproc *rmp;
    int proc_id, proc_nr, id;
    std::bitset<NR_SIGS> sig_map_bits; /**< Pending signals. */

    /* Only kernel and FS may make this call. */
    if (who != HARDWARE && who != FS_PROC_NR) // who is int global
        return (ErrorCode::EPERM);

    proc_nr = proc1(mm_in); // proc1 macro gets m1_i1 (int)
    rmp = &mproc[proc_nr];
    if ((rmp->mp_flags & IN_USE) == 0 || (rmp->mp_flags & HANGING))
        return (OK);
    proc_id = rmp->mp_pid; // mp_pid is int
    sig_map_bits = std::bitset<NR_SIGS>{
        static_cast<uint16_t>(sig_map(mm_in))}; // sig_map macro gets m1_i2 (int)
    mp = &mproc[0];                             /* pretend kernel signals are from MM */

    /* Stack faults are passed from kernel to MM as pseudo-signal 16. */
    if (sig_map_bits.test(STACK_FAULT - 1)) { // STACK_FAULT is int
        stack_fault(proc_nr);                 // stack_fault is in mm/break.cpp
        return (OK);
    }

    /* Iterate over pending signals; for SIGINT and SIGQUIT use proc_id 0. */
    for (std::size_t i = 0; i < sig_map_bits.size(); ++i) {
        if (!sig_map_bits.test(i))
            continue;
        id = (i + 1 == SIGINT || i + 1 == SIGQUIT ? 0 : proc_id);
        check_sig(id, static_cast<int>(i + 1), static_cast<uint16_t>(SUPER_USER));
    }

    dont_reply = TRUE; /* don't reply to the kernel */
    return (OK);
}

/**
 * @brief Validate and deliver a signal to one or more processes.
 *
 * Applies permission
 * checks and dispatches ::sig_proc() for each eligible
 * process. When @p proc_id is zero, the
 * signal is broadcast to the sender's
 * process group.
 *
 * @return Number of processes signalled
 * or ::ErrorCode::EINVAL for an
 * invalid signal number.
 */
[[nodiscard]] static int check_sig(int proc_id, int sig_nr, uint16_t send_uid) noexcept {
    /* Check to see if it is possible to send a signal.  The signal may have to be
     * sent to a group of processes.  This routine is invoked by the KILL system
     * call, and also when the kernel catches a DEL or other signal. SIGALRM too.
     */

    register struct mproc *rmp;
    int count, send_sig;
    uint16_t mask; // Was unshort

    if (sig_nr < 1 || sig_nr > NR_SIGS)
        return (ErrorCode::EINVAL);
    count = 0;                                       /* count # of signals sent */
    mask = static_cast<uint16_t>(1 << (sig_nr - 1)); // mp_ignore/catch are uint16_t

    /* Search the proc table for processes to signal.  Several tests are made:
     * 	- if proc's uid != sender's, and sender is not superuser, don't signal
     *	- if specific process requested (i.e., 'procpid' > 0, check for match
     *	- if a process has already exited, it can't receive signals
     *	- if 'proc_id' is 0 signal everyone in same process group except caller
     */
    for (rmp = &mproc[INIT_PROC_NR + 1]; rmp < &mproc[NR_PROCS]; rmp++) {
        if ((rmp->mp_flags & IN_USE) == 0)
            continue;
        send_sig = TRUE; /* if it's FALSE at end of loop, don't signal */
        // mp_effuid is uid (uint16_t). SUPER_USER is uid (uint16_t).
        if (send_uid != rmp->mp_effuid && send_uid != SUPER_USER)
            send_sig = FALSE;
        if (proc_id > 0 && proc_id != rmp->mp_pid) // mp_pid is int
            send_sig = FALSE;
        if (rmp->mp_flags & HANGING)
            send_sig = FALSE;                                  /*don't wake the dead*/
        if (proc_id == 0 && mp->mp_procgrp != rmp->mp_procgrp) // mp_procgrp is int
            send_sig = FALSE;
        if (send_uid == SUPER_USER && proc_id == -1)
            send_sig = TRUE;

        /* SIGALARM is a little special.  When a process exits, a clock signal
         * can arrive just as the timer is being turned off.  Also, turn off
         * ALARM_ON bit when timer goes off to keep it accurate.
         */
        if (sig_nr == SIGALRM) { // ALARM_ON is unsigned int flag
            if ((rmp->mp_flags & ALARM_ON) == 0)
                continue;
            rmp->mp_flags &= ~ALARM_ON;
        }

        if (send_sig == FALSE || rmp->mp_ignore & mask) // mp_ignore is unshort (uint16_t)
            continue;
        count++;

        /* Send the signal or kill the process, possibly with core dump. */
        sig_proc(rmp, sig_nr);

        /* If process is hanging on PAUSE, WAIT, tty, pipe, etc. release it. */
        unpause(static_cast<int>(rmp - mproc.data())); /* check to see if process is paused */
        if (proc_id > 0)
            break; /* only one process being signalled */
    }

    /* If the calling process has killed itself, don't reply. */
    if ((mp->mp_flags & IN_USE) == 0 || (mp->mp_flags & HANGING))
        dont_reply = TRUE;
    return (count > 0 ? OK : ErrorCode::ESRCH);
}

/**
 * @brief Deliver a signal to a process and perform the default action.
 *
 * If the signal is
 * caught, the user handler is invoked; otherwise the
 * process is terminated, optionally producing
 * a core file.
 *
 * @param rmp   Target process descriptor.
 * @param sig_nr Signal number being
 * delivered.
 */
PUBLIC void sig_proc(struct mproc *rmp, int sig_nr) noexcept {
    /* Send a signal to a process.  Check to see if the signal is to be caught.
     * If so, the pc, psw, and signal number are to be pushed onto the process'
     * stack.  If the stack cannot grow or the signal is not to be caught, kill
     * the process.
     */

    uint16_t mask; // Was unshort
    int core_file;
    std::size_t new_sp; // Was vir_bytes

    if ((rmp->mp_flags & IN_USE) == 0)
        return;                                      /* if already dead forget it */
    mask = static_cast<uint16_t>(1 << (sig_nr - 1)); // mp_catch is unshort (uint16_t)
    if (rmp->mp_catch & mask) {
        /* Signal should be caught. */
        rmp->mp_catch &= ~mask; /* disable further signals */
        sys_getsp(static_cast<int>(rmp - mproc.data()),
                  &new_sp);       // sys_getsp (kernel) expects std::size_t* for new_sp
        new_sp -= SIG_PUSH_BYTES; // SIG_PUSH_BYTES is int. new_sp is std::size_t.
        // rmp->mp_seg[D].mem_len is vir_clicks (std::size_t). adjust takes std::size_t for clicks &
        // sp.
        if (adjust(rmp, rmp->mp_seg[D].mem_len, new_sp) == OK) {
            sys_sig(static_cast<int>(rmp - mproc.data()), sig_nr, rmp->mp_func, rmp->mp_token);
            return; /* successful signal */
        }
    }

    /* Signal should not or cannot be caught.  Take default action. */
    core_file = is_core_dump_signal(sig_nr);
    rmp->mp_sigstatus = static_cast<char>(sig_nr); // mp_sigstatus is char
    if (core_file)
        dump_core(rmp); /* dump core */
    mm_exit(rmp, 0);    /* terminate process */
}

/**
 * @brief Implement the `alarm` system call.
 *
 * Requests delivery of SIGALRM after @p
 * seconds. Any pending timer is
 * replaced and its remaining time is returned.
 *
 * @return
 * Seconds remaining from the previous alarm, if any.
 */
[[nodiscard]] PUBLIC int do_alarm() noexcept {
    unsigned int sec = static_cast<unsigned int>(seconds); // seconds (message m1_i1) is int
    return set_alarm(who, sec);
}

/**
 * @brief Helper to schedule or cancel a process alarm.
 *
 * Communicates with the clock task
 * to arrange SIGALRM delivery after the
 * specified interval.
 *
 * @param proc_nr Target process
 * number.
 * @param sec     Interval in seconds; zero cancels the alarm.
 * @return Remaining
 * seconds on a previous timer.
 */
[[nodiscard]] PUBLIC int set_alarm(int proc_nr, unsigned int sec) noexcept {
    /* This routine is used by do_alarm() to set the alarm timer.  It is also
     * to turn the timer off when a process exits with the timer still on.
     */

    int remaining;

    m_sig.m_type = SET_ALARM;
    proc_nr(m_sig) = proc_nr; // proc_nr macro (m6_i1) is int
    // delta_ticks macro (m6_l1) is int64_t. HZ is int. sec is unsigned int.
    delta_ticks(m_sig) = static_cast<int64_t>(HZ) * static_cast<int64_t>(sec);
    if (sec != 0)
        mproc[proc_nr].mp_flags |= ALARM_ON; /* turn ALARM_ON bit on */
    else
        mproc[proc_nr].mp_flags &= ~ALARM_ON; /* turn ALARM_ON bit off */

    /* Tell the clock task to provide a signal message when the time comes. */
    if (sendrec(CLOCK, &m_sig) != OK)
        panic("alarm er", NO_NUM);
    // remaining represents the number of seconds left.
    remaining = static_cast<int>(seconds_left(m_sig));
    return (remaining);
}

/**
 * @brief Suspend the caller until a signal arrives.
 *
 * Marks the process as paused and
 * defers reply handling until it is
 * awakened by a signal.
 *
 * @return ::OK always.
 */
[[nodiscard]] PUBLIC int do_pause() noexcept {
    /* Perform the pause() system call. */

    mp->mp_flags |= PAUSED; /* turn on PAUSE bit */
    dont_reply = TRUE;
    return (OK);
}

/**
 * @brief Resume a process that was suspended awaiting an event.
 *
 * Clears PAUSED or WAITING
 * flags and, if necessary, informs the file system
 * so that blocked I/O can be interrupted.
 *
 *
 * @param pro Process table index of the target process.
 */
PUBLIC void unpause(int pro) noexcept {
    /* A signal is to be sent to a process.  It that process is hanging on a
     * system call, the system call must be terminated with ErrorCode::EINTR.  Possible
     * calls are PAUSE, WAIT, READ and WRITE, the latter two for pipes and ttys.
     * First check if the process is hanging on PAUSE or WAIT.  If not, tell FS,
     * so it can check for READs and WRITEs from pipes, ttys and the like.
     */

    register struct mproc *rmp;

    rmp = &mproc[pro];

    /* Check to see if process is hanging on PAUSE call. */
    if ((rmp->mp_flags & PAUSED) && (rmp->mp_flags & HANGING) == 0) {
        rmp->mp_flags &= ~PAUSED;                 /* turn off PAUSED bit */
        reply(pro, ErrorCode::EINTR, 0, NIL_PTR); // NIL_PTR is char* (nullptr)
        return;
    }

    /* Check to see if process is hanging on a WAIT call. */
    if ((rmp->mp_flags & WAITING) && (rmp->mp_flags & HANGING) == 0) {
        rmp->mp_flags &= ~WAITING; /* turn off WAITING bit */
        reply(pro, ErrorCode::EINTR, 0, NIL_PTR);
        return;
    }

    /* Process is not hanging on an MM call.  Ask FS to take a look. */
    tell_fs(UNPAUSE, pro, 0, 0);
    // return; // Implicit void return
}

/**
 * @brief Write a core dump for the specified process.
 *
 * Creates a file named "core" in the
 * process's working directory containing
 * the contents of its address space, provided permissions
 * allow.
 *
 * @param rmp Process descriptor of the faulting process.
 */
static void dump_core(struct mproc *rmp) noexcept {
    /* Make a core dump on the file "core", if possible. */

    struct stat s_buf, d_buf;
    char buf[DUMP_SIZE]; // DUMP_SIZE is int const
    int i, r, s, er1, er2, slot;
    std::size_t v_buf; // Was vir_bytes
    // len, a, c, ct were long. They represent byte counts or addresses.
    // len, c, ct are counts -> std::size_t
    // a, dest are addresses/offsets -> std::size_t (virtual)
    std::size_t len, a, c, ct, dest;
    struct mproc *xmp;
    extern char core_name[];

    /* Change to working directory of dumpee. */
    slot = static_cast<int>(rmp - mproc.data()); // int
    tell_fs(CHDIR, slot, 0, 0);

    /* Can core file be written? */
    if (rmp->mp_realuid != rmp->mp_effuid) // uid -> uint16_t
        return;
    xmp = mp; /* allowed() looks at 'mp' */
    mp = rmp;
    r = allowed(core_name, &s_buf, W_BIT); /* is core_file writable */ // W_BIT is int
    s = allowed(".", &d_buf, W_BIT);                                   /* is directory writable? */
    mp = xmp;
    if (r >= 0)
        close(r); // r is fd
    if (s >= 0)
        close(s);
    if (rmp->mp_effuid == SUPER_USER) // SUPER_USER is uid (uint16_t)
        r = 0;                        /* su can always dump core */

    if (s >= 0 && (r >= 0 || r == ErrorCode::ENOENT)) {
        /* Either file is writable or it doesn't exist & dir is writable */
        r = creat(core_name, CORE_MODE); // CORE_MODE is int
        tell_fs(CHDIR, 0, 1, 0);         /* go back to MM's own dir */
        if (r < 0)
            return;
        rmp->mp_sigstatus |= DUMPED; // mp_sigstatus is char, DUMPED is int

        /* First loop through segments and write each length on core file. */
        for (i = 0; i < NR_SEGS; i++) { // NR_SEGS is int
            // rmp->mp_seg[i].mem_len is vir_clicks (std::size_t). CLICK_SHIFT is int.
            len = rmp->mp_seg[i].mem_len << CLICK_SHIFT;
            if (write(r, reinterpret_cast<char *>(&len), sizeof(len)) < 0) { // write takes char*
                close(r);
                return;
            }
        }

        /* Now loop through segments and write the segments themselves out. */
        v_buf = reinterpret_cast<std::size_t>(buf); // buf is char[]
        dest = v_buf;
        for (i = 0; i < NR_SEGS; i++) {
            // rmp->mp_seg[i].mem_vir and mem_len are vir_clicks (std::size_t)
            a = rmp->mp_seg[i].mem_vir << CLICK_SHIFT;
            c = rmp->mp_seg[i].mem_len << CLICK_SHIFT;

            /* Loop through a segment, dumping it. */
            while (c > 0) {
                ct = std::min(c, static_cast<std::size_t>(DUMP_SIZE)); // DUMP_SIZE is int
                // mem_copy takes (int, int, uintptr_t, int, int, uintptr_t, std::size_t)
                // a (src_vir) and dest (dst_vir) are std::size_t (addresses). Cast to uintptr_t.
                // ct (bytes) is std::size_t.
                er1 = mem_copy(slot, i, static_cast<uintptr_t>(a), MM_PROC_NR, D,
                               static_cast<uintptr_t>(dest), ct);
                er2 = write(r, buf, static_cast<int>(ct)); // write takes int count
                if (er1 < 0 || er2 < 0) {
                    close(r);
                    return;
                }
                a += ct;
                c -= ct;
            }
        }
    } else {
        tell_fs(CHDIR, 0, 1, 0); /* go back to MM's own dir */
        close(r);                // r might be error code here
        return;
    }

    close(r); // r is fd
}
