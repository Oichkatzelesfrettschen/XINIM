!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABS	h/const.hpp	/^inline constexpr int ABS = -999;       \/\/ this process means absolute memory$/;"	v
ACCESS	h/callnr.hpp	/^inline constexpr int ACCESS = 33;$/;"	v
ACK	commands/svcctl.hpp	/^    ACK = 6,           \/\/!< Generic acknowledgement$/;"	m	class:svcctl::Message
ADEFN	commands/make.cpp	1064;"	d	file:
AEAD_NONCE_SIZE	kernel/lattice_ipc.hpp	/^inline constexpr std::size_t AEAD_NONCE_SIZE = 24;$/;"	m	namespace:lattice
AEAD_TAG_SIZE	kernel/lattice_ipc.hpp	/^inline constexpr std::size_t AEAD_TAG_SIZE = 16;$/;"	m	namespace:lattice
AL	commands/mined1.cpp	/^char *CE, *VS, *SO, *SE, *CL, *AL, *CM;$/;"	v
ALARM	h/callnr.hpp	/^inline constexpr int ALARM = 27;$/;"	v
ALARM_ON	mm/mproc.hpp	/^inline constexpr unsigned int ALARM_ON = 020; \/**< Set when the SIGALRM timer is active. *\/$/;"	v
ALIGN	commands/sh1.cpp	737;"	d	file:
ALIGN	lib/malloc.cpp	7;"	d	file:
ALL_MODES	h/const.hpp	/^inline constexpr mask_bits ALL_MODES = 0006777;       \/\/ all bits for user, group and others$/;"	v
AMACRO	commands/make.cpp	1066;"	d	file:
ANY	h/com.hpp	/^inline constexpr int ANY = NR_PROCS + 100; \/* receive(ANY, buf) accepts from any source *\/$/;"	v
ANY	lib/regexp.cpp	81;"	d	file:
ANYBUT	lib/regexp.cpp	83;"	d	file:
ANYOF	lib/regexp.cpp	82;"	d	file:
ANY_NODE	kernel/lattice_ipc.hpp	/^inline constexpr net::node_t ANY_NODE = -1;$/;"	m	namespace:lattice
API_H	crypto/kyber_impl/api.h	2;"	d
APPEND	commands/ar.cpp	/^constexpr int APPEND = 2;$/;"	v
AR	common/math/Makefile	/^AR := ar$/;"	m
AR	lib/Makefile	/^AR ?= ar$/;"	m
ARCH_MACROS	tools/arch_scan.py	/^ARCH_MACROS = [$/;"	v
ARFLAGS	common/math/Makefile	/^ARFLAGS := rcs$/;"	m
ARULE	commands/make.cpp	1065;"	d	file:
ASCII	commands/sort.cpp	64;"	d	file:
ASCII	commands/tr.cpp	15;"	d	file:
ASLD	commands/cc.cpp	/^char *ASLD = "\/usr\/bin\/asld";$/;"	v
ASLD_FLAGS	commands/cc.cpp	/^struct arglist ASLD_FLAGS;$/;"	v	typeref:struct:arglist
ASSERT_STROBE	kernel/printer.cpp	37;"	d	file:
AT_SIGN	kernel/tty.cpp	79;"	d	file:
AT_WINI_VECTOR	kernel/const.hpp	/^inline constexpr int AT_WINI_VECTOR = 119;$/;"	v
AUTOMATIC	tools/fsck.cpp	/^    AUTOMATIC,   \/\/\/< Automatic repair mode$/;"	m	class:minix::fsck::FsckMode	file:
A_BLR	tools/c86/dos2out.cpp	97;"	d	file:
A_EXEC	tools/c86/dos2out.cpp	74;"	d	file:
A_HDR_LEN	tools/c86/dos2out.cpp	76;"	d	file:
A_I8086	tools/c86/dos2out.cpp	75;"	d	file:
A_SEP	tools/c86/dos2out.cpp	73;"	d	file:
A_WLR	tools/c86/dos2out.cpp	98;"	d	file:
Aflag	commands/dosread.cpp	/^BOOL Rflag, Lflag, Aflag, dos_read, dos_write, dos_dir;$/;"	v
AlreadyExists	include/minix/fs/inode.hpp	/^    AlreadyExists,$/;"	m	class:minix::fs::InodeError
Architecture	kernel/main.cpp	/^enum class Architecture : uint8_t {$/;"	c	file:
ArgumentParser	tools/build.cpp	/^    class ArgumentParser {$/;"	c	class:minix::builder::ProgramType::BootImageBuilder	file:
Arguments	tools/build.cpp	/^        struct Arguments {$/;"	s	class:minix::builder::ProgramType::BootImageBuilder::ArgumentParser	file:
BACK	lib/regexp.cpp	85;"	d	file:
BAD	commands/dosread.cpp	58;"	d	file:
BAD_CYL	kernel/floppy.cpp	70;"	d	file:
BAD_INODE	tools/fsck.cpp	/^    BAD_INODE,$/;"	m	class:minix::fsck::InodeType	file:
BAD_SECTOR	kernel/floppy.cpp	69;"	d	file:
BASE	commands/cc.cpp	/^USTRING BASE;$/;"	v
BEEP_FREQ	kernel/tty.cpp	797;"	d	file:
BEGIN_LINE	commands/mined.hpp	114;"	d
BEGIN_LINE	include/mined.hpp	107;"	d
BIGGER	commands/mined.hpp	/^    BIGGER,$/;"	e	enum:ReturnCode::FLAG
BIGGER	include/mined.hpp	/^    BIGGER,$/;"	e	enum:ReturnCode::FLAG
BIN	commands/mkfs.cpp	60;"	d	file:
BIN	tools/mkfs.cpp	54;"	d	file:
BINGRP	commands/mkfs.cpp	61;"	d	file:
BINGRP	tools/mkfs.cpp	55;"	d	file:
BIT	include/sh.hpp	/^constexpr int BIT(int i) { return 1 << i; }$/;"	f
BITMAP_MASK	tools/fsck.cpp	/^    static constexpr std::uint32_t BITMAP_MASK = (1U << BIT_SHIFT) - 1;$/;"	m	struct:minix::fsck::FsckConstants	file:
BITMAP_SHIFT	tools/fsck.cpp	/^    static constexpr std::size_t BITMAP_SHIFT = 13;$/;"	m	struct:minix::fsck::FsckConstants	file:
BIT_MAP_SHIFT	commands/mkfs.cpp	62;"	d	file:
BIT_MAP_SHIFT	fs/super.cpp	30;"	d	file:
BIT_MAP_SHIFT	tools/mkfs.cpp	56;"	d	file:
BIT_SHIFT	tools/fsck.cpp	/^    static constexpr std::size_t BIT_SHIFT = 4;$/;"	m	struct:minix::fsck::FsckConstants	file:
BKSLSH	commands/make.cpp	125;"	d	file:
BL	commands/mined2.cpp	/^BL() { move_to(LINE_START, y); }$/;"	f
BLANK	commands/dd.cpp	79;"	d	file:
BLANK	commands/sort.cpp	65;"	d	file:
BLANK	commands/tail.cpp	12;"	d	file:
BLANK	kernel/tty.cpp	799;"	d	file:
BLKSIZ	commands/sh4.cpp	378;"	d	file:
BLOCK	commands/lpr.cpp	11;"	d	file:
BLOCK_BOUNDARY	commands/tar.cpp	33;"	d	file:
BLOCK_SIZE	commands/ar.cpp	/^constexpr std::size_t BLOCK_SIZE = 1024;$/;"	v
BLOCK_SIZE	commands/cmp.cpp	10;"	d	file:
BLOCK_SIZE	commands/mined.hpp	/^inline constexpr int BLOCK_SIZE = 1024; \/\/ Block size in bytes$/;"	v
BLOCK_SIZE	commands/tar.cpp	60;"	d	file:
BLOCK_SIZE	h/const.hpp	/^inline constexpr int BLOCK_SIZE = 1024; \/\/ number of bytes in a disk block$/;"	v
BLOCK_SIZE	include/blocksiz.hpp	/^inline constexpr int BLOCK_SIZE = 1024; \/\/ File system data block size$/;"	v
BLOCK_SIZE	include/mined.hpp	/^inline constexpr int BLOCK_SIZE = 1024; \/\/ Block size in bytes$/;"	v
BLOCK_SIZE	tools/fsck.cpp	/^constexpr std::uint32_t BLOCK_SIZE = 1024;$/;"	v
BLOCK_SPECIAL	tools/fsck.cpp	/^    BLOCK_SPECIAL,$/;"	m	class:minix::fsck::InodeType	file:
BOL	lib/regexp.cpp	79;"	d	file:
BOOL	commands/sort.cpp	/^enum BOOL { \/* Boolean types *\/$/;"	g	file:
BOOT_BLOCK	fs/const.hpp	/^inline constexpr block_nr BOOT_BLOCK = static_cast<block_nr>(0);  \/* block number of boot block *\/$/;"	v
BOOT_DEV	h/const.hpp	/^inline constexpr dev_nr BOOT_DEV = static_cast<dev_nr>(512);$/;"	v
BOOT_SIGNATURE	tools/bootblok1.cpp	/^    static constexpr std::array<u8_t, 2> BOOT_SIGNATURE = {0x55, 0xaa};$/;"	m	class:minix::bootloader::BootSector	file:
BOOT_SIGNATURE_OFFSET	tools/bootblok1.cpp	/^    static constexpr std::size_t BOOT_SIGNATURE_OFFSET = 510;$/;"	m	class:minix::bootloader::BootSector	file:
BOTH	h/com.hpp	/^inline constexpr int BOTH = 3;             \/* function code for SEND + RECEIVE *\/$/;"	v
BRACKET	commands/mined2.cpp	1230;"	d	file:
BRANCH	lib/regexp.cpp	84;"	d	file:
BREAD	commands/mkfs.cpp	66;"	d	file:
BREAD	commands/mkfs.cpp	69;"	d	file:
BREAD	tools/mkfs.cpp	60;"	d	file:
BREAD	tools/mkfs.cpp	63;"	d	file:
BREAK	commands/sh2.cpp	26;"	d	file:
BRK	h/callnr.hpp	/^inline constexpr int BRK = 17;$/;"	v
BRK2	h/callnr.hpp	/^inline constexpr int BRK2 = 66;       \/* to MM: used to say how big FS & INIT are *\/$/;"	v
BSS	commands/chmem.cpp	13;"	d	file:
BSS	commands/size.cpp	12;"	d	file:
BSSB	mm/exec.cpp	34;"	d	file:
BUFFER_SIZE	commands/tr.cpp	14;"	d	file:
BUFSIZ	commands/comm.cpp	20;"	d	file:
BUFSIZ	commands/libpack.cpp	13;"	d	file:
BUFSIZ	include/stdio.hpp	/^inline constexpr std::size_t BUFSIZ = 1024;$/;"	v
BUFSIZE	commands/cc.cpp	343;"	d	file:
BUFSIZE	fs/putc.cpp	12;"	d	file:
BUF_SIZE	commands/cat.cpp	/^constexpr std::size_t BUF_SIZE = 512; \/* size of the output buffer *\/$/;"	v
BUF_SIZE	commands/tail.cpp	105;"	d	file:
BUF_SIZE	mm/putc.cpp	11;"	d	file:
BUILDDIR	tools/Makefile	/^BUILDDIR := build$/;"	m
BUSY	commands/mined1.cpp	1140;"	d	file:
BUSY	commands/sh1.cpp	736;"	d	file:
BUSY	kernel/tty.cpp	145;"	d	file:
BUSY	lib/malloc.cpp	8;"	d	file:
BUSY_STATUS	kernel/printer.cpp	36;"	d	file:
BWRITE	commands/mkfs.cpp	67;"	d	file:
BWRITE	commands/mkfs.cpp	70;"	d	file:
BWRITE	tools/mkfs.cpp	61;"	d	file:
BWRITE	tools/mkfs.cpp	64;"	d	file:
BYTE	h/const.hpp	/^inline constexpr int BYTE = BYTE_MASK; \/\/ alias for legacy code$/;"	v
BYTE_AVAIL	kernel/tty.cpp	824;"	d	file:
BYTE_MASK	h/const.hpp	/^inline constexpr int BYTE_MASK = 0377; \/\/ mask for 8 bits (Original name: BYTE)$/;"	v
B_TIME	kernel/tty.cpp	798;"	d	file:
BitNumber	tools/fsck.cpp	/^    explicit BitNumber(std::uint32_t bit) : value(bit) {}$/;"	f	struct:minix::fsck::ZoneLevel::BitNumber
BitNumber	tools/fsck.cpp	/^struct BitNumber {$/;"	s	class:minix::fsck::ZoneLevel	file:
Bitmap	tools/fsck.cpp	/^    explicit Bitmap(std::size_t bit_count)$/;"	f	class:minix::fsck::ZoneLevel::Bitmap
Bitmap	tools/fsck.cpp	/^class Bitmap {$/;"	c	class:minix::fsck::ZoneLevel	file:
BlockFlags	include/minix/fs/const.hpp	/^namespace BlockFlags {$/;"	n	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
BlockSpecial	include/minix/fs/inode.hpp	/^    BlockSpecial = std::to_underlying(FileTypes::kBlockSpecial),$/;"	m	class:minix::fs::InodeType
BlockType	fs/buf.hpp	/^enum class BlockType : int {$/;"	c
BlockType	include/minix/fs/const.hpp	/^enum class BlockType : std::uint8_t {$/;"	c	class:minix::fs::FsConstants::IoMode::DirOp
Blocked	kernel/wormhole.hpp	/^enum class ThreadStatus { Running, Blocked, SendBlocked, RecvBlocked };$/;"	m	class:fastpath::ThreadStatus
BootImageBuilder	tools/build.cpp	/^    explicit BootImageBuilder(const std::string &output_path) {$/;"	f	class:minix::builder::ProgramType::BootImageBuilder
BootImageBuilder	tools/build.cpp	/^class BootImageBuilder {$/;"	c	class:minix::builder::ProgramType	file:
BootSector	tools/bootblok1.cpp	/^    BootSector() : sector_buffer(boot_sector_data) { validate(); }$/;"	f	class:minix::bootloader::BootSector
BootSector	tools/bootblok1.cpp	/^class BootSector {$/;"	c	namespace:minix::bootloader	file:
BootSectorExtractor	tools/bootblok1.cpp	/^class BootSectorExtractor {$/;"	c	namespace:minix::bootloader	file:
Buf	lib/prints.cpp	/^char Buf[TRUNC_SIZE], *Bufp;$/;"	v
Buffer	include/minix/fs/buffer.hpp	/^class Buffer {$/;"	c	namespace:minix::fs
BufferData	include/minix/fs/buffer.hpp	/^class BufferData {$/;"	c	namespace:minix::fs
BufferDataType	include/minix/fs/buffer.hpp	/^concept BufferDataType = requires {$/;"	m	namespace:minix::fs
BufferError	include/minix/fs/buffer.hpp	/^enum class BufferError {$/;"	c	namespace:minix::fs
BufferGuard	include/minix/fs/buffer.hpp	/^    BufferGuard(BufferHandle handle, BlockType type)$/;"	f	class:minix::fs::BufferGuard
BufferGuard	include/minix/fs/buffer.hpp	/^class BufferGuard {$/;"	c	namespace:minix::fs
BufferHandle	include/minix/fs/buffer.hpp	/^    explicit BufferHandle(Buffer *buf, bool owned = true) : buffer_{buf}, owned_{owned} {}$/;"	f	class:minix::fs::BufferHandle
BufferHandle	include/minix/fs/buffer.hpp	/^class BufferHandle {$/;"	c	namespace:minix::fs
BufferInUse	include/minix/fs/buffer.hpp	/^    BufferInUse,$/;"	m	class:minix::fs::BufferError
BufferPool	include/minix/fs/buffer.hpp	/^class BufferPool {$/;"	c	namespace:minix::fs
BufferState	include/minix/fs/const.hpp	/^    enum class BufferState : std::uint8_t { Clean = 0, Dirty = 1 };$/;"	c	class:minix::fs::FsConstants::IoMode::DirOp
Bufp	lib/prints.cpp	/^char Buf[TRUNC_SIZE], *Bufp;$/;"	v
BuildConstants	tools/build.cpp	/^struct BuildConstants {$/;"	s	namespace:minix::builder	file:
ByteOffset	tools/build.cpp	/^    explicit ByteOffset(std::size_t val) : value(val) {}$/;"	f	struct:minix::builder::ByteOffset
ByteOffset	tools/build.cpp	/^struct ByteOffset {$/;"	s	namespace:minix::builder	file:
CACHE_LINE_SIZE	tools/diskio.hpp	/^    static constexpr std::uint32_t CACHE_LINE_SIZE = 64;          \/\/\/< CPU cache line size$/;"	m	struct:diskio::DiskConstants
CACHE_SIZE	commands/mkfs.cpp	768;"	d	file:
CACHE_SIZE	tools/diskio.hpp	/^    static constexpr std::size_t CACHE_SIZE = 64; \/\/\/< Number of cached sectors$/;"	m	class:DiskInterface
CACHE_SIZE	tools/mkfs.cpp	763;"	d	file:
CALIBRATED	kernel/floppy.cpp	130;"	d	file:
CALL_VEC	commands/cc.cpp	/^struct arglist CALL_VEC[2];$/;"	v	typeref:struct:arglist
CANCEL	h/com.hpp	/^inline constexpr int CANCEL = 0;$/;"	v
CANCELED	kernel/printer.cpp	47;"	d	file:
CASE	commands/sh2.cpp	32;"	d	file:
CATEGORY_PREFIXES	tools/migration_dashboard.py	/^CATEGORY_PREFIXES = ['fs\/', 'kernel\/', 'mm\/', 'lib\/', 'commands\/', 'tools\/', 'test\/']$/;"	v
CBD_H	crypto/kyber_impl/cbd.h	2;"	d
CBREAK	include/sgtty.hpp	/^    CBREAK = 0000002, \/**< enable cbreak mode *\/$/;"	m	class:SgFlags
CC	commands/Makefile	/^CC ?= clang$/;"	m
CC	lib/Makefile	/^CC ?= clang$/;"	m
CC	test/Makefile	/^CC ?= clang$/;"	m
CC	test/minix/Makefile	/^CC ?= clang$/;"	m
CC	tools/minix/Makefile	/^CC ?= clang$/;"	m
CE	commands/mined1.cpp	/^char *CE, *VS, *SO, *SE, *CL, *AL, *CM;$/;"	v
CEM	commands/cc.cpp	/^char *CEM = "\/lib\/cem";$/;"	v
CEM	commands/cc.cpp	/^char *CEM = "\/usr\/lib\/cem";$/;"	v
CEM_FLAGS	commands/cc.cpp	/^struct arglist CEM_FLAGS;$/;"	v	typeref:struct:arglist
CFLAGS	commands/Makefile	/^CFLAGS ?= -F$/;"	m
CFLAGS	lib/Makefile	/^CFLAGS ?= -O2$/;"	m
CFLAGS	test/Makefile	/^CFLAGS ?= -O$/;"	m
CFLAGS	test/minix/Makefile	/^CFLAGS ?= -F$/;"	m
CFLAGS	tools/minix/Makefile	/^CFLAGS ?= -F$/;"	m
CG	commands/cc.cpp	/^char *CG = "\/usr\/lib\/cg";$/;"	v
CG_FLAGS	commands/cc.cpp	/^struct arglist CG_FLAGS;$/;"	v	typeref:struct:arglist
CHANGE	kernel/floppy.cpp	72;"	d	file:
CHARBITS	include/regexp.hpp	/^inline constexpr int CHARBITS = 0377;$/;"	v
CHAR_SPECIAL	tools/fsck.cpp	/^    CHAR_SPECIAL,$/;"	m	class:minix::fsck::InodeType	file:
CHDIR	h/callnr.hpp	/^inline constexpr int CHDIR = 12;$/;"	v
CHECK_ONLY	tools/fsck.cpp	/^    CHECK_ONLY,  \/\/\/< Read-only checking$/;"	m	class:minix::fsck::FsckMode	file:
CHILD_NODE	tests/test_lattice_ipv6.cpp	/^static constexpr net::node_t CHILD_NODE = 1;$/;"	v	file:
CHILD_NODE	tests/test_lattice_network.cpp	/^static constexpr net::node_t CHILD_NODE = 1;$/;"	v	file:
CHILD_NODE	tests/test_lattice_network_encrypted.cpp	/^static constexpr net::node_t CHILD_NODE = 1;$/;"	v	file:
CHILD_NODE	tests/test_net_driver.cpp	/^static constexpr net::node_t CHILD_NODE = 1;$/;"	v	file:
CHILD_NODE	tests/test_net_driver_drop_newest.cpp	/^constexpr net::node_t CHILD_NODE = 1;$/;"	m	namespace:__anon13	file:
CHILD_NODE	tests/test_net_driver_ipv6.cpp	/^constexpr net::node_t CHILD_NODE = 1;$/;"	m	namespace:__anon11	file:
CHILD_NODE	tests/test_net_driver_overflow.cpp	/^constexpr net::node_t CHILD_NODE = 1;$/;"	m	namespace:__anon6	file:
CHILD_NODE	tests/test_net_driver_reconnect.cpp	/^constexpr net::node_t CHILD_NODE = 1;$/;"	m	namespace:__anon12	file:
CHILD_NODE	tests/test_net_driver_tcp.cpp	/^constexpr net::node_t CHILD_NODE = 1;$/;"	m	namespace:__anon9	file:
CHILD_NODE	tests/test_net_two_node.cpp	/^static constexpr net::node_t CHILD_NODE = 1;$/;"	v	file:
CHILD_NODE	tests/test_poll_network.cpp	/^static constexpr net::node_t CHILD_NODE = 1;$/;"	v	file:
CHILD_PORT	tests/test_lattice_ipv6.cpp	/^static constexpr std::uint16_t CHILD_PORT = 12601;$/;"	v	file:
CHILD_PORT	tests/test_lattice_network.cpp	/^static constexpr uint16_t CHILD_PORT = 12001;$/;"	v	file:
CHILD_PORT	tests/test_lattice_network_encrypted.cpp	/^static constexpr std::uint16_t CHILD_PORT = 12501;$/;"	v	file:
CHILD_PORT	tests/test_net_driver.cpp	/^static constexpr uint16_t CHILD_PORT = 14001;$/;"	v	file:
CHILD_PORT	tests/test_net_driver_drop_newest.cpp	/^constexpr std::uint16_t CHILD_PORT = 14201;$/;"	m	namespace:__anon13	file:
CHILD_PORT	tests/test_net_driver_overflow.cpp	/^constexpr std::uint16_t CHILD_PORT = 14101;$/;"	m	namespace:__anon6	file:
CHILD_PORT	tests/test_net_driver_reconnect.cpp	/^constexpr uint16_t CHILD_PORT = 15501;$/;"	m	namespace:__anon12	file:
CHILD_PORT	tests/test_net_driver_tcp.cpp	/^constexpr uint16_t CHILD_PORT = 15001;$/;"	m	namespace:__anon9	file:
CHILD_PORT	tests/test_net_two_node.cpp	/^static constexpr std::uint16_t CHILD_PORT = 13001;$/;"	v	file:
CHILD_PORT	tests/test_poll_network.cpp	/^static constexpr std::uint16_t CHILD_PORT = 15001;$/;"	v	file:
CHMEM	commands/size.cpp	13;"	d	file:
CHMOD	h/callnr.hpp	/^inline constexpr int CHMOD = 15;$/;"	v
CHOWN	h/callnr.hpp	/^inline constexpr int CHOWN = 16;$/;"	v
CHROOT	h/callnr.hpp	/^inline constexpr int CHROOT = 61;$/;"	v
CHUNK_DIRECT	tools/fsck.cpp	/^    static constexpr std::size_t CHUNK_DIRECT = 16;$/;"	m	struct:minix::fsck::FsckConstants	file:
CHUNK_INDIRECT	tools/fsck.cpp	/^    static constexpr std::size_t CHUNK_INDIRECT = 128;$/;"	m	struct:minix::fsck::FsckConstants	file:
CL	commands/mined1.cpp	/^char *CE, *VS, *SO, *SE, *CL, *AL, *CM;$/;"	v
CLEAN	fs/const.hpp	/^inline constexpr int CLEAN = 0; \/* disk and memory copies identical *\/$/;"	v
CLICK_SHIFT	h/const.hpp	/^inline constexpr int CLICK_SHIFT = 4;   \/\/ log2 of CLICK_SIZE$/;"	v
CLICK_SHIFT	tools/build.cpp	/^    static constexpr std::size_t CLICK_SHIFT = 4;       \/\/\/< Bit shift for 16-byte memory clicks$/;"	m	struct:minix::builder::BuildConstants	file:
CLICK_SIZE	h/const.hpp	/^inline constexpr int CLICK_SIZE = 0020; \/\/ allocation unit in bytes (16 in decimal)$/;"	v
CLICK_SIZE	lib/malloc.cpp	2;"	d	file:
CLICK_TO_K	mm/main.cpp	33;"	d	file:
CLIENT_PID	commands/svcctl.hpp	/^inline constexpr xinim::pid_t CLIENT_PID = 200; \/\/\/< PID used by svcctl$/;"	m	class:svcctl::Message
CLOCK	h/com.hpp	/^inline constexpr int CLOCK = -3;     \/* clock class *\/$/;"	v
CLOCK_TICK	h/com.hpp	/^inline constexpr int CLOCK_TICK = 2; \/* fcn code for clock tick *\/$/;"	v
CLOCK_VECTOR	kernel/const.hpp	/^inline constexpr int CLOCK_VECTOR = 32;$/;"	v
CLOSE	h/callnr.hpp	/^inline constexpr int CLOSE = 6;$/;"	v
CLOSE	lib/regexp.cpp	92;"	d	file:
CM	commands/mined1.cpp	/^char *CE, *VS, *SO, *SE, *CL, *AL, *CM;$/;"	v
CMASK	commands/sh1.cpp	665;"	d	file:
CMASK	include/stdio.hpp	/^inline constexpr int CMASK = 0377;$/;"	v
COLOR_BASE	kernel/tty.cpp	789;"	d	file:
COMMON_MATH_OCTONION_HPP	common/math/octonion.hpp	2;"	d
COMMON_MATH_QUATERNION_HPP	common/math/quaternion.hpp	2;"	d
COMMON_MATH_SEDENION_HPP	common/math/sedenion.hpp	2;"	d
COMPILERFLAG	commands/mkfs.cpp	31;"	d	file:
COMPILERFLAG	commands/mkfs.cpp	38;"	d	file:
COMPILERFLAG	tools/mkfs.cpp	25;"	d	file:
COMPILERFLAG	tools/mkfs.cpp	32;"	d	file:
CONSOLE	kernel/tty.cpp	804;"	d	file:
CONSOLE_H	console.h	2;"	d
CONTIN	commands/sh2.cpp	43;"	d	file:
COOKED	include/sgtty.hpp	/^    COOKED = 0000000  \/**< neither CBREAK nor RAW *\/$/;"	m	class:SgFlags
COPYV	include/sh.hpp	/^    COPYV = 1,   \/* flag to setval, suggesting copy *\/$/;"	e	enum:VarFlag
COPY_UNIT	kernel/system.cpp	71;"	d	file:
CORE_MODE	mm/signal.cpp	35;"	d	file:
CREAT	h/callnr.hpp	/^inline constexpr int CREAT = 8;$/;"	v
CREATE	commands/ar.cpp	/^constexpr int CREATE = 1;$/;"	v
CRMOD	include/sgtty.hpp	/^    CRMOD = 0000020,  \/**< map LF to CR+LF *\/$/;"	m	class:SgFlags
CRYPTO_ALGNAME	crypto/kyber_impl/kem.h	13;"	d
CRYPTO_ALGNAME	crypto/kyber_impl/kem.h	15;"	d
CRYPTO_ALGNAME	crypto/kyber_impl/kem.h	17;"	d
CRYPTO_BYTES	crypto/kyber_impl/kem.h	10;"	d
CRYPTO_CIPHERTEXTBYTES	crypto/kyber_impl/kem.h	9;"	d
CRYPTO_PUBLICKEYBYTES	crypto/kyber_impl/kem.h	8;"	d
CRYPTO_SECRETKEYBYTES	crypto/kyber_impl/kem.h	7;"	d
CS_REG	kernel/const.hpp	/^inline constexpr int CS_REG = 0;$/;"	v
CTL_ACCEPTING	kernel/floppy.cpp	60;"	d	file:
CTL_BUSY	kernel/floppy.cpp	59;"	d	file:
CTRL	commands/mined2.cpp	/^CTRL() {$/;"	f
CTRL_BYTE	kernel/wini.cpp	63;"	d	file:
CTRL_BYTE	kernel/xt_wini.cpp	60;"	d	file:
CTRL_S	kernel/tty.cpp	802;"	d	file:
CURSOR	kernel/tty.cpp	820;"	d	file:
CUR_SIZE	kernel/tty.cpp	818;"	d	file:
CXX	common/math/Makefile	/^CXX := g++$/;"	m
CXX	test/Makefile	/^CXX ?= clang++$/;"	m
CXX	tools/Makefile	/^CXX := clang++$/;"	m
CXXFLAGS	common/math/Makefile	/^CXXFLAGS := -std=c++23 -Wall -Wextra -pedantic -O2 -fPIC -I.$/;"	m
CXXFLAGS	test/Makefile	/^CXXFLAGS ?= -std=c++23 -O$/;"	m
CXXFLAGS	tools/Makefile	/^CXXFLAGS := -std=c++23 -Wall -Wextra -Wpedantic -Werror -O2$/;"	m
C_6845	kernel/tty.cpp	815;"	d	file:
C_RETRACE	kernel/tty.cpp	793;"	d	file:
C_VID_MASK	kernel/tty.cpp	791;"	d	file:
CacheEntry	tools/diskio.hpp	/^        CacheEntry(SectorAddress addr, SectorBuffer buf)$/;"	f	struct:DiskInterface::CacheEntry
CacheEntry	tools/diskio.hpp	/^    struct CacheEntry {$/;"	s	class:DiskInterface
CapRights	kernel/wormhole.hpp	/^struct CapRights {$/;"	s	namespace:fastpath
CapType	kernel/wormhole.hpp	/^enum class CapType { Endpoint };$/;"	c	namespace:fastpath
Capability	kernel/wormhole.hpp	/^struct Capability {$/;"	s	namespace:fastpath
Channel	kernel/lattice_ipc.hpp	/^struct Channel {$/;"	s	namespace:lattice
CharSpecial	include/minix/fs/inode.hpp	/^    CharSpecial = std::to_underlying(FileTypes::kCharSpecial),$/;"	m	class:minix::fs::InodeType
Clean	include/minix/fs/const.hpp	/^    enum class BufferState : std::uint8_t { Clean = 0, Dirty = 1 };$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
Common	common/math/octonion.cpp	/^namespace Common {$/;"	n	file:
Common	common/math/octonion.hpp	/^namespace Common {$/;"	n
Common	common/math/quaternion.cpp	/^namespace Common {$/;"	n	file:
Common	common/math/quaternion.hpp	/^namespace Common {$/;"	n
Common	common/math/sedenion.cpp	/^namespace Common {$/;"	n	file:
Common	common/math/sedenion.hpp	/^namespace Common {$/;"	n
CorruptedData	include/minix/fs/inode.hpp	/^    CorruptedData,$/;"	m	class:minix::fs::InodeError
D	h/const.hpp	/^inline constexpr int D = 1;         \/\/ data segment index$/;"	v
DATA	commands/chmem.cpp	12;"	d	file:
DATA	commands/size.cpp	11;"	d	file:
DATA	kernel/tty.cpp	817;"	d	file:
DATAB	lib/c86/prologue.hpp	/^    DGROUP GROUP @DATAB,$/;"	v
DATAB	mm/exec.cpp	33;"	d	file:
DATAC	lib/c86/prologue.hpp	/^    @DATAC, @DATAI, @DATAT, @DATAU, @DATAV$/;"	v
DATAI	lib/c86/prologue.hpp	/^    @DATAC, @DATAI, @DATAT, @DATAU, @DATAV$/;"	v
DATAT	lib/c86/prologue.hpp	/^    @DATAC, @DATAI, @DATAT, @DATAU, @DATAV$/;"	v
DATAU	lib/c86/prologue.hpp	/^    @DATAC, @DATAI, @DATAT, @DATAU, @DATAV$/;"	v
DATA_CHANGED	mm/break.cpp	/^constexpr int DATA_CHANGED = 1;  \/* flag value when data segment size changed *\/$/;"	v
DAY	commands/ar.cpp	473;"	d	file:
DAY	commands/dosread.cpp	634;"	d	file:
DAYS_PER_WEEK	commands/cal.cpp	/^constexpr int DAYS_PER_WEEK = 7;   \/* Sunday, etc.			*\/$/;"	v
DCC	commands/mined2.cpp	/^DCC() {$/;"	f
DDDD	commands/dosread.cpp	25;"	d	file:
DDHD	commands/dosread.cpp	26;"	d	file:
DEBUG_FLAGS	commands/cc.cpp	/^struct arglist DEBUG_FLAGS;$/;"	v	typeref:struct:arglist
DEBUG_FLAGS	tools/Makefile	/^DEBUG_FLAGS := -g -DDEBUG -fsanitize=address -fsanitize=undefined$/;"	m
DEFAULT	commands/dd.cpp	80;"	d	file:
DEFAULT	commands/head.cpp	12;"	d	file:
DEFAULT_BUFFER_SIZE	tools/diskio.hpp	/^    static constexpr std::size_t DEFAULT_BUFFER_SIZE = 64 * 1024; \/\/\/< Default buffer size (64KB)$/;"	m	struct:diskio::DiskConstants
DEFAULT_COLOR	console.h	25;"	d
DEFS_H	include/defs.hpp	8;"	d
DELAY_COUNT	kernel/printer.cpp	48;"	d	file:
DELAY_LOOP	kernel/printer.cpp	49;"	d	file:
DELC	commands/stty.cpp	21;"	d	file:
DELETE	commands/mined.hpp	/^    DELETE,$/;"	e	enum:ReturnCode::FLAG
DELETE	fs/const.hpp	/^inline constexpr int DELETE = 2;  \/* tells search_dir to delete entry *\/$/;"	v
DELETE	include/mined.hpp	/^    DELETE,$/;"	e	enum:ReturnCode::FLAG
DELETE	include/sh.hpp	350;"	d
DELUXE	kernel/tty.cpp	826;"	d	file:
DEL_CODE	kernel/tty.cpp	78;"	d	file:
DEV_PER_DRIVE	kernel/at_wini.cpp	/^inline constexpr int DEV_PER_DRIVE = 5;     \/* hd0 + hd1 + hd2 + hd3 + hd4 = 5 *\/$/;"	m	namespace:__anon18	file:
DEV_PER_DRIVE	kernel/wini.cpp	82;"	d	file:
DEV_PER_DRIVE	kernel/xt_wini.cpp	79;"	d	file:
DICT	commands/sort.cpp	63;"	d	file:
DIGIT	commands/sort.cpp	66;"	d	file:
DIGIT	tools/init.cpp	11;"	d	file:
DIR	commands/dosread.cpp	50;"	d	file:
DIRECT	tools/fsck.cpp	/^    DIRECT = 0,$/;"	m	class:minix::fsck::ZoneLevel	file:
DIRECTION	kernel/floppy.cpp	58;"	d	file:
DIRECTIVE	commands/make.cpp	1067;"	d	file:
DIRECTORY	tools/fsck.cpp	/^    DIRECTORY,$/;"	m	class:minix::fsck::InodeType	file:
DIRNAMELEN	commands/ls.cpp	16;"	d	file:
DIRSIZ	commands/sh4.cpp	368;"	d	file:
DIRTY	fs/const.hpp	/^inline constexpr int DIRTY = 1; \/* disk and memory copies differ *\/$/;"	v
DIR_ENTRY_SIZE	fs/const.hpp	/^inline constexpr std::size_t DIR_ENTRY_SIZE = sizeof(dir_struct);          \/* # bytes\/dir entry *\/$/;"	v
DIR_SIZE	commands/dosread.cpp	51;"	d	file:
DISKINT	h/com.hpp	/^inline constexpr int DISKINT = 1;     \/* fcn code for disk interrupt *\/$/;"	v
DISK_IOCTL	h/com.hpp	/^inline constexpr int DISK_IOCTL = 5;  \/* fcn code for setting up RAM disk *\/$/;"	v
DISK_READ	h/com.hpp	/^inline constexpr int DISK_READ = 3;   \/* fcn code to DISK (must equal TTY_READ) *\/$/;"	v
DISK_WRITE	h/com.hpp	/^inline constexpr int DISK_WRITE = 4;  \/* fcn code to DISK (must equal TTY_WRITE) *\/$/;"	v
DIVIDE_VECTOR	kernel/const.hpp	/^inline constexpr int DIVIDE_VECTOR = 0;$/;"	v
DIVISOR	kernel/floppy.cpp	109;"	d	file:
DLN	commands/mined2.cpp	/^DLN() {$/;"	f
DMA_ADDR	kernel/floppy.cpp	39;"	d	file:
DMA_ADDR	kernel/wini.cpp	45;"	d	file:
DMA_ADDR	kernel/xt_wini.cpp	42;"	d	file:
DMA_COUNT	kernel/floppy.cpp	41;"	d	file:
DMA_COUNT	kernel/wini.cpp	47;"	d	file:
DMA_COUNT	kernel/xt_wini.cpp	44;"	d	file:
DMA_INIT	kernel/floppy.cpp	44;"	d	file:
DMA_INIT	kernel/wini.cpp	50;"	d	file:
DMA_INIT	kernel/xt_wini.cpp	47;"	d	file:
DMA_INT	kernel/wini.cpp	60;"	d	file:
DMA_INT	kernel/xt_wini.cpp	57;"	d	file:
DMA_M1	kernel/floppy.cpp	43;"	d	file:
DMA_M1	kernel/wini.cpp	49;"	d	file:
DMA_M1	kernel/xt_wini.cpp	46;"	d	file:
DMA_M2	kernel/floppy.cpp	42;"	d	file:
DMA_M2	kernel/wini.cpp	48;"	d	file:
DMA_M2	kernel/xt_wini.cpp	45;"	d	file:
DMA_READ	kernel/floppy.cpp	83;"	d	file:
DMA_READ	kernel/wini.cpp	66;"	d	file:
DMA_READ	kernel/xt_wini.cpp	63;"	d	file:
DMA_TOP	kernel/floppy.cpp	40;"	d	file:
DMA_TOP	kernel/wini.cpp	46;"	d	file:
DMA_TOP	kernel/xt_wini.cpp	43;"	d	file:
DMA_WRITE	kernel/floppy.cpp	84;"	d	file:
DMA_WRITE	kernel/wini.cpp	67;"	d	file:
DMA_WRITE	kernel/xt_wini.cpp	64;"	d	file:
DN	commands/mined2.cpp	/^void DN() {$/;"	f
DNW	commands/mined2.cpp	/^DNW() {$/;"	f
DO	commands/sh2.cpp	37;"	d	file:
DOALL	include/sh.hpp	/^inline constexpr int DOALL = DOSUB | DOBLANK | DOGLOB | DOKEY | DOTRIM;$/;"	v
DOBLANK	include/sh.hpp	/^inline constexpr int DOBLANK = 2; \/* perform blank interpretation *\/$/;"	v
DOGLOB	include/sh.hpp	/^inline constexpr int DOGLOB = 4;  \/* interpret [?* *\/$/;"	v
DOKEY	include/sh.hpp	/^inline constexpr int DOKEY = 8;   \/* move words with `=' to 2nd arg. list *\/$/;"	v
DONE	commands/make.cpp	1063;"	d	file:
DONE	commands/mined2.cpp	1232;"	d	file:
DONE	commands/sh2.cpp	38;"	d	file:
DOR	kernel/floppy.cpp	35;"	d	file:
DOS	tools/c86/dos2out.cpp	77;"	d	file:
DOSUB	include/sh.hpp	/^inline constexpr int DOSUB = 1;   \/* interpret $, `, and quotes *\/$/;"	v
DOS_TIME	commands/dosread.cpp	67;"	d	file:
DOT	commands/mined2.cpp	1227;"	d	file:
DOTRIM	include/sh.hpp	/^inline constexpr int DOTRIM = 16; \/* trim resulting string *\/$/;"	v
DOUBLE_INDIRECT	tools/fsck.cpp	/^    DOUBLE_INDIRECT = 2,$/;"	m	class:minix::fsck::ZoneLevel	file:
DPC	commands/mined2.cpp	/^DPC() {$/;"	f
DPW	commands/mined2.cpp	/^DPW() {$/;"	f
DRIVE	commands/dosread.cpp	22;"	d	file:
DRIVE_NR	commands/dosread.cpp	23;"	d	file:
DRIVE_NUMBER_OFFSET	tools/bootblok1.cpp	/^    static constexpr std::size_t DRIVE_NUMBER_OFFSET = 0xfd; \/\/ Offset 253$/;"	m	class:minix::bootloader::BootSector	file:
DS_OFFSET	tools/build.cpp	/^    static constexpr std::size_t DS_OFFSET = 4;         \/\/\/< Offset for data segment value in kernel$/;"	m	struct:minix::builder::BuildConstants	file:
DS_REG	kernel/const.hpp	/^inline constexpr int DS_REG = 0;$/;"	v
DT	commands/mined2.cpp	/^DT() { set_up(DELETE); }$/;"	f
DTL	kernel/floppy.cpp	90;"	d	file:
DUMMY	commands/mined.hpp	106;"	d
DUMMY	include/mined.hpp	99;"	d
DUMMY_MASK	commands/mined.hpp	107;"	d
DUMMY_MASK	include/mined.hpp	100;"	d
DUMPED	mm/signal.cpp	36;"	d	file:
DUMP_SIZE	mm/signal.cpp	34;"	d	file:
DUP	h/callnr.hpp	/^inline constexpr int DUP = 41;$/;"	v
DUP_MASK	fs/const.hpp	/^inline constexpr int DUP_MASK = 0100; \/* mask to distinguish dup2 from dup *\/$/;"	v
D_FMT_SIZE	tools/c86/dos2out.cpp	41;"	d	file:
Delete	include/minix/fs/const.hpp	/^    enum class DirOp : std::uint8_t { LookUp = 0, Enter = 1, Delete = 2 };$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp
DirOp	include/minix/fs/const.hpp	/^    enum class DirOp : std::uint8_t { LookUp = 0, Enter = 1, Delete = 2 };$/;"	c	class:minix::fs::FsConstants::IoMode
Directory	fs/buf.hpp	/^    Directory = 1 + WriteImmediate,$/;"	m	class:BlockType
Directory	include/minix/fs/inode.hpp	/^    Directory = std::to_underlying(FileTypes::kDirectory),$/;"	m	class:minix::fs::InodeType
DirectoryBlock	include/minix/fs/const.hpp	/^    DirectoryBlock = 1,$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
DirectoryEntry	tools/fsck.cpp	/^class DirectoryEntry {$/;"	c	class:minix::fsck::ZoneLevel	file:
Dirty	include/minix/fs/const.hpp	/^    enum class BufferState : std::uint8_t { Clean = 0, Dirty = 1 };$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
DiskConstants	tools/diskio.hpp	/^struct DiskConstants {$/;"	s	namespace:diskio
DiskError	include/minix/fs/buffer.hpp	/^    DiskError,$/;"	m	class:minix::fs::BufferError
DiskError	include/minix/fs/inode.hpp	/^    DiskError,$/;"	m	class:minix::fs::InodeError
DiskInterface	tools/diskio.cpp	/^DiskInterface::DiskInterface(const std::string &device_path, bool read_only)$/;"	f	class:diskio::DiskInterface
DiskInterface	tools/diskio.hpp	/^class DiskInterface {$/;"	c
DiskIoError	tools/diskio.hpp	/^    DiskIoError(const std::string &device_path, SectorAddress sector, const std::string &operation,$/;"	f	class:DiskIoError
DiskIoError	tools/diskio.hpp	/^class DiskIoError : public std::runtime_error {$/;"	c
E2BIG	h/error.hpp	/^    E2BIG = -7,    \/\/ Arg list too long$/;"	m	class:ErrorCode
E2BIG	h/error.hpp	16;"	d
E2BIG	include/errno.hpp	/^    E2BIG = 7,    \/\/ Argument list too long$/;"	m	class:Errno
EACCES	h/error.hpp	/^    EACCES = -13,  \/\/ Permission denied$/;"	m	class:ErrorCode
EACCES	h/error.hpp	22;"	d
EACCES	include/errno.hpp	/^    EACCES = 13,  \/\/ Permission denied$/;"	m	class:Errno
EAGAIN	h/error.hpp	/^    EAGAIN = -11,  \/\/ Try again$/;"	m	class:ErrorCode
EAGAIN	h/error.hpp	20;"	d
EAGAIN	include/errno.hpp	/^    EAGAIN = 11,  \/\/ Try again$/;"	m	class:Errno
EBADF	h/error.hpp	/^    EBADF = -9,    \/\/ Bad file number$/;"	m	class:ErrorCode
EBADF	h/error.hpp	18;"	d
EBADF	include/errno.hpp	/^    EBADF = 9,    \/\/ Bad file number$/;"	m	class:Errno
EBUSY	h/error.hpp	/^    EBUSY = -16,   \/\/ Resource busy$/;"	m	class:ErrorCode
EBUSY	h/error.hpp	25;"	d
EBUSY	include/errno.hpp	/^    EBUSY = 16,   \/\/ Device or resource busy$/;"	m	class:Errno
ECHILD	h/error.hpp	/^    ECHILD = -10,  \/\/ No children$/;"	m	class:ErrorCode
ECHILD	h/error.hpp	19;"	d
ECHILD	include/errno.hpp	/^    ECHILD = 10,  \/\/ No child processes$/;"	m	class:Errno
ECHO	include/sgtty.hpp	/^    ECHO = 0000010,   \/**< echo input *\/$/;"	m	class:SgFlags
EDOM	h/error.hpp	/^    EDOM = -33,    \/\/ Math argument$/;"	m	class:ErrorCode
EDOM	h/error.hpp	42;"	d
EDOM	include/errno.hpp	/^    EDOM = 33,    \/\/ Math argument out of domain$/;"	m	class:Errno
EEXIST	h/error.hpp	/^    EEXIST = -17,  \/\/ File exists$/;"	m	class:ErrorCode
EEXIST	h/error.hpp	26;"	d
EEXIST	include/errno.hpp	/^    EEXIST = 17,  \/\/ File exists$/;"	m	class:Errno
EF	commands/mined2.cpp	/^EF() {$/;"	f
EFAULT	h/error.hpp	/^    EFAULT = -14,  \/\/ Bad address$/;"	m	class:ErrorCode
EFAULT	h/error.hpp	23;"	d
EFAULT	include/errno.hpp	/^    EFAULT = 14,  \/\/ Bad address$/;"	m	class:Errno
EFBIG	h/error.hpp	/^    EFBIG = -27,   \/\/ File too large$/;"	m	class:ErrorCode
EFBIG	h/error.hpp	36;"	d
EFBIG	include/errno.hpp	/^    EFBIG = 27,   \/\/ File too large$/;"	m	class:Errno
EINTR	h/error.hpp	/^    EINTR = -4,    \/\/ Interrupted system call$/;"	m	class:ErrorCode
EINTR	h/error.hpp	13;"	d
EINTR	include/errno.hpp	/^    EINTR = 4,    \/\/ Interrupted system call$/;"	m	class:Errno
EINVAL	h/error.hpp	/^    EINVAL = -22,  \/\/ Invalid argument$/;"	m	class:ErrorCode
EINVAL	h/error.hpp	31;"	d
EINVAL	include/errno.hpp	/^    EINVAL = 22,  \/\/ Invalid argument$/;"	m	class:Errno
EIO	h/error.hpp	/^    EIO = -5,      \/\/ I\/O error$/;"	m	class:ErrorCode
EIO	h/error.hpp	14;"	d
EIO	include/errno.hpp	/^    EIO = 5,      \/\/ I\/O error$/;"	m	class:Errno
EISDIR	h/error.hpp	/^    EISDIR = -21,  \/\/ Is a directory$/;"	m	class:ErrorCode
EISDIR	h/error.hpp	30;"	d
EISDIR	include/errno.hpp	/^    EISDIR = 21,  \/\/ Is a directory$/;"	m	class:Errno
EL	commands/mined2.cpp	/^EL() { move_to(LINE_END, y); }$/;"	f
ELIF	commands/sh2.cpp	30;"	d	file:
ELSE	commands/sh2.cpp	29;"	d	file:
EMFILE	h/error.hpp	/^    EMFILE = -24,  \/\/ Too many open files$/;"	m	class:ErrorCode
EMFILE	h/error.hpp	33;"	d
EMFILE	include/errno.hpp	/^    EMFILE = 24,  \/\/ Too many open files$/;"	m	class:Errno
EMLINK	h/error.hpp	/^    EMLINK = -31,  \/\/ Too many links$/;"	m	class:ErrorCode
EMLINK	h/error.hpp	40;"	d
EMLINK	include/errno.hpp	/^    EMLINK = 31,  \/\/ Too many links$/;"	m	class:Errno
EMPTY	commands/mined.hpp	/^    EMPTY,$/;"	e	enum:ReturnCode::FLAG
EMPTY	include/mined.hpp	/^    EMPTY,$/;"	e	enum:ReturnCode::FLAG
ENABLE	kernel/const.hpp	/^inline constexpr int ENABLE = 0x20;$/;"	v
ENABLE_INT	kernel/floppy.cpp	62;"	d	file:
END	commands/svcctl.hpp	/^    END = 7,           \/\/!< End of list indicator$/;"	m	class:svcctl::Message
END	lib/regexp.cpp	78;"	d	file:
END_LINE	commands/mined.hpp	115;"	d
END_LINE	include/mined.hpp	108;"	d
ENFILE	h/error.hpp	/^    ENFILE = -23,  \/\/ File table overflow$/;"	m	class:ErrorCode
ENFILE	h/error.hpp	32;"	d
ENFILE	include/errno.hpp	/^    ENFILE = 23,  \/\/ File table overflow$/;"	m	class:Errno
ENODEV	h/error.hpp	/^    ENODEV = -19,  \/\/ No such device$/;"	m	class:ErrorCode
ENODEV	h/error.hpp	28;"	d
ENODEV	include/errno.hpp	/^    ENODEV = 19,  \/\/ No such device$/;"	m	class:Errno
ENOENT	h/error.hpp	/^    ENOENT = -2,   \/\/ No such file or directory$/;"	m	class:ErrorCode
ENOENT	h/error.hpp	11;"	d
ENOENT	include/errno.hpp	/^    ENOENT = 2,   \/\/ No such file or directory$/;"	m	class:Errno
ENOEXEC	h/error.hpp	/^    ENOEXEC = -8,  \/\/ Exec format error$/;"	m	class:ErrorCode
ENOEXEC	h/error.hpp	17;"	d
ENOEXEC	include/errno.hpp	/^    ENOEXEC = 8,  \/\/ Exec format error$/;"	m	class:Errno
ENOMEM	h/error.hpp	/^    ENOMEM = -12,  \/\/ Out of memory$/;"	m	class:ErrorCode
ENOMEM	h/error.hpp	21;"	d
ENOMEM	include/errno.hpp	/^    ENOMEM = 12,  \/\/ Out of memory$/;"	m	class:Errno
ENOSPC	h/error.hpp	/^    ENOSPC = -28,  \/\/ No space left on device$/;"	m	class:ErrorCode
ENOSPC	h/error.hpp	37;"	d
ENOSPC	include/errno.hpp	/^    ENOSPC = 28,  \/\/ No space left on device$/;"	m	class:Errno
ENOTBLK	h/error.hpp	/^    ENOTBLK = -15, \/\/ Block device required$/;"	m	class:ErrorCode
ENOTBLK	h/error.hpp	24;"	d
ENOTBLK	include/errno.hpp	/^    ENOTBLK = 15, \/\/ Block device required$/;"	m	class:Errno
ENOTDIR	h/error.hpp	/^    ENOTDIR = -20, \/\/ Not a directory$/;"	m	class:ErrorCode
ENOTDIR	h/error.hpp	29;"	d
ENOTDIR	include/errno.hpp	/^    ENOTDIR = 20, \/\/ Not a directory$/;"	m	class:Errno
ENOTTY	h/error.hpp	/^    ENOTTY = -25,  \/\/ Not a typewriter$/;"	m	class:ErrorCode
ENOTTY	h/error.hpp	34;"	d
ENOTTY	include/errno.hpp	/^    ENOTTY = 25,  \/\/ Not a typewriter$/;"	m	class:Errno
ENOUGH	mm/main.cpp	31;"	d	file:
ENTER	fs/const.hpp	/^inline constexpr int ENTER = 1;   \/* tells search_dir to make dir entry *\/$/;"	v
ENTRY	commands/dosread.cpp	76;"	d	file:
ENTRY_SIZE	commands/cal.cpp	/^constexpr int ENTRY_SIZE = 3;      \/* 3 bytes per value		*\/$/;"	v
ENXIO	h/error.hpp	/^    ENXIO = -6,    \/\/ No such device or address$/;"	m	class:ErrorCode
ENXIO	h/error.hpp	15;"	d
ENXIO	include/errno.hpp	/^    ENXIO = 6,    \/\/ No such device or address$/;"	m	class:Errno
EOF	commands/dosread.cpp	84;"	d	file:
EOF	commands/mined.hpp	16;"	d
EOF	commands/rev.cpp	21;"	d	file:
EOF	include/mined.hpp	16;"	d
EOFC	commands/stty.cpp	20;"	d	file:
EOF_ERROR	h/error.hpp	/^    EOF_ERROR = -104,     \/\/ End of file for drivers$/;"	m	class:ErrorCode
EOF_MARK	commands/dosread.cpp	85;"	d	file:
EOL	lib/regexp.cpp	80;"	d	file:
EOLN	commands/mined2.cpp	1228;"	d	file:
EOS	commands/cal.cpp	/^constexpr char EOS = 0;$/;"	v
EOS	commands/dd.cpp	10;"	d	file:
EOT_CHAR	kernel/tty.cpp	76;"	d	file:
EPERM	h/error.hpp	/^    EPERM = -1,    \/\/ Operation not permitted$/;"	m	class:ErrorCode
EPERM	h/error.hpp	10;"	d
EPERM	include/errno.hpp	/^    EPERM = 1,    \/\/ Operation not permitted$/;"	m	class:Errno
EPIPE	h/error.hpp	/^    EPIPE = -32,   \/\/ Broken pipe$/;"	m	class:ErrorCode
EPIPE	h/error.hpp	41;"	d
EPIPE	include/errno.hpp	/^    EPIPE = 32,   \/\/ Broken pipe$/;"	m	class:Errno
EQ	commands/make.cpp	130;"	d	file:
ERANGE	h/error.hpp	/^    ERANGE = -34,  \/\/ Result too large$/;"	m	class:ErrorCode
ERANGE	h/error.hpp	43;"	d
ERANGE	include/errno.hpp	/^    ERANGE = 34,  \/\/ Result too large$/;"	m	class:Errno
ERASED	commands/dosread.cpp	49;"	d	file:
ERASE_CHAR	kernel/tty.cpp	70;"	d	file:
EROFS	h/error.hpp	/^    EROFS = -30,   \/\/ Read-only file system$/;"	m	class:ErrorCode
EROFS	h/error.hpp	39;"	d
EROFS	include/errno.hpp	/^    EROFS = 30,   \/\/ Read-only file system$/;"	m	class:Errno
ERR	include/stdio.hpp	/^constexpr int ERR = 16;$/;"	v
ERR	kernel/at_wini.cpp	/^inline constexpr int ERR = -1; \/* general error *\/$/;"	m	namespace:__anon18	file:
ERR	kernel/wini.cpp	74;"	d	file:
ERR	kernel/xt_wini.cpp	71;"	d	file:
ERROR	commands/make.cpp	126;"	d	file:
ERROR	commands/make.cpp	127;"	d	file:
ERROR	commands/sort.cpp	52;"	d	file:
ERROR	h/error.hpp	/^    ERROR = -1,    \/\/ Generic error$/;"	m	class:ErrorCode
ERROR	include/errno.hpp	/^constexpr int ERROR = 1; \/\/ generic failure code$/;"	v
ERR_DRIVE	kernel/floppy.cpp	102;"	d	file:
ERR_RECALIBRATE	kernel/floppy.cpp	100;"	d	file:
ERR_SEEK	kernel/floppy.cpp	97;"	d	file:
ERR_STATUS	kernel/floppy.cpp	99;"	d	file:
ERR_TRANSFER	kernel/floppy.cpp	98;"	d	file:
ERR_WR_PROTECT	kernel/floppy.cpp	101;"	d	file:
ESAC	commands/sh2.cpp	33;"	d	file:
ESC	commands/mined1.cpp	/^ESC() {$/;"	f
ESCAPED	kernel/tty.cpp	141;"	d	file:
ESPIPE	h/error.hpp	/^    ESPIPE = -29,  \/\/ Illegal seek$/;"	m	class:ErrorCode
ESPIPE	h/error.hpp	38;"	d
ESPIPE	include/errno.hpp	/^    ESPIPE = 29,  \/\/ Illegal seek$/;"	m	class:Errno
ESRCH	h/error.hpp	/^    ESRCH = -3,    \/\/ No such process$/;"	m	class:ErrorCode
ESRCH	h/error.hpp	12;"	d
ESRCH	include/errno.hpp	/^    ESRCH = 3,    \/\/ No such process$/;"	m	class:Errno
ES_REG	kernel/const.hpp	/^inline constexpr int ES_REG = 0;$/;"	v
ETXTBSY	h/error.hpp	/^    ETXTBSY = -26, \/\/ Text file busy$/;"	m	class:ErrorCode
ETXTBSY	h/error.hpp	35;"	d
ETXTBSY	include/errno.hpp	/^    ETXTBSY = 26, \/\/ Text file busy$/;"	m	class:Errno
EXACTLY	lib/regexp.cpp	86;"	d	file:
EXDEV	h/error.hpp	/^    EXDEV = -18,   \/\/ Cross-device link$/;"	m	class:ErrorCode
EXDEV	h/error.hpp	27;"	d
EXDEV	include/errno.hpp	/^    EXDEV = 18,   \/\/ Cross-device link$/;"	m	class:Errno
EXEC	h/callnr.hpp	/^inline constexpr int EXEC = 59;$/;"	v
EXIT	h/callnr.hpp	/^inline constexpr int EXIT = 1;$/;"	v
EXPORT	include/sh.hpp	/^    EXPORT = 02, \/* variable is to be exported *\/$/;"	e	enum:VarFlag
EXTERN	commands/mkfs.cpp	24;"	d	file:
EXTERN	commands/mkfs.cpp	25;"	d	file:
EXTERN	fs/glo.hpp	2;"	d
EXTERN	fs/table.cpp	12;"	d	file:
EXTERN	fs/table.cpp	13;"	d	file:
EXTERN	h/const.hpp	17;"	d
EXTERN	kernel/glo.hpp	5;"	d
EXTERN	kernel/table.cpp	30;"	d	file:
EXTERN	kernel/table.cpp	31;"	d	file:
EXTERN	mm/table.cpp	10;"	d	file:
EXTERN	mm/table.cpp	9;"	d	file:
EXTERN	tools/mkfs.cpp	18;"	d	file:
EXTERN	tools/mkfs.cpp	19;"	d	file:
E_BAD_ADDR	h/error.hpp	/^    E_BAD_ADDR = -10,  \/\/ bad address given to utility routine$/;"	m	class:ErrorCode
E_BAD_BUF	h/error.hpp	/^    E_BAD_BUF = -5,    \/\/ message buffer outside caller address space$/;"	m	class:ErrorCode
E_BAD_CALL	h/error.hpp	/^    E_BAD_CALL = -102,    \/\/ Bad system call$/;"	m	class:ErrorCode
E_BAD_CALL	include/errno.hpp	/^    E_BAD_CALL = 102,   \/\/ Bad system call$/;"	m	class:Errno
E_BAD_DEST	h/error.hpp	/^    E_BAD_DEST = -1,   \/\/ destination address illegal$/;"	m	class:ErrorCode
E_BAD_FCN	h/error.hpp	/^    E_BAD_FCN = -9,    \/\/ only valid functions are SEND, RECEIVE, BOTH$/;"	m	class:ErrorCode
E_BAD_PROC	h/error.hpp	/^    E_BAD_PROC = -11   \/\/ bad proc number given to utility$/;"	m	class:ErrorCode
E_BAD_SRC	h/error.hpp	/^    E_BAD_SRC = -2,    \/\/ source address illegal$/;"	m	class:ErrorCode
E_LOCKED	h/error.hpp	/^    E_LOCKED = -101,      \/\/ Table locked$/;"	m	class:ErrorCode
E_LOCKED	include/errno.hpp	/^    E_LOCKED = 101,     \/\/ Table locked$/;"	m	class:Errno
E_LONG_STRING	h/error.hpp	/^    E_LONG_STRING = -103, \/\/ String is too long$/;"	m	class:ErrorCode
E_LONG_STRING	include/errno.hpp	/^    E_LONG_STRING = 103 \/\/ String is too long$/;"	m	class:Errno
E_NO_MESSAGE	h/error.hpp	/^    E_NO_MESSAGE = -7, \/\/ RECEIVE failed: no message present$/;"	m	class:ErrorCode
E_NO_PERM	h/error.hpp	/^    E_NO_PERM = -8,    \/\/ ordinary users can't send to tasks$/;"	m	class:ErrorCode
E_OVERRUN	h/error.hpp	/^    E_OVERRUN = -4,    \/\/ interrupt for task that is not waiting$/;"	m	class:ErrorCode
E_TASK	h/error.hpp	/^    E_TASK = -6,       \/\/ can't send to task$/;"	m	class:ErrorCode
E_TRY_AGAIN	h/error.hpp	/^    E_TRY_AGAIN = -3,  \/\/ tables full$/;"	m	class:ErrorCode
Endpoint	kernel/wormhole.hpp	/^struct Endpoint {$/;"	s	namespace:fastpath
EndpointState	kernel/wormhole.hpp	/^enum class EndpointState { Idle, Send, Recv };$/;"	c	namespace:fastpath
Enter	include/minix/fs/const.hpp	/^    enum class DirOp : std::uint8_t { LookUp = 0, Enter = 1, Delete = 2 };$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp
Entry	tools/fsck.cpp	/^        Entry(inode_nr ino, std::string n) : inode_number(ino), name(std::move(n)) {}$/;"	f	struct:minix::fsck::ZoneLevel::DirectoryEntry::Entry
Entry	tools/fsck.cpp	/^    struct Entry {$/;"	s	class:minix::fsck::ZoneLevel::DirectoryEntry	file:
Errno	include/errno.hpp	/^enum class Errno : int {$/;"	c
ErrorCode	h/error.hpp	/^enum class ErrorCode : int {$/;"	c
Errors	commands/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	m	class:ReturnCode
Errors	include/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	m	class:ReturnCode
ExecutableHeader	tools/build.cpp	/^    explicit ExecutableHeader(std::ifstream &file) {$/;"	f	class:minix::builder::ProgramType::ExecutableHeader
ExecutableHeader	tools/build.cpp	/^class ExecutableHeader {$/;"	c	class:minix::builder::ProgramType	file:
F1	kernel/tty.cpp	81;"	d	file:
F10	kernel/tty.cpp	83;"	d	file:
F2	kernel/tty.cpp	82;"	d	file:
FAIL	lib/regexp.cpp	139;"	d	file:
FALSE	commands/dosread.cpp	64;"	d	file:
FALSE	commands/make.cpp	129;"	d	file:
FALSE	commands/tail.cpp	11;"	d	file:
FALSE	commands/tar.cpp	29;"	d	file:
FALSE	commands/tr.cpp	20;"	d	file:
FALSE	h/const.hpp	/^inline constexpr bool FALSE = false; \/\/\/< Boolean false$/;"	v
FALSE	include/mined.hpp	/^    FALSE,$/;"	e	enum:ReturnCode::FLAG
FALSE_ENUM	commands/mined.hpp	/^    FALSE_ENUM = 0, \/\/ Renamed to avoid conflict with potential macros\/keywords$/;"	e	enum:ReturnCode::FLAG
FALSE_ENUM	commands/sort.cpp	/^            FALSE_ENUM = 0,$/;"	e	enum:BOOL	file:
FAT_START	commands/dosread.cpp	31;"	d	file:
FDBASE	include/sh.hpp	/^inline constexpr int FDBASE = 10; \/* First file usable by Shell *\/$/;"	v
FDC_DATA	kernel/floppy.cpp	37;"	d	file:
FDC_RATE	kernel/floppy.cpp	38;"	d	file:
FDC_READ	kernel/floppy.cpp	76;"	d	file:
FDC_RECALIBRATE	kernel/floppy.cpp	79;"	d	file:
FDC_SEEK	kernel/floppy.cpp	75;"	d	file:
FDC_SENSE	kernel/floppy.cpp	78;"	d	file:
FDC_SPECIFY	kernel/floppy.cpp	80;"	d	file:
FDC_STATUS	kernel/floppy.cpp	36;"	d	file:
FDC_WRITE	kernel/floppy.cpp	77;"	d	file:
FD_MASK	fs/read.cpp	37;"	d	file:
FEXEC	include/sh.hpp	/^inline constexpr int FEXEC = BIT(0); \/* execute without forking *\/$/;"	v
FI	commands/sh2.cpp	31;"	d	file:
FIELD	commands/sort.cpp	/^struct FIELD {$/;"	s	file:
FIELDS_LIMIT	commands/sort.cpp	88;"	d	file:
FILE	include/stdio.hpp	42;"	d
FILE_LENGTH	commands/mined.hpp	51;"	d
FILE_LENGTH	include/mined.hpp	51;"	d
FIND	commands/dosread.cpp	74;"	d	file:
FIPS202_H	crypto/kyber_impl/fips202.h	2;"	d
FIPS202_NAMESPACE	crypto/kyber_impl/fips202.h	12;"	d
FLAG	commands/mined.hpp	/^enum FLAG {$/;"	g	class:ReturnCode
FLAG	include/mined.hpp	/^enum FLAG {$/;"	g	class:ReturnCode
FLOPPY	h/com.hpp	/^inline constexpr int FLOPPY = -5;     \/* floppy disk class *\/$/;"	v
FLOPPY_VECTOR	kernel/const.hpp	/^inline constexpr int FLOPPY_VECTOR = 35;$/;"	v
FNAME	tools/c86/dos2out.cpp	106;"	d	file:
FOR	commands/sh2.cpp	34;"	d	file:
FORK	h/callnr.hpp	/^inline constexpr int FORK = 2;$/;"	v
FORWARD	commands/mined.hpp	/^    FORWARD,$/;"	e	enum:ReturnCode::FLAG
FORWARD	include/mined.hpp	/^    FORWARD,$/;"	e	enum:ReturnCode::FLAG
FREE	commands/dosread.cpp	57;"	d	file:
FREE	commands/sh1.cpp	735;"	d	file:
FROM_USER	h/const.hpp	/^inline constexpr int FROM_USER = 1;    \/\/ copy from user to fs$/;"	v
FS	commands/libpack.cpp	15;"	d	file:
FS	commands/mined1.cpp	/^FS() { fstatus(file_name[0] ? "" : "[buffer]", -1L); }$/;"	f
FS	include/lib.hpp	/^inline constexpr int FS = 1; \/\/ file system index$/;"	v
FS	tools/build.cpp	/^    FS = 2,     \/\/\/< File System - manages file operations$/;"	m	class:minix::builder::ProgramType	file:
FSCK	tools/build.cpp	/^    FSCK = 4    \/\/\/< File System Checker - disk integrity tool$/;"	m	class:minix::builder::ProgramType	file:
FSTAT	h/callnr.hpp	/^inline constexpr int FSTAT = 28;$/;"	v
FS_COMPAT_H	fs/compat.hpp	3;"	d
FS_DATA_MAGIC	tools/build.cpp	/^    static constexpr std::uint16_t FS_DATA_MAGIC =$/;"	m	struct:minix::builder::BuildConstants	file:
FS_EXTENT_H	fs/extent.hpp	3;"	d
FS_PROC_NR	h/const.hpp	/^inline constexpr int FS_PROC_NR = 1;   \/\/ file system process number$/;"	v
FS_STACK_BYTES	fs/const.hpp	/^inline constexpr std::size_t FS_STACK_BYTES = 512; \/* size of file system stack *\/$/;"	v
F_flag	commands/cc.cpp	/^int F_flag = 0; \/* use pipes by default *\/$/;"	v
F_l_u_s_h	mm/putc.cpp	/^PRIVATE F_l_u_s_h() {$/;"	f
FastpathStats	kernel/wormhole.hpp	/^    FastpathStats() {$/;"	f	struct:fastpath::FastpathStats
FastpathStats	kernel/wormhole.hpp	/^struct FastpathStats {$/;"	s	namespace:fastpath
File	commands/roff.cpp	/^FILE *File, *Macread, *Macwrite;$/;"	v
FileDescriptor	mm/utility.cpp	/^    explicit FileDescriptor(int f) : fd(f) {}$/;"	f	struct:__anon4::FileDescriptor
FileDescriptor	mm/utility.cpp	/^struct FileDescriptor {$/;"	s	namespace:__anon4	file:
FileStream	include/minix/io/file_stream.hpp	/^    explicit FileStream(int fd, bool write) : fd_(fd), writable_(write) {}$/;"	f	class:minix::io::FileStream
FileStream	include/minix/io/file_stream.hpp	/^class FileStream : public Stream {$/;"	c	namespace:minix::io
FileTime	include/minix/fs/inode.hpp	/^    FileTime() : time_point_{std::chrono::system_clock::now()} {}$/;"	f	class:minix::fs::InodeType::FileTime
FileTime	include/minix/fs/inode.hpp	/^    explicit FileTime(real_time legacy_time)$/;"	f	class:minix::fs::InodeType::FileTime
FileTime	include/minix/fs/inode.hpp	/^class FileTime {$/;"	c	class:minix::fs::InodeType
FileType	include/minix/fs/inode.hpp	/^concept FileType = requires {$/;"	m	namespace:minix::fs
FileTypes	include/minix/fs/const.hpp	/^namespace FileTypes {$/;"	n	class:minix::fs::FsConstants::IoMode::DirOp
FilesystemChecker	tools/fsck.cpp	/^    explicit FilesystemChecker(diskio::DiskInterface &disk, FsckMode mode)$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker
FilesystemChecker	tools/fsck.cpp	/^class FilesystemChecker {$/;"	c	class:minix::fsck::ZoneLevel	file:
FilesystemStatistics	tools/fsck.cpp	/^struct FilesystemStatistics {$/;"	s	class:minix::fsck::ZoneLevel	file:
Fine	commands/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	m	class:ReturnCode
Fine	include/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	m	class:ReturnCode
FsConstants	include/minix/fs/const.hpp	/^struct FsConstants {$/;"	s	namespace:minix::fs
FsckApplication	tools/fsck.cpp	/^class FsckApplication {$/;"	c	class:minix::fsck::ZoneLevel	file:
FsckConstants	tools/fsck.cpp	/^struct FsckConstants {$/;"	s	namespace:minix::fsck	file:
FsckMode	tools/fsck.cpp	/^enum class FsckMode {$/;"	c	namespace:minix::fsck	file:
FullData	fs/buf.hpp	/^    FullData = 6,$/;"	m	class:BlockType
FullDataBlock	include/minix/fs/const.hpp	/^    FullDataBlock = 6,$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
GEN_LDFILES	commands/cc.cpp	/^struct arglist GEN_LDFILES;$/;"	v	typeref:struct:arglist
GEN_MATRIX_NBLOCKS	crypto/kyber_impl/indcpa.c	163;"	d	file:
GETCELL	include/sh.hpp	/^    GETCELL = 04 \/* name & value space was got with getcell *\/$/;"	e	enum:VarFlag
GETGID	h/callnr.hpp	/^inline constexpr int GETGID = 47;$/;"	v
GETPID	h/callnr.hpp	/^inline constexpr int GETPID = 20;$/;"	v
GETUID	h/callnr.hpp	/^inline constexpr int GETUID = 24;$/;"	v
GET_ARG	lib/doprintf.cpp	55;"	d	file:
GET_TIME	h/com.hpp	/^inline constexpr int GET_TIME = 3;   \/* fcn code to CLOCK, get real time *\/$/;"	v
GET_TYPE	kernel/tty.cpp	827;"	d	file:
GLOBAL	commands/sort.cpp	89;"	d	file:
GOTO	commands/mined2.cpp	/^GOTO() {$/;"	f
GO_BACKWARD	kernel/tty.cpp	806;"	d	file:
GO_FORWARD	kernel/tty.cpp	805;"	d	file:
GR	commands/mined2.cpp	/^GR() { change("Global replace:", VALID); }$/;"	f
GROWBY	commands/sh1.cpp	733;"	d	file:
Graph	kernel/lattice_ipc.hpp	/^class Graph {$/;"	c	namespace:lattice
HANGING	mm/mproc.hpp	/^inline constexpr unsigned int HANGING = 004;  \/**< Set by the EXIT system call. *\/$/;"	v
HARDWARE	h/com.hpp	/^inline constexpr int HARDWARE = -1; \/* used as source on interrupt generated msgs *\/$/;"	v
HASWIDTH	lib/regexp.cpp	150;"	d	file:
HC_SIZE	kernel/floppy.cpp	88;"	d	file:
HDR_SIZE	mm/const.hpp	/^inline constexpr std::size_t HDR_SIZE = 32;$/;"	v
HEADER	commands/tar.cpp	/^union HEADER {$/;"	u	file:
HEADER_LONG	tools/build.cpp	/^    static constexpr std::size_t HEADER_LONG = 48;  \/\/\/< Long executable header size$/;"	m	struct:minix::builder::BuildConstants	file:
HEADER_SHORT	tools/build.cpp	/^    static constexpr std::size_t HEADER_SHORT = 32; \/\/\/< Short executable header size$/;"	m	struct:minix::builder::BuildConstants	file:
HEADER_SIZE	commands/tar.cpp	31;"	d	file:
HIGH	commands/mined2.cpp	/^HIGH() { move_to(0, 0); }$/;"	f
HIGHER	commands/sort.cpp	58;"	d	file:
HIGH_BYTE	commands/mined2.cpp	1236;"	d	file:
HLONG	commands/chmem.cpp	10;"	d	file:
HLONG	commands/size.cpp	9;"	d	file:
HO	commands/mined2.cpp	/^HO() {$/;"	f
HOUR	commands/ar.cpp	472;"	d	file:
HOUR	commands/dosread.cpp	630;"	d	file:
HZ	h/const.hpp	/^inline constexpr int HZ = 60;           \/\/ clock frequency$/;"	v
H_ERROR_HPP	h/error.hpp	3;"	d
Hole	mm/alloc.cpp	/^struct Hole {$/;"	s	file:
I	commands/mined1.cpp	/^I() {}$/;"	f
I64_C	include/defs.hpp	32;"	d
IBM_FREQ	kernel/clock.cpp	56;"	d	file:
IBUFSIZE	commands/libupack.cpp	131;"	d	file:
IDLE	kernel/const.hpp	/^inline constexpr int IDLE = -999; \/* 'cur_proc' = IDLE means nobody is running *\/$/;"	v
IDTLEN	commands/roff.cpp	16;"	d	file:
IF	commands/mined2.cpp	/^IF() {$/;"	f
IF	commands/sh2.cpp	27;"	d	file:
IGN_ERR	commands/make.cpp	141;"	d	file:
IMap	fs/buf.hpp	/^    IMap = 3 + WriteImmediate + OneShot,$/;"	m	class:BlockType
IN	commands/sh2.cpp	39;"	d	file:
INACTIVE	kernel/tty.cpp	144;"	d	file:
INC	commands/Makefile	/^INC ?= ..\/include$/;"	m
INC	test/Makefile	/^INC ?= ..\/include$/;"	m
INC	test/minix/Makefile	/^INC ?= ..\/include$/;"	m
INC	tools/minix/Makefile	/^INC ?= ..\/include$/;"	m
INCR	commands/tail.cpp	100;"	d	file:
INDCPA_H	crypto/kyber_impl/indcpa.h	2;"	d
INDEX	kernel/tty.cpp	816;"	d	file:
INFO	fs/main.cpp	32;"	d	file:
INIT	tools/build.cpp	/^    INIT = 3,   \/\/\/< Init process - first user process$/;"	m	class:minix::builder::ProgramType	file:
INIT_PRINTER	kernel/printer.cpp	40;"	d	file:
INIT_PROC_NR	h/const.hpp	/^inline constexpr int INIT_PROC_NR = 2; \/\/ init process number$/;"	v
INIT_PSW	kernel/const.hpp	/^inline constexpr int INIT_PSW = 0x0200;$/;"	v
INIT_SP	kernel/const.hpp	/^inline constexpr std::uint64_t *INIT_SP = nullptr; \/\/ Using std::uint64_t from core_types$/;"	v
INI_SRC	kernel/Makefile	/^                                                                  at_wini.cpp else WINI_SRC =$/;"	m
INMAX	commands/make.cpp	143;"	d	file:
INMAXSH	commands/make.cpp	144;"	d	file:
INODES_PER_BLOCK	fs/const.hpp	/^inline constexpr std::size_t INODES_PER_BLOCK = BLOCK_SIZE \/ INODE_SIZE;   \/* # inodes\/disk blk *\/$/;"	v
INODES_PER_BLOCK	tools/fsck.cpp	/^constexpr std::uint32_t INODES_PER_BLOCK = BLOCK_SIZE \/ INODE_SIZE;$/;"	v
INODE_MAP	commands/mkfs.cpp	56;"	d	file:
INODE_MAP	tools/mkfs.cpp	50;"	d	file:
INODE_SIZE	fs/const.hpp	/^inline constexpr std::size_t INODE_SIZE = sizeof(d_inode);                 \/* bytes in disk inode*\/$/;"	v
INODE_SIZE	tools/fsck.cpp	/^constexpr std::uint32_t INODE_SIZE = 32;$/;"	v
INSUB	include/sh.hpp	/^inline bool INSUB() { return e.iop->task == XGRAVE || e.iop->task == XDOLL; }$/;"	f
INT	kernel/wini.cpp	61;"	d	file:
INT	kernel/xt_wini.cpp	58;"	d	file:
INT2_CTL	kernel/const.hpp	/^inline constexpr int INT2_CTL = 0xA0;$/;"	v
INT2_MASK	kernel/const.hpp	/^inline constexpr int INT2_MASK = 0xA1;$/;"	v
INTERACTIVE	tools/fsck.cpp	/^    INTERACTIVE, \/\/\/< Interactive repair mode$/;"	m	class:minix::fsck::FsckMode	file:
INTR_CHAR	kernel/tty.cpp	72;"	d	file:
INTS_PER_BLOCK	fs/const.hpp	/^inline constexpr std::size_t INTS_PER_BLOCK = BLOCK_SIZE \/ sizeof(int);    \/* # integers\/blk *\/$/;"	v
INT_BITS	fs/super.cpp	29;"	d	file:
INT_CTL	kernel/const.hpp	/^inline constexpr int INT_CTL = 0x20;$/;"	v
INT_CTLMASK	kernel/const.hpp	/^inline constexpr int INT_CTLMASK = 0x21;$/;"	v
INT_TYPE	commands/tar.cpp	53;"	d	file:
IN_USE	mm/mproc.hpp	/^inline constexpr unsigned int IN_USE = 001;   \/**< Slot is currently in use. *\/$/;"	v
IOCAT	include/sh.hpp	/^    IOCAT = 8,    \/* >> *\/$/;"	e	enum:IoFlag
IOCLOSE	include/sh.hpp	/^    IOCLOSE = 64  \/* >&- *\/$/;"	e	enum:IoFlag
IOCTL	h/callnr.hpp	/^inline constexpr int IOCTL = 54;$/;"	v
IODEFAULT	include/sh.hpp	/^inline constexpr int IODEFAULT = -1; \/* token for default IO unit *\/$/;"	v
IODUP	include/sh.hpp	/^    IODUP = 32,   \/* >&digit *\/$/;"	e	enum:IoFlag
IOHERE	include/sh.hpp	/^    IOHERE = 2,   \/* << (here file) *\/$/;"	e	enum:IoFlag
IOMYBUF	include/stdio.hpp	/^constexpr int IOMYBUF = 32;$/;"	v
IOREAD	include/sh.hpp	/^    IOREAD = 1,   \/* < *\/$/;"	e	enum:IoFlag
IOWRITE	include/sh.hpp	/^    IOWRITE = 4,  \/* > *\/$/;"	e	enum:IoFlag
IOXHERE	include/sh.hpp	/^    IOXHERE = 16, \/* ${}, ` in << *\/$/;"	e	enum:IoFlag
IO_ERROR	commands/cal.cpp	/^constexpr int IO_ERROR = 1;$/;"	v
IO_SIZE	commands/ar.cpp	/^constexpr std::size_t IO_SIZE = 10 * 1024;$/;"	v
IO_SIZE	commands/shar.cpp	11;"	d	file:
IO_SIZE	commands/sort.cpp	47;"	d	file:
IO_SUCCESS	commands/cal.cpp	/^constexpr int IO_SUCCESS = 0;$/;"	v
ISEEK	fs/inode.hpp	45;"	d
ISMULT	lib/regexp.cpp	144;"	d	file:
IS_EXE	tools/c86/dos2out.cpp	42;"	d	file:
I_BLOCK_SPECIAL	h/const.hpp	/^inline constexpr mask_bits I_BLOCK_SPECIAL = 0060000; \/\/ block special file$/;"	v
I_BLOCK_SPECIAL	tools/fsck.cpp	/^constexpr std::uint16_t I_BLOCK_SPECIAL = 0060000;$/;"	m	class:minix::fsck::ZoneLevel	file:
I_CHAR_SPECIAL	h/const.hpp	/^inline constexpr mask_bits I_CHAR_SPECIAL = 0020000;  \/\/ character special file$/;"	v
I_CHAR_SPECIAL	tools/fsck.cpp	/^constexpr std::uint16_t I_CHAR_SPECIAL = 0020000;$/;"	m	class:minix::fsck::ZoneLevel	file:
I_DIRECTORY	h/const.hpp	/^inline constexpr mask_bits I_DIRECTORY = 0040000;     \/\/ directory file$/;"	v
I_DIRECTORY	tools/fsck.cpp	/^constexpr std::uint16_t I_DIRECTORY = 0040000;$/;"	m	class:minix::fsck::ZoneLevel	file:
I_MAP_SLOTS	fs/const.hpp	/^inline constexpr int I_MAP_SLOTS = 4;              \/* max # of blocks in the inode bit map *\/$/;"	v
I_MOUNT	fs/inode.hpp	43;"	d
I_NOT_ALLOC	h/const.hpp	/^inline constexpr mask_bits I_NOT_ALLOC = 0000000;     \/\/ inode is free$/;"	v
I_PIPE	fs/inode.hpp	41;"	d
I_REGULAR	h/const.hpp	/^inline constexpr mask_bits I_REGULAR = 0100000;       \/\/ regular file$/;"	v
I_REGULAR	tools/fsck.cpp	/^constexpr std::uint16_t I_REGULAR = 0100000;$/;"	m	class:minix::fsck::ZoneLevel	file:
I_SET_GID_BIT	h/const.hpp	/^inline constexpr mask_bits I_SET_GID_BIT = 0002000;   \/\/ set effective gid on exec$/;"	v
I_SET_UID_BIT	h/const.hpp	/^inline constexpr mask_bits I_SET_UID_BIT = 0004000;   \/\/ set effective uid on exec$/;"	v
I_TYPE	h/const.hpp	/^inline constexpr mask_bits I_TYPE = 0170000;          \/\/ inode type field$/;"	v
I_TYPE	tools/fsck.cpp	/^constexpr std::uint16_t I_TYPE = 0170000;$/;"	m	class:minix::fsck::ZoneLevel	file:
Idle	kernel/wormhole.hpp	/^enum class EndpointState { Idle, Send, Recv };$/;"	m	class:fastpath::EndpointState
ImageFile	tools/build.cpp	/^    explicit ImageFile(const std::string &path) {$/;"	f	class:minix::builder::ProgramType::ImageFile
ImageFile	tools/build.cpp	/^class ImageFile {$/;"	c	class:minix::builder::ProgramType	file:
ImapBlock	include/minix/fs/const.hpp	/^    ImapBlock = 3,$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
Indirect	fs/buf.hpp	/^    Indirect = 2 + WriteImmediate,$/;"	m	class:BlockType
IndirectBlock	include/minix/fs/const.hpp	/^    IndirectBlock = 2,$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
Inode	fs/buf.hpp	/^    Inode = 0 + WriteImmediate,$/;"	m	class:BlockType
Inode	include/minix/fs/inode.hpp	/^    [[nodiscard]] auto find_inode(dev_nr device, inode_nr number) -> Inode *;$/;"	m	class:minix::fs::InodeType::InodeTable
Inode	include/minix/fs/inode.hpp	/^    [[nodiscard]] auto release() -> Inode *;$/;"	m	class:minix::fs::InodeType::InodeHandle
Inode	include/minix/fs/inode.hpp	/^    explicit Inode(InodeType type, uid owner, gid group)$/;"	f	class:minix::fs::InodeType::Inode
Inode	include/minix/fs/inode.hpp	/^class Inode {$/;"	c	class:minix::fs::InodeType
Inode	tools/fsck.cpp	/^    explicit Inode(inode_nr number = 0) : number_(number) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
Inode	tools/fsck.cpp	/^class Inode {$/;"	c	class:minix::fsck::ZoneLevel	file:
InodeBlock	include/minix/fs/const.hpp	/^    InodeBlock = 0,$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
InodeError	include/minix/fs/inode.hpp	/^enum class InodeError {$/;"	c	namespace:minix::fs
InodeHandle	include/minix/fs/inode.hpp	/^    explicit InodeHandle(Inode *inode = nullptr, bool owned = true)$/;"	f	class:minix::fs::InodeType::InodeHandle
InodeHandle	include/minix/fs/inode.hpp	/^class InodeHandle {$/;"	c	class:minix::fs::InodeType
InodeTable	include/minix/fs/inode.hpp	/^class InodeTable {$/;"	c	class:minix::fs::InodeType
InodeType	include/minix/fs/inode.hpp	/^enum class InodeType : mask_bits {$/;"	c	namespace:minix::fs
InodeType	tools/fsck.cpp	/^enum class InodeType {$/;"	c	namespace:minix::fsck	file:
InvalidArgument	include/minix/fs/inode.hpp	/^    InvalidArgument,$/;"	m	class:minix::fs::InodeError
InvalidBlockNumber	include/minix/fs/buffer.hpp	/^    InvalidBlockNumber,$/;"	m	class:minix::fs::BufferError
InvalidDevice	include/minix/fs/buffer.hpp	/^    InvalidDevice,$/;"	m	class:minix::fs::BufferError
InvalidOperation	include/minix/fs/inode.hpp	/^    InvalidOperation,$/;"	m	class:minix::fs::InodeError
IoFlag	include/sh.hpp	/^enum IoFlag {$/;"	g
IoMode	include/minix/fs/const.hpp	/^    enum class IoMode : std::uint8_t { Normal = 0, NoRead = 1 };$/;"	c	struct:minix::fs::FsConstants
IoStatistics	tools/diskio.hpp	/^struct IoStatistics {$/;"	s	namespace:diskio
IoTask	include/sh.hpp	/^enum IoTask {$/;"	g
IpcFlags	kernel/lattice_ipc.hpp	/^enum class IpcFlags : unsigned {$/;"	c	namespace:lattice
KBIT	kernel/tty.cpp	811;"	d	file:
KB_BUSY	kernel/tty.cpp	825;"	d	file:
KB_STATUS	kernel/tty.cpp	823;"	d	file:
KEM_H	crypto/kyber_impl/kem.h	2;"	d
KERNEL	tools/build.cpp	/^    KERNEL = 0, \/\/\/< MINIX kernel - core OS functionality$/;"	m	class:minix::builder::ProgramType	file:
KERNEL_BASE	kernel/main.cpp	/^static constexpr phys_clicks_t KERNEL_BASE = Traits::BASE >> Traits::CLICK_SHIFT;$/;"	v	file:
KERNEL_DATA_MAGIC	tools/build.cpp	/^    static constexpr std::uint16_t KERNEL_DATA_MAGIC =$/;"	m	struct:minix::builder::BuildConstants	file:
KERNEL_ENTRY	tools/build.cpp	/^    static constexpr std::uint64_t KERNEL_ENTRY = 0x00100000ULL; \/\/\/< Kernel entry point address$/;"	m	struct:minix::builder::BuildConstants	file:
KERNEL_ENTRY_OFFSET	tools/bootblok1.cpp	/^    static constexpr std::size_t KERNEL_ENTRY_OFFSET = 0xf5; \/\/ Offset 245$/;"	m	class:minix::bootloader::BootSector	file:
KERNEL_LBA_OFFSET	tools/bootblok1.cpp	/^    static constexpr std::size_t KERNEL_LBA_OFFSET = 0xeb;   \/\/ Offset 235$/;"	m	class:minix::bootloader::BootSector	file:
KERNEL_VIRTUAL_BASE	vmm.h	39;"	d
KEYBD	kernel/tty.cpp	809;"	d	file:
KEYBOARD_VECTOR	kernel/const.hpp	/^inline constexpr int KEYBOARD_VECTOR = 33;$/;"	v
KILL	h/callnr.hpp	/^inline constexpr int KILL = 37;$/;"	v
KILL_CHAR	kernel/tty.cpp	71;"	d	file:
KMEM_DEV	h/com.hpp	/^inline constexpr int KMEM_DEV = 2; \/* minor device for \/dev\/kmem *\/$/;"	v
KR_PATTERN	tools/modernize_kr_file.py	/^KR_PATTERN = re.compile(r"^([A-Za-z_][A-Za-z0-9_]*\\s+)?([A-Za-z_][A-Za-z0-9_]*)\\(([^)])*\\)\\s*\\n([^{]+);", re.MULTILINE)$/;"	v
KSIG	h/callnr.hpp	/^inline constexpr int KSIG = 64;       \/* kernel detected a signal *\/$/;"	v
KYBER_CIPHERTEXTBYTES	crypto/kyber_impl/params.h	53;"	d
KYBER_ETA1	crypto/kyber_impl/params.h	30;"	d
KYBER_ETA1	crypto/kyber_impl/params.h	34;"	d
KYBER_ETA1	crypto/kyber_impl/params.h	38;"	d
KYBER_ETA2	crypto/kyber_impl/params.h	43;"	d
KYBER_INDCPA_BYTES	crypto/kyber_impl/params.h	48;"	d
KYBER_INDCPA_MSGBYTES	crypto/kyber_impl/params.h	45;"	d
KYBER_INDCPA_PUBLICKEYBYTES	crypto/kyber_impl/params.h	46;"	d
KYBER_INDCPA_SECRETKEYBYTES	crypto/kyber_impl/params.h	47;"	d
KYBER_K	crypto/kyber_impl/params.h	5;"	d
KYBER_N	crypto/kyber_impl/params.h	20;"	d
KYBER_NAMESPACE	crypto/kyber_impl/params.h	11;"	d
KYBER_NAMESPACE	crypto/kyber_impl/params.h	13;"	d
KYBER_NAMESPACE	crypto/kyber_impl/params.h	15;"	d
KYBER_POLYBYTES	crypto/kyber_impl/params.h	26;"	d
KYBER_POLYCOMPRESSEDBYTES	crypto/kyber_impl/params.h	31;"	d
KYBER_POLYCOMPRESSEDBYTES	crypto/kyber_impl/params.h	35;"	d
KYBER_POLYCOMPRESSEDBYTES	crypto/kyber_impl/params.h	39;"	d
KYBER_POLYVECBYTES	crypto/kyber_impl/params.h	27;"	d
KYBER_POLYVECCOMPRESSEDBYTES	crypto/kyber_impl/params.h	32;"	d
KYBER_POLYVECCOMPRESSEDBYTES	crypto/kyber_impl/params.h	36;"	d
KYBER_POLYVECCOMPRESSEDBYTES	crypto/kyber_impl/params.h	40;"	d
KYBER_PUBLICKEYBYTES	crypto/kyber_impl/params.h	50;"	d
KYBER_Q	crypto/kyber_impl/params.h	21;"	d
KYBER_SECRETKEYBYTES	crypto/kyber_impl/params.h	52;"	d
KYBER_SSBYTES	crypto/kyber_impl/params.h	24;"	d
KYBER_SYMBYTES	crypto/kyber_impl/params.h	23;"	d
K_STACK_BYTES	kernel/const.hpp	/^inline constexpr std::size_t K_STACK_BYTES = 256;    \/* how many bytes for the kernel stack *\/$/;"	v
KeccakF1600_StatePermute	crypto/kyber_impl/fips202.c	/^static void KeccakF1600_StatePermute(uint64_t state[25])$/;"	f	file:
KeccakF_RoundConstants	crypto/kyber_impl/fips202.c	/^static const uint64_t KeccakF_RoundConstants[NROUNDS] = {$/;"	v	file:
KeyPair	crypto/kyber.hpp	/^struct KeyPair {$/;"	s	namespace:pq::kyber
KeyPair	include/pqcrypto.hpp	/^struct KeyPair {$/;"	s	namespace:pqcrypto
KeyPair	kernel/pqcrypto.hpp	/^struct KeyPair {$/;"	s	namespace:pqcrypto
LABEL	commands/dosread.cpp	75;"	d	file:
LAST_CLUSTER	commands/dosread.cpp	55;"	d	file:
LAST_FEW	mm/forkexit.cpp	29;"	d	file:
LCASE	commands/dd.cpp	75;"	d	file:
LDFILES	commands/cc.cpp	/^struct arglist LDFILES;$/;"	v	typeref:struct:arglist
LDFLAGS	commands/Makefile	/^LDFLAGS ?=$/;"	m
LDFLAGS	test/Makefile	/^LDFLAGS ?=$/;"	m
LDFLAGS	test/minix/Makefile	/^LDFLAGS ?=$/;"	m
LDFLAGS	tools/minix/Makefile	/^LDFLAGS ?=$/;"	m
LD_HEAD	commands/cc.cpp	/^struct arglist LD_HEAD = {1,$/;"	v	typeref:struct:arglist
LD_TAIL	commands/cc.cpp	/^struct arglist LD_TAIL = {2, {"\/usr\/lib\/libc.a", "\/usr\/lib\/end.s"}};$/;"	v	typeref:struct:arglist
LEGAL	commands/ls.cpp	20;"	d	file:
LF	commands/mined2.cpp	/^void LF() {$/;"	f
LIB	commands/Makefile	/^LIB ?= ..\/lib\/lib.a$/;"	m
LIB	commands/mined2.cpp	/^LIB() {$/;"	f
LIB	test/Makefile	/^LIB ?= ..\/lib\/lib.a$/;"	m
LIB	test/minix/Makefile	/^LIB ?= ..\/lib\/lib.a$/;"	m
LIB	tools/minix/Makefile	/^LIB ?= ..\/lib\/lib.a$/;"	m
LIBDIR	commands/cc.cpp	/^char *LIBDIR = "\/usr\/lib";$/;"	v
LINELIM	include/sh.hpp	/^inline constexpr int LINELIM = 1000;$/;"	v
LINE_END	commands/mined.hpp	40;"	d
LINE_END	include/mined.hpp	40;"	d
LINE_LEN	commands/mined.hpp	42;"	d
LINE_LEN	commands/mkfs.cpp	59;"	d	file:
LINE_LEN	include/mined.hpp	42;"	d
LINE_LEN	tools/mkfs.cpp	53;"	d	file:
LINE_SIZE	commands/sort.cpp	46;"	d	file:
LINE_START	commands/mined.hpp	39;"	d
LINE_START	include/mined.hpp	39;"	d
LINE_WIDTH	kernel/tty.cpp	800;"	d	file:
LINK	h/callnr.hpp	/^inline constexpr int LINK = 9;$/;"	v
LINMAX	commands/comm.cpp	21;"	d	file:
LIST	commands/svcctl.hpp	/^    LIST = 1,          \/\/!< Request list of services$/;"	m	class:svcctl::Message
LIST_ONLY	tools/fsck.cpp	/^    LIST_ONLY,   \/\/\/< List filesystem contents$/;"	m	class:minix::fsck::FsckMode	file:
LIST_RESPONSE	commands/svcctl.hpp	/^    LIST_RESPONSE = 5, \/\/!< Single service entry in response$/;"	m	class:svcctl::Message
LOGAND	commands/sh2.cpp	24;"	d	file:
LOGOR	commands/sh2.cpp	25;"	d	file:
LONG_TYPE	commands/tar.cpp	54;"	d	file:
LOOK_UP	fs/const.hpp	/^inline constexpr int LOOK_UP = 0; \/* tells search_dir to lookup string *\/$/;"	v
LOW	commands/mined2.cpp	/^LOW() { move_to(0, last_y); }$/;"	f
LOWER	commands/sort.cpp	56;"	d	file:
LOW_BYTE	commands/mined2.cpp	1235;"	d	file:
LOW_FOUR	kernel/printer.cpp	46;"	d	file:
LOW_USER	h/const.hpp	/^inline constexpr int LOW_USER = 2;     \/\/ first user not part of OS$/;"	v
LR	commands/mined2.cpp	/^LR() { change("Line replace:", NOT_VALID); }$/;"	f
LSEEK	h/callnr.hpp	/^inline constexpr int LSEEK = 19;$/;"	v
LYEAR	commands/ar.cpp	475;"	d	file:
LYEAR	commands/ls.cpp	446;"	d	file:
Lflag	commands/dosread.cpp	/^BOOL Rflag, Lflag, Aflag, dos_read, dos_write, dos_dir;$/;"	v
Line	commands/mined.hpp	/^struct Line {$/;"	s	class:ReturnCode
Line	include/mined.hpp	/^struct Line {$/;"	s	class:ReturnCode
LivenessContract	kernel/service.hpp	/^    struct LivenessContract {$/;"	s	class:svc::ServiceManager
LookUp	include/minix/fs/const.hpp	/^    enum class DirOp : std::uint8_t { LookUp = 0, Enter = 1, Delete = 2 };$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp
M	lib/message.cpp	/^message M;$/;"	v
M1	h/type.hpp	/^inline constexpr int M1 = 1;         \/* style of message with three ints and three pointers *\/$/;"	v
M3	h/type.hpp	/^inline constexpr int M3 = 3;         \/* style of message with two ints and a string *\/$/;"	v
M3_STRING	h/type.hpp	/^inline constexpr int M3_STRING = 14; \/* length of M3's char array *\/$/;"	v
M4	h/type.hpp	/^inline constexpr int M4 = 4;         \/* style of message with four longs *\/$/;"	v
M64K	fs/main.cpp	31;"	d	file:
MA	commands/mined2.cpp	/^MA() {$/;"	f
MAGIC	commands/chmem.cpp	17;"	d	file:
MAGIC	commands/size.cpp	14;"	d	file:
MAGIC	lib/regexp.cpp	39;"	d	file:
MAGIC	lib/regsub.cpp	27;"	d	file:
MAGIC	mm/exec.cpp	30;"	d	file:
MAGIC0	tools/c86/dos2out.cpp	71;"	d	file:
MAGIC1	tools/c86/dos2out.cpp	72;"	d	file:
MAGIC_NUMBER	commands/ar.cpp	/^constexpr int MAGIC_NUMBER = 0177545;$/;"	v
MAJOR	h/const.hpp	/^inline constexpr int MAJOR = 8;         \/\/ major device shift$/;"	v
MANAGER_PID	commands/svcctl.hpp	/^inline constexpr xinim::pid_t MANAGER_PID = 1;  \/\/\/< PID for the service manager$/;"	m	class:svcctl::Message
MARKER	kernel/tty.cpp	77;"	d	file:
MASK	commands/dosread.cpp	56;"	d	file:
MASTER	kernel/floppy.cpp	57;"	d	file:
MATCH	commands/mined.hpp	111;"	d
MATCH	include/mined.hpp	104;"	d
MAX	commands/chmem.cpp	18;"	d	file:
MAX	commands/libpack.cpp	143;"	d	file:
MAXARGC	commands/cc.cpp	/^constexpr int MAXARGC = 64;   \/* maximum number of arguments allowed in a list *\/$/;"	v
MAXDEPTH	commands/roff.cpp	18;"	d	file:
MAXDIGITS	lib/printk.cpp	7;"	d	file:
MAXFD	commands/tee.cpp	8;"	d	file:
MAXLENGTH	commands/roff.cpp	19;"	d	file:
MAXLINE	commands/grep.cpp	31;"	d	file:
MAXLINE	commands/gres.cpp	30;"	d	file:
MAXMAC	commands/roff.cpp	17;"	d	file:
MAXPATHLEN	commands/ls.cpp	18;"	d	file:
MAXTRAILS	commands/mined2.cpp	924;"	d	file:
MAX_BUFFER_SIZE	tools/diskio.hpp	/^    static constexpr std::size_t MAX_BUFFER_SIZE = 1024 * 1024;   \/\/\/< Maximum buffer size (1MB)$/;"	m	struct:diskio::DiskConstants
MAX_CHARS	commands/mined.hpp	37;"	d
MAX_CHARS	include/mined.hpp	37;"	d
MAX_CLUSTER_SIZE	commands/dosread.cpp	28;"	d	file:
MAX_DIR_SIZE	tools/fsck.cpp	/^    static constexpr std::size_t MAX_DIR_SIZE = 5000;$/;"	m	struct:minix::fsck::FsckConstants	file:
MAX_ERRORS	kernel/at_wini.cpp	/^inline constexpr int MAX_ERRORS = 4;        \/* how often to try rd\/wt before quitting *\/$/;"	m	namespace:__anon18	file:
MAX_ERRORS	kernel/floppy.cpp	106;"	d	file:
MAX_ERRORS	kernel/wini.cpp	77;"	d	file:
MAX_ERRORS	kernel/xt_wini.cpp	74;"	d	file:
MAX_FAT_SIZE	commands/dosread.cpp	29;"	d	file:
MAX_FDC_RETRY	kernel/floppy.cpp	110;"	d	file:
MAX_ISTACK_BYTES	h/const.hpp	/^inline constexpr int MAX_ISTACK_BYTES = 1024; \/\/ maximum initial stack size for EXEC$/;"	v
MAX_LINKS	tools/fsck.cpp	/^    static constexpr std::uint16_t MAX_LINKS = std::numeric_limits<std::uint16_t>::max();$/;"	m	struct:minix::fsck::FsckConstants	file:
MAX_OVERRUN	kernel/tty.cpp	68;"	d	file:
MAX_PAGES	mm/const.hpp	/^inline constexpr std::size_t MAX_PAGES = 1048576;$/;"	v
MAX_PATH_LEN	h/const.hpp	/^inline constexpr int MAX_PATH_LEN = 128;      \/\/ max length of path names (Original name: MAX_PATH)$/;"	v
MAX_PRINT_ERRORS	tools/fsck.cpp	/^    static constexpr std::size_t MAX_PRINT_ERRORS = 8;$/;"	m	struct:minix::fsck::FsckConstants	file:
MAX_P_LONG	h/const.hpp	/^inline constexpr std::int32_t MAX_P_LONG = kMaxPLong; \/\/ alias for legacy code$/;"	v
MAX_RAM	fs/main.cpp	33;"	d	file:
MAX_REP	kernel/printer.cpp	50;"	d	file:
MAX_RESULTS	kernel/floppy.cpp	107;"	d	file:
MAX_RESULTS	kernel/wini.cpp	78;"	d	file:
MAX_RESULTS	kernel/xt_wini.cpp	75;"	d	file:
MAX_RETRIES	commands/mkfs.cpp	898;"	d	file:
MAX_RETRIES	tools/mkfs.cpp	893;"	d	file:
MAX_ROOT_ENTRIES	commands/dosread.cpp	30;"	d	file:
MAX_SECTOR_SIZE	tools/diskio.hpp	/^    static constexpr std::size_t MAX_SECTOR_SIZE = 4096;          \/\/\/< Maximum sector size$/;"	m	struct:diskio::DiskConstants
MAX_TOKENS	commands/mkfs.cpp	58;"	d	file:
MAX_TOKENS	tools/mkfs.cpp	52;"	d	file:
MAX_WIDTH	tools/fsck.cpp	/^    static constexpr std::size_t MAX_WIDTH = 32;$/;"	m	struct:minix::fsck::FsckConstants	file:
MAX_WIN_RETRY	kernel/at_wini.cpp	/^inline constexpr int MAX_WIN_RETRY = 10000; \/* max # times to try to output to WIN *\/$/;"	m	namespace:__anon18	file:
MAX_WIN_RETRY	kernel/wini.cpp	80;"	d	file:
MAX_WIN_RETRY	kernel/xt_wini.cpp	77;"	d	file:
MAX_ZONES	fs/const.hpp	/^inline constexpr std::size_t MAX_ZONES = NR_DZONE_NUM + NR_INDIRECTS + NR_INDIRECTS * NR_INDIRECTS;$/;"	v
MEM	h/com.hpp	/^inline constexpr int MEM = -4;     \/* \/dev\/ram, \/dev\/(k)mem and \/dev\/null class *\/$/;"	v
MEMBER	commands/ar.cpp	/^struct MEMBER {$/;"	s	file:
MEMORY_SIZE	commands/mined.hpp	52;"	d
MEMORY_SIZE	commands/sort.cpp	45;"	d	file:
MEMORY_SIZE	include/mined.hpp	52;"	d
MEM_BYTES	kernel/const.hpp	/^inline constexpr std::uint64_t MEM_BYTES = 0x100000000ULL; \/\/ Using std::uint64_t$/;"	v
MEM_DEV	h/com.hpp	/^inline constexpr int MEM_DEV = 1;  \/* minor device for \/dev\/mem *\/$/;"	v
MERGE	commands/sort.cpp	/^struct MERGE {$/;"	s	file:
META	lib/regexp.cpp	145;"	d	file:
MILLISEC	kernel/clock.cpp	50;"	d	file:
MIN	commands/dosread.cpp	631;"	d	file:
MINOR	h/const.hpp	/^inline constexpr int MINOR = 0;         \/\/ minor device mask$/;"	v
MINUTE	commands/ar.cpp	471;"	d	file:
MKDIR	commands/tar.cpp	56;"	d	file:
MKNOD	h/callnr.hpp	/^inline constexpr int MKNOD = 14;$/;"	v
MM	include/lib.hpp	/^inline constexpr int MM = 0; \/\/ memory manager index$/;"	v
MM	tools/build.cpp	/^    MM = 1,     \/\/\/< Memory Manager - handles process memory allocation$/;"	m	class:minix::builder::ProgramType	file:
MM_PROC_NR	h/const.hpp	/^inline constexpr int MM_PROC_NR = 0;   \/\/ memory manager process number$/;"	v
MM_STACK_BYTES	mm/const.hpp	/^inline constexpr std::size_t MM_STACK_BYTES = MAX_ISTACK_BYTES + MAX_PATH + 384;$/;"	v
MM_STACK_BYTES	mm/const.hpp	/^inline constexpr std::size_t MM_STACK_BYTES = MAX_ISTACK_BYTES + ZEROBUF_SIZE + 384;$/;"	v
MN	commands/mined2.cpp	/^MN() { move_next_word(NO_DELETE); }$/;"	f
MONOCHROME	kernel/tty.cpp	803;"	d	file:
MONO_BASE	kernel/tty.cpp	790;"	d	file:
MONT	crypto/kyber_impl/reduce.h	7;"	d
MONTH	commands/dosread.cpp	633;"	d	file:
MONTHS_PER_LINE	commands/cal.cpp	/^constexpr int MONTHS_PER_LINE = 3; \/* Three months across		*\/$/;"	v
MONTH_SPACE	commands/cal.cpp	/^constexpr int MONTH_SPACE = 3;     \/* Between each month		*\/$/;"	v
MOTOR_MASK	kernel/floppy.cpp	61;"	d	file:
MOTOR_OFF	kernel/floppy.cpp	94;"	d	file:
MOTOR_RUNNING	kernel/floppy.cpp	105;"	d	file:
MOUNT	h/callnr.hpp	/^inline constexpr int MOUNT = 21;$/;"	v
MP	commands/mined2.cpp	/^MP() { move_previous_word(NO_DELETE); }$/;"	f
MULTIBOOT_H	multiboot.h	2;"	d
MULTIBOOT_MEMORY_ACPI_RECLAIMABLE	multiboot.h	57;"	d
MULTIBOOT_MEMORY_AVAILABLE	multiboot.h	55;"	d
MULTIBOOT_MEMORY_BADRAM	multiboot.h	59;"	d
MULTIBOOT_MEMORY_NVS	multiboot.h	58;"	d
MULTIBOOT_MEMORY_RESERVED	multiboot.h	56;"	d
MULTIBOOT_TAG_TYPE_ACPI_NEW	multiboot.h	22;"	d
MULTIBOOT_TAG_TYPE_ACPI_OLD	multiboot.h	21;"	d
MULTIBOOT_TAG_TYPE_APM	multiboot.h	17;"	d
MULTIBOOT_TAG_TYPE_BASIC_MEMINFO	multiboot.h	11;"	d
MULTIBOOT_TAG_TYPE_BOOTDEV	multiboot.h	12;"	d
MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME	multiboot.h	9;"	d
MULTIBOOT_TAG_TYPE_CMDLINE	multiboot.h	8;"	d
MULTIBOOT_TAG_TYPE_EFI32	multiboot.h	18;"	d
MULTIBOOT_TAG_TYPE_EFI32_IH	multiboot.h	26;"	d
MULTIBOOT_TAG_TYPE_EFI64	multiboot.h	19;"	d
MULTIBOOT_TAG_TYPE_EFI64_IH	multiboot.h	27;"	d
MULTIBOOT_TAG_TYPE_EFI_BS	multiboot.h	25;"	d
MULTIBOOT_TAG_TYPE_EFI_MMAP	multiboot.h	24;"	d
MULTIBOOT_TAG_TYPE_ELF_SECTIONS	multiboot.h	16;"	d
MULTIBOOT_TAG_TYPE_END	multiboot.h	7;"	d
MULTIBOOT_TAG_TYPE_FRAMEBUFFER	multiboot.h	15;"	d
MULTIBOOT_TAG_TYPE_LOAD_BASE_ADDR	multiboot.h	28;"	d
MULTIBOOT_TAG_TYPE_MMAP	multiboot.h	13;"	d
MULTIBOOT_TAG_TYPE_MODULE	multiboot.h	10;"	d
MULTIBOOT_TAG_TYPE_NETWORK	multiboot.h	23;"	d
MULTIBOOT_TAG_TYPE_SMBIOS	multiboot.h	20;"	d
MULTIBOOT_TAG_TYPE_VBE	multiboot.h	14;"	d
M_6845	kernel/tty.cpp	814;"	d	file:
M_RETRACE	kernel/tty.cpp	794;"	d	file:
M_VID_MASK	kernel/tty.cpp	792;"	d	file:
Macread	commands/roff.cpp	/^FILE *File, *Macread, *Macwrite;$/;"	v
Macwrite	commands/roff.cpp	/^FILE *File, *Macread, *Macwrite;$/;"	v
Math	common/math/octonion.cpp	/^namespace Math {$/;"	n	namespace:Common	file:
Math	common/math/octonion.hpp	/^namespace Math {$/;"	n	namespace:Common
Math	common/math/quaternion.cpp	/^namespace Math {$/;"	n	namespace:Common	file:
Math	common/math/quaternion.hpp	/^namespace Math {$/;"	n	namespace:Common
Math	common/math/sedenion.cpp	/^namespace Math {$/;"	n	namespace:Common	file:
Math	common/math/sedenion.hpp	/^namespace Math {$/;"	n	namespace:Common
MemoryStream	include/minix/io/memory_stream.hpp	/^class MemoryStream : public Stream {$/;"	c	namespace:minix::io
Message	commands/svcctl.hpp	/^enum class Message : int {$/;"	c	namespace:svcctl
MessageReply	kernel/memory.cpp	/^class MessageReply {$/;"	c	file:
MinixFsErrorCategory	include/minix/fs_error.hpp	/^class MinixFsErrorCategory : public std::error_category {$/;"	c
MkListMem	commands/make.cpp	/^struct llist *MkListMem() {$/;"	f
MockServiceManager	tests/test_svcctl.cpp	/^class MockServiceManager {$/;"	c	file:
NAKED	include/defs.hpp	27;"	d
NAKED	kernel/syscall.cpp	/^void syscall_entry() noexcept NAKED; \/\/ (void) -> (), noexcept$/;"	v
NAME_SIZE	commands/tar.cpp	32;"	d	file:
NAME_SIZE	fs/const.hpp	/^inline constexpr std::size_t NAME_SIZE = 14;       \/* # bytes in a directory component *\/$/;"	v
NB	test/test0.cpp	21;"	d	file:
NCALLS	h/callnr.hpp	/^inline constexpr int NCALLS = 69; \/* number of system calls allowed *\/$/;"	v
NCPB	commands/sh5.cpp	393;"	d	file:
NDENT	commands/sh4.cpp	379;"	d	file:
NDIRBLOCKS	commands/ls.cpp	19;"	d	file:
NDRULES	commands/make.cpp	87;"	d	file:
NEGATE	commands/mined2.cpp	1231;"	d	file:
NEGATE_STROBE	kernel/printer.cpp	38;"	d	file:
NERROR	h/error.hpp	/^constexpr int NERROR = 34;$/;"	v
NEW	include/sh.hpp	349;"	d
NEWL	commands/tail.cpp	14;"	d	file:
NEXT	lib/malloc.cpp	9;"	d	file:
NEXT	lib/regexp.cpp	127;"	d	file:
NFILE	commands/ls.cpp	17;"	d	file:
NFILES	include/stdio.hpp	/^inline constexpr int NFILES = 20;$/;"	v
NILP	commands/libpack.cpp	17;"	d	file:
NIL_BUF	fs/buf.hpp	66;"	d
NIL_DIR	commands/dosread.cpp	53;"	d	file:
NIL_EXTENT	fs/extent.hpp	13;"	d
NIL_FILP	fs/file.hpp	/^inline constexpr struct filp *NIL_FILP = nullptr;$/;"	v	typeref:struct:filp
NIL_HEADER	commands/tar.cpp	58;"	d	file:
NIL_INODE	fs/inode.hpp	/^inline constexpr struct inode *NIL_INODE = nullptr;$/;"	v	typeref:struct:inode
NIL_INT	commands/mined.hpp	138;"	d
NIL_INT	include/mined.hpp	131;"	d
NIL_LINE	commands/mined.hpp	136;"	d
NIL_LINE	include/mined.hpp	129;"	d
NIL_LONG	commands/ar.cpp	/^constexpr long *NIL_LONG = nullptr;$/;"	v
NIL_MEM	commands/ar.cpp	/^constexpr MEMBER *NIL_MEM = nullptr;$/;"	v
NIL_MERGE	commands/sort.cpp	84;"	d	file:
NIL_PROC	kernel/proc.hpp	/^inline constexpr struct proc *NIL_PROC = nullptr;$/;"	v	typeref:struct:proc
NIL_PTR	commands/ar.cpp	/^constexpr char *NIL_PTR = nullptr;$/;"	v
NIL_PTR	commands/dosread.cpp	65;"	d	file:
NIL_PTR	commands/mined.hpp	135;"	d
NIL_PTR	commands/pr.cpp	36;"	d	file:
NIL_PTR	commands/sort.cpp	53;"	d	file:
NIL_PTR	commands/tar.cpp	59;"	d	file:
NIL_PTR	commands/tr.cpp	22;"	d	file:
NIL_PTR	include/mined.hpp	128;"	d
NIL_PTR	include/xinim/core_types.hpp	57;"	d
NIL_REG	commands/mined.hpp	137;"	d
NIL_REG	include/mined.hpp	130;"	d
NIL_SUPER	fs/super.hpp	43;"	d
NOERROR	commands/dd.cpp	77;"	d	file:
NOFILE	include/sh.hpp	/^inline constexpr int NOFILE = 20; \/* Number of open files *\/$/;"	v
NOMINMAX	tools/diskio.cpp	16;"	d	file:
NONBLOCK	kernel/lattice_ipc.hpp	/^    NONBLOCK = 1, \/\/!< Return immediately if no message can be sent or received$/;"	m	class:lattice::IpcFlags
NONCE_SIZE	crypto/kyber.cpp	/^constexpr std::size_t NONCE_SIZE = 12;$/;"	m	namespace:pq::kyber::__anon21	file:
NONCE_SIZE	kernel/lattice_ipc.cpp	/^constexpr std::size_t NONCE_SIZE = lattice::AEAD_NONCE_SIZE;$/;"	m	namespace:__anon15	file:
NONE	kernel/lattice_ipc.hpp	/^    NONE = 0,     \/\/!< Blocking semantics$/;"	m	class:lattice::IpcFlags
NORMAL	commands/mined2.cpp	1226;"	d	file:
NORMAL	fs/const.hpp	/^inline constexpr int NORMAL = 0;                    \/* forces get_block to do disk read *\/$/;"	v
NORMAL_STATUS	kernel/printer.cpp	35;"	d	file:
NOT	commands/sh1.cpp	668;"	d	file:
NOTHING	lib/regexp.cpp	87;"	d	file:
NOT_A_HDR_LEN	tools/c86/dos2out.cpp	105;"	d	file:
NOT_ESCAPED	kernel/tty.cpp	140;"	d	file:
NOT_REVIVING	fs/fproc.hpp	27;"	d
NOT_SUSPENDED	fs/fproc.hpp	25;"	d
NOT_USED	commands/dosread.cpp	48;"	d	file:
NOT_VALID	commands/mined.hpp	/^    NOT_VALID,$/;"	e	enum:ReturnCode::FLAG
NOT_VALID	include/mined.hpp	/^    NOT_VALID,$/;"	e	enum:ReturnCode::FLAG
NOT_WAITING	kernel/tty.cpp	148;"	d	file:
NO_BIT	fs/const.hpp	/^inline constexpr bit_nr NO_BIT =$/;"	v
NO_DELETE	commands/mined.hpp	/^    NO_DELETE,$/;"	e	enum:ReturnCode::FLAG
NO_DELETE	include/mined.hpp	/^    NO_DELETE,$/;"	e	enum:ReturnCode::FLAG
NO_DMA_INT	kernel/wini.cpp	62;"	d	file:
NO_DMA_INT	kernel/xt_wini.cpp	59;"	d	file:
NO_MAP	kernel/proc.hpp	/^inline constexpr unsigned int NO_MAP = 002;      \/* keeps unmapped forked child from running *\/$/;"	v
NO_MATCH	commands/mined.hpp	110;"	d
NO_MATCH	include/mined.hpp	103;"	d
NO_MEM	mm/const.hpp	/^inline constexpr phys_clicks NO_MEM = 0; \/* returned by alloc_mem() when mem is up *\/$/;"	v
NO_MOUNT	fs/inode.hpp	42;"	d
NO_NUM	h/const.hpp	/^inline constexpr int NO_NUM = 0x8000;         \/\/ used as numerical argument to panic$/;"	v
NO_PAPER	kernel/printer.cpp	41;"	d	file:
NO_PIPE	fs/inode.hpp	40;"	d
NO_READ	fs/const.hpp	/^inline constexpr int NO_READ = 1;                   \/* prevents get_block from doing disk read *\/$/;"	v
NO_SEEK	fs/inode.hpp	44;"	d
NO_TARG	commands/make.cpp	139;"	d	file:
NPUSH	include/sh.hpp	/^inline constexpr int NPUSH = 8; \/* limit to input nesting *\/$/;"	v
NQ	kernel/const.hpp	/^inline constexpr int NQ = 3;       \/* # of scheduling queues *\/$/;"	v
NROUNDS	crypto/kyber_impl/fips202.c	10;"	d	file:
NR_BUFS	fs/const.hpp	/^inline constexpr int NR_BUFS = 20;     \/* # blocks in the buffer cache *\/$/;"	v
NR_CPUS	kernel/const.hpp	/^inline constexpr int NR_CPUS = 1; \/* number of CPUs (SMP placeholder) *\/$/;"	v
NR_DEVICES	kernel/at_wini.cpp	/^inline constexpr int NR_DEVICES = 10;       \/* maximum number of drives *\/$/;"	m	namespace:__anon18	file:
NR_DEVICES	kernel/wini.cpp	79;"	d	file:
NR_DEVICES	kernel/xt_wini.cpp	76;"	d	file:
NR_DINDIRECTS	tools/fsck.cpp	/^constexpr std::size_t NR_DINDIRECTS = 1;$/;"	m	class:minix::fsck::ZoneLevel	file:
NR_DIRECT_ZONES	tools/fsck.cpp	/^constexpr std::size_t NR_DIRECT_ZONES = 7;$/;"	m	class:minix::fsck::ZoneLevel	file:
NR_DIR_ENTRIES	fs/const.hpp	/^inline constexpr std::size_t NR_DIR_ENTRIES = BLOCK_SIZE \/ DIR_ENTRY_SIZE; \/* # dir entries\/blk*\/$/;"	v
NR_DRIVES	kernel/floppy.cpp	108;"	d	file:
NR_DZONE_NUM	fs/const.hpp	/^inline constexpr int NR_DZONE_NUM = NR_ZONE_NUMS - 2;                      \/* # zones in inode *\/$/;"	v
NR_FDS	fs/const.hpp	/^inline constexpr int NR_FDS = 20;                  \/* max file descriptors per process *\/$/;"	v
NR_FILPS	fs/const.hpp	/^inline constexpr int NR_FILPS = 64;                \/* # slots in filp table *\/$/;"	v
NR_HEADS	kernel/floppy.cpp	89;"	d	file:
NR_HOLES	mm/alloc.cpp	/^constexpr int NR_HOLES = 128;$/;"	v
NR_INDIRECTS	fs/const.hpp	/^inline constexpr std::size_t NR_INDIRECTS = BLOCK_SIZE \/ ZONE_NUM_SIZE;    \/* # zones\/indir blk *\/$/;"	v
NR_INDIRECTS	tools/fsck.cpp	/^constexpr std::size_t NR_INDIRECTS = 1;$/;"	m	class:minix::fsck::ZoneLevel	file:
NR_INODES	fs/const.hpp	/^inline constexpr int NR_INODES = 32;               \/* # slots in "in core" inode table *\/$/;"	v
NR_PROCS	h/const.hpp	/^inline constexpr int NR_PROCS = 16; \/\/ number of slots in proc table$/;"	v
NR_RAMS	kernel/memory.cpp	/^constexpr std::size_t NR_RAMS = 4;$/;"	v
NR_REGS	kernel/const.hpp	/^inline constexpr int NR_REGS = 15;$/;"	v
NR_SCHED_QUEUES	kernel/const.hpp	/^inline constexpr int NR_SCHED_QUEUES = 16; \/* number of priority queues *\/$/;"	v
NR_SECTORS	kernel/wini.cpp	71;"	d	file:
NR_SECTORS	kernel/xt_wini.cpp	68;"	d	file:
NR_SEGS	h/const.hpp	/^inline constexpr int NR_SEGS = 3;   \/\/ segments per process$/;"	v
NR_SIGS	include/shared/signal_constants.hpp	/^inline constexpr int NR_SIGS = 16; \/* number of signals used *\/$/;"	v
NR_SUPERS	fs/const.hpp	/^inline constexpr int NR_SUPERS = 5;                \/* # slots in super block table *\/$/;"	v
NR_TASKS	h/const.hpp	/^inline constexpr int NR_TASKS = 8;  \/\/ number of tasks in transfer vector$/;"	v
NR_TTYS	kernel/tty.cpp	62;"	d	file:
NR_ZONE_NUMS	fs/const.hpp	/^inline constexpr int NR_ZONE_NUMS = 9; \/* # zone numbers in an inode *\/$/;"	v
NSIG	include/shared/signal_constants.hpp	/^inline constexpr int NSIG = 16;    \/* number of signals used *\/$/;"	v
NSIGNAL	commands/sh3.cpp	37;"	d	file:
NSIZE	kernel/dmp.cpp	20;"	d	file:
NSTART	commands/sh4.cpp	536;"	d	file:
NSUBEXP	include/regexp.hpp	/^inline constexpr int NSUBEXP = 10;$/;"	v
NT	kernel/floppy.cpp	111;"	d	file:
NTT_H	crypto/kyber_impl/ntt.h	2;"	d
NUFILE	include/sh.hpp	/^inline constexpr int NUFILE = 10; \/* Number of user-accessible files *\/$/;"	v
NUL	commands/make.cpp	131;"	d	file:
NULL	commands/mined.hpp	15;"	d
NULL	commands/rev.cpp	17;"	d	file:
NULL	commands/sh1.cpp	664;"	d	file:
NULL	commands/sh1.cpp	740;"	d	file:
NULL	include/mined.hpp	15;"	d
NULL	include/sh.hpp	12;"	d
NULL_DEV	h/com.hpp	/^inline constexpr int NULL_DEV = 3; \/* minor device for \/dev\/null *\/$/;"	v
N_BLOCKS	commands/mkfs.cpp	63;"	d	file:
N_BLOCKS	tools/mkfs.cpp	57;"	d	file:
NoFreeBuffers	include/minix/fs/buffer.hpp	/^    NoFreeBuffers,$/;"	m	class:minix::fs::BufferError
NoInput	commands/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	m	class:ReturnCode
NoInput	include/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	m	class:ReturnCode
NoLine	commands/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	m	class:ReturnCode
NoLine	include/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	m	class:ReturnCode
NoRead	include/minix/fs/const.hpp	/^    enum class IoMode : std::uint8_t { Normal = 0, NoRead = 1 };$/;"	m	class:minix::fs::FsConstants::IoMode
Normal	include/minix/fs/const.hpp	/^    enum class IoMode : std::uint8_t { Normal = 0, NoRead = 1 };$/;"	m	class:minix::fs::FsConstants::IoMode
NotFound	include/minix/fs/inode.hpp	/^    NotFound,$/;"	m	class:minix::fs::InodeError
OBJECTS	common/math/Makefile	/^OBJECTS := $(SOURCES:.cpp=.o)$/;"	m
OBJECTS	tools/Makefile	/^OBJECTS := $(SOURCES:$(SRCDIR)\/%.cpp=$(BUILDDIR)\/%.o)$/;"	m
OBJS	lib/Makefile	/^OBJS := $(patsubst %.cpp,%.o,$(wildcard *.cpp))$/;"	m
OBUFSIZE	commands/libupack.cpp	132;"	d	file:
OFF	commands/mined.hpp	/^    OFF,$/;"	e	enum:ReturnCode::FLAG
OFF	include/mined.hpp	/^    OFF,$/;"	e	enum:ReturnCode::FLAG
OFF_LINE	kernel/printer.cpp	42;"	d	file:
OFF_MASK	kernel/tty.cpp	796;"	d	file:
OK	commands/sort.cpp	51;"	d	file:
OK	h/error.hpp	/^constexpr int OK = 0; \/\/ Consistent with xinim::OK$/;"	v
OK	include/errno.hpp	/^constexpr int OK = 0;    \/\/ successful return status$/;"	v
OLIVETTI_EQUAL	kernel/tty.cpp	828;"	d	file:
ON	commands/mined.hpp	/^    ON,$/;"	e	enum:ReturnCode::FLAG
ON	include/mined.hpp	/^    ON,$/;"	e	enum:ReturnCode::FLAG
ONE	commands/cmp.cpp	63;"	d	file:
ONE_INT	kernel/tty.cpp	146;"	d	file:
OP	lib/regexp.cpp	126;"	d	file:
OPEN	h/callnr.hpp	/^inline constexpr int OPEN = 5;$/;"	v
OPEN	lib/regexp.cpp	90;"	d	file:
OPEN_FILES	commands/sort.cpp	43;"	d	file:
OPERAND	lib/regexp.cpp	128;"	d	file:
OPT	commands/cc.cpp	/^char *OPT = "\/usr\/lib\/opt";$/;"	v
OPT_FLAGS	commands/cc.cpp	/^struct arglist OPT_FLAGS;$/;"	v	typeref:struct:arglist
OUT	lib/prints.cpp	15;"	d	file:
Octonion	common/math/octonion.cpp	/^Octonion::Octonion(const Quaternion& q1, const Quaternion& q2) {$/;"	f	class:Common::Math::Octonion
Octonion	kernel/octonion.hpp	/^    explicit constexpr Octonion(const std::array<std::uint32_t, 8> &c) : comp(c) {}$/;"	f	struct:lattice::Octonion
Octonion	kernel/octonion.hpp	/^struct Octonion {$/;"	s	namespace:lattice
OctonionToken	kernel/octonion_math.hpp	/^struct OctonionToken {$/;"	s	namespace:lattice
OneShot	fs/buf.hpp	/^    OneShot = 0200,$/;"	m	class:BlockType
OpType	include/sh.hpp	/^enum OpType {$/;"	g
OpenMode	include/minix/io/file_operations.hpp	/^enum class OpenMode : unsigned {$/;"	c	namespace:minix::io
OutOfSpace	include/minix/fs/inode.hpp	/^    OutOfSpace,$/;"	m	class:minix::fs::InodeError
P1	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	m	class:fastpath::Precondition
P2	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	m	class:fastpath::Precondition
P3	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	m	class:fastpath::Precondition
P4	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	m	class:fastpath::Precondition
P5	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	m	class:fastpath::Precondition
P6	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	m	class:fastpath::Precondition
P7	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	m	class:fastpath::Precondition
P8	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	m	class:fastpath::Precondition
P9	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	m	class:fastpath::Precondition
PACKED	include/defs.hpp	26;"	d
PACKED	kernel/idt64.cpp	/^} PACKED;$/;"	v	typeref:struct:idt_entry
PACKED	kernel/idt64.cpp	/^} PACKED;$/;"	v	typeref:struct:idt_ptr
PACKED	kernel/idt64.cpp	/^} PACKED;$/;"	v	typeref:struct:tss64
PAGE_DIR_ENTRIES	vmm.h	30;"	d
PAGE_SIZE	mm/const.hpp	/^inline constexpr std::size_t PAGE_SIZE = 4096;$/;"	v
PAGE_SIZE	pmm.h	8;"	d
PAGE_SIZE_4K	include/paging.hpp	/^inline constexpr std::size_t PAGE_SIZE_4K = 4096;$/;"	v
PAGE_SIZE_4KB	vmm.h	32;"	d
PAGE_SIZE_4MB	vmm.h	33;"	d
PAGE_TABLE_ENTRIES	vmm.h	29;"	d
PAGING_H	include/paging.hpp	8;"	d
PARAMS_H	crypto/kyber_impl/params.h	2;"	d
PARENT_NODE	tests/test_lattice_ipv6.cpp	/^static constexpr net::node_t PARENT_NODE = 0;$/;"	v	file:
PARENT_NODE	tests/test_lattice_network.cpp	/^static constexpr net::node_t PARENT_NODE = 0;$/;"	v	file:
PARENT_NODE	tests/test_lattice_network_encrypted.cpp	/^static constexpr net::node_t PARENT_NODE = 0;$/;"	v	file:
PARENT_NODE	tests/test_net_driver.cpp	/^static constexpr net::node_t PARENT_NODE = 0;$/;"	v	file:
PARENT_NODE	tests/test_net_driver_drop_newest.cpp	/^constexpr net::node_t PARENT_NODE = 0;$/;"	m	namespace:__anon13	file:
PARENT_NODE	tests/test_net_driver_ipv6.cpp	/^constexpr net::node_t PARENT_NODE = 0;$/;"	m	namespace:__anon11	file:
PARENT_NODE	tests/test_net_driver_overflow.cpp	/^constexpr net::node_t PARENT_NODE = 0;$/;"	m	namespace:__anon6	file:
PARENT_NODE	tests/test_net_driver_reconnect.cpp	/^constexpr net::node_t PARENT_NODE = 0;$/;"	m	namespace:__anon12	file:
PARENT_NODE	tests/test_net_driver_tcp.cpp	/^constexpr net::node_t PARENT_NODE = 0;$/;"	m	namespace:__anon9	file:
PARENT_NODE	tests/test_net_two_node.cpp	/^static constexpr net::node_t PARENT_NODE = 0;$/;"	v	file:
PARENT_NODE	tests/test_poll_network.cpp	/^static constexpr net::node_t PARENT_NODE = 0;$/;"	v	file:
PARENT_PORT	tests/test_lattice_ipv6.cpp	/^static constexpr std::uint16_t PARENT_PORT = 12600;$/;"	v	file:
PARENT_PORT	tests/test_lattice_network.cpp	/^static constexpr uint16_t PARENT_PORT = 12000;$/;"	v	file:
PARENT_PORT	tests/test_lattice_network_encrypted.cpp	/^static constexpr std::uint16_t PARENT_PORT = 12500;$/;"	v	file:
PARENT_PORT	tests/test_net_driver.cpp	/^static constexpr uint16_t PARENT_PORT = 14000;$/;"	v	file:
PARENT_PORT	tests/test_net_driver_drop_newest.cpp	/^constexpr std::uint16_t PARENT_PORT = 14200;$/;"	m	namespace:__anon13	file:
PARENT_PORT	tests/test_net_driver_overflow.cpp	/^constexpr std::uint16_t PARENT_PORT = 14100;$/;"	m	namespace:__anon6	file:
PARENT_PORT	tests/test_net_driver_reconnect.cpp	/^constexpr uint16_t PARENT_PORT = 15500;$/;"	m	namespace:__anon12	file:
PARENT_PORT	tests/test_net_driver_tcp.cpp	/^constexpr uint16_t PARENT_PORT = 15000;$/;"	m	namespace:__anon9	file:
PARENT_PORT	tests/test_net_two_node.cpp	/^static constexpr std::uint16_t PARENT_PORT = 13000;$/;"	v	file:
PARENT_PORT	tests/test_poll_network.cpp	/^static constexpr std::uint16_t PARENT_PORT = 15000;$/;"	v	file:
PART_TABLE	kernel/at_wini.cpp	/^inline constexpr int PART_TABLE = 0x1C6;    \/* IBM partition table starts here in sect 0 *\/$/;"	m	namespace:__anon18	file:
PART_TABLE	kernel/wini.cpp	81;"	d	file:
PART_TABLE	kernel/xt_wini.cpp	78;"	d	file:
PATHCHAR	commands/make.cpp	18;"	d	file:
PATHCHAR	commands/make.cpp	26;"	d	file:
PAUSE	h/callnr.hpp	/^inline constexpr int PAUSE = 29;$/;"	v
PAUSED	mm/mproc.hpp	/^inline constexpr unsigned int PAUSED = 010;   \/**< Set by the PAUSE system call. *\/$/;"	v
PC_OFF	kernel/mpx64.cpp	27;"	d	file:
PD	commands/mined2.cpp	/^PD() {$/;"	f
PDE_PAGE_SIZE	vmm.h	18;"	d
PERPRINTF	include/stdio.hpp	/^constexpr int PERPRINTF = 64;$/;"	v
PH_SECTSIZE	commands/mkfs.cpp	751;"	d	file:
PH_SECTSIZE	tools/c86/dos2out.cpp	104;"	d	file:
PH_SECTSIZE	tools/mkfs.cpp	746;"	d	file:
PIDSLOTS	tools/init.cpp	9;"	d	file:
PIPE	h/callnr.hpp	/^inline constexpr int PIPE = 42;$/;"	v
PIPE_SIZE	fs/const.hpp	/^inline constexpr std::size_t PIPE_SIZE =$/;"	v
PLUS	lib/regexp.cpp	89;"	d	file:
PMM_H	pmm.h	2;"	d
PMM_INVALID_PAGE	pmm.h	9;"	d
PMODE	lib/fopen.cpp	5;"	d	file:
POINTER_SIZE	commands/mined1.cpp	1137;"	d	file:
POLYVEC_H	crypto/kyber_impl/polyvec.h	2;"	d
POLY_H	crypto/kyber_impl/poly.h	2;"	d
PORT_B	kernel/tty.cpp	810;"	d	file:
PP	commands/cc.cpp	/^char *PP = "\/lib\/cpp";$/;"	v
PP	commands/cc.cpp	/^char *PP = "\/usr\/lib\/cpp";$/;"	v
PP_FLAGS	commands/cc.cpp	/^struct arglist PP_FLAGS;$/;"	v	typeref:struct:arglist
PRINTER	h/com.hpp	/^inline constexpr int PRINTER = -8;     \/* printer I\/O class *\/$/;"	v
PRINTER_VECTOR	kernel/const.hpp	/^inline constexpr int PRINTER_VECTOR = 36;$/;"	v
PRIVATE	h/const.hpp	20;"	d
PRI_SERVER	kernel/const.hpp	/^inline constexpr int PRI_SERVER = 2;       \/* servers such as MM\/FS *\/$/;"	v
PRI_TASK	kernel/const.hpp	/^inline constexpr int PRI_TASK = 0;         \/* task priority *\/$/;"	v
PRI_USER	kernel/const.hpp	/^inline constexpr int PRI_USER = 8;         \/* default user process priority *\/$/;"	v
PROGRAM_COUNT	tools/build.cpp	/^    static constexpr std::size_t PROGRAM_COUNT =$/;"	m	struct:minix::builder::BuildConstants	file:
PROGRAM_ORIGIN	tools/build.cpp	/^    static constexpr std::size_t PROGRAM_ORIGIN = 1536; \/\/\/< Base address where kernel loads (0x600)$/;"	m	struct:minix::builder::BuildConstants	file:
PR_COLOR_BASE	kernel/printer.cpp	44;"	d	file:
PR_ERROR	kernel/printer.cpp	43;"	d	file:
PR_MONO_BASE	kernel/printer.cpp	45;"	d	file:
PSW_OFF	kernel/mpx64.cpp	28;"	d	file:
PT	commands/mined2.cpp	/^PT() {$/;"	f
PTE_ACCESSED	vmm.h	13;"	d
PTE_CACHE_DISABLE	vmm.h	12;"	d
PTE_DIRTY	vmm.h	14;"	d
PTE_GLOBAL	vmm.h	16;"	d
PTE_PAT	vmm.h	15;"	d
PTE_PRESENT	vmm.h	8;"	d
PTE_READ_WRITE	vmm.h	9;"	d
PTE_USER	vmm.h	10;"	d
PTE_WRITE_THROUGH	vmm.h	11;"	d
PT_ENTRIES	include/paging.hpp	/^inline constexpr std::size_t PT_ENTRIES = 512;$/;"	v
PU	commands/mined2.cpp	/^PU() {$/;"	f
PUBLIC	h/const.hpp	23;"	d
PUBLIC	lib/c86/prologue.hpp	/^    @CODE SEGMENT BYTE PUBLIC 'CODE';$/;"	v
PUBLIC	lib/c86/prologue.hpp	/^bss segment @DATAT ENDS @DATAU SEGMENT BYTE PUBLIC 'DATAU';$/;"	v
PUBLIC	lib/c86/prologue.hpp	/^bss segment @DATAU ENDS @DATAV SEGMENT BYTE PUBLIC 'DATAV';$/;"	v
PUBLIC	lib/c86/prologue.hpp	/^data segment @DATAB ENDS @DATAC SEGMENT BYTE PUBLIC 'DATAC';$/;"	v
PUBLIC	lib/c86/prologue.hpp	/^data segment @DATAC ENDS @DATAI SEGMENT BYTE PUBLIC 'DATAI';$/;"	v
PUBLIC	lib/c86/prologue.hpp	/^data segment @DATAI ENDS @DATAT SEGMENT BYTE PUBLIC 'DATAT';$/;"	v
PUBLIC	lib/c86/prologue.hpp	/^text segment @CODE ENDS @DATAB SEGMENT PARA PUBLIC 'DATAB';$/;"	v
PUSHIO	include/sh.hpp	317;"	d
P_SLOT_FREE	kernel/proc.hpp	/^inline constexpr unsigned int P_SLOT_FREE = 001; \/* set when slot is not in use *\/$/;"	v
PartialData	fs/buf.hpp	/^    PartialData = 7$/;"	m	class:BlockType
PartialDataBlock	include/minix/fs/const.hpp	/^    PartialDataBlock = 7$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
PathNode	tools/fsck.cpp	/^        PathNode(std::string n, inode_nr ino, std::shared_ptr<PathNode> p = nullptr)$/;"	f	struct:minix::fsck::ZoneLevel::PathTracker::PathNode
PathNode	tools/fsck.cpp	/^    struct PathNode {$/;"	s	class:minix::fsck::ZoneLevel::PathTracker	file:
PathTracker	tools/fsck.cpp	/^    PathTracker() : current_(std::make_shared<PathNode>("", ROOT_INODE)) {}$/;"	f	class:minix::fsck::ZoneLevel::PathTracker
PathTracker	tools/fsck.cpp	/^class PathTracker {$/;"	c	class:minix::fsck::ZoneLevel	file:
PerCpuQueue	kernel/wormhole.hpp	/^struct PerCpuQueue {$/;"	s	namespace:fastpath
PermissionDenied	include/minix/fs/inode.hpp	/^    PermissionDenied,$/;"	m	class:minix::fs::InodeError
Permissions	include/minix/fs/const.hpp	/^namespace Permissions {$/;"	n	class:minix::fs::FsConstants::IoMode::DirOp
Permissions	include/minix/fs/inode.hpp	/^    constexpr explicit Permissions(mask_bits bits = mask_bits{0}) : bits_{bits} {}$/;"	f	class:minix::fs::InodeType::Permissions
Permissions	include/minix/fs/inode.hpp	/^class Permissions {$/;"	c	class:minix::fs::InodeType
Permissions	include/minix/io/file_operations.hpp	/^struct Permissions {$/;"	s	class:minix::io::OpenMode
Pipe	include/minix/fs/inode.hpp	/^    Pipe = std::to_underlying(FileTypes::kPipe)$/;"	m	class:minix::fs::InodeType
PowerOfTwo	include/minix/fs/const.hpp	/^concept PowerOfTwo = requires(T value) {$/;"	m	namespace:minix::fs
Precondition	kernel/wormhole.hpp	/^enum class Precondition : size_t { P1, P2, P3, P4, P5, P6, P7, P8, P9, Count };$/;"	c	namespace:fastpath
ProgCall	commands/cc.cpp	/^char *ProgCall = 0;$/;"	v
ProgramInfo	tools/build.cpp	/^struct ProgramInfo {$/;"	s	class:minix::builder::ProgramType	file:
ProgramType	tools/build.cpp	/^enum class ProgramType : std::size_t {$/;"	c	namespace:minix::builder	file:
QINV	crypto/kyber_impl/reduce.h	8;"	d
QMASK	commands/sh1.cpp	667;"	d	file:
QUITC	commands/stty.cpp	19;"	d	file:
QUIT_CHAR	kernel/tty.cpp	73;"	d	file:
QUOTE	commands/sh1.cpp	666;"	d	file:
QUOTE	include/sh.hpp	/^inline constexpr char QUOTE = 0200;$/;"	v
Quaternion	kernel/quaternion_spinlock.hpp	/^struct Quaternion {$/;"	s	namespace:hyper
QuaternionLockGuard	kernel/quaternion_spinlock.hpp	/^class QuaternionLockGuard {$/;"	c	namespace:hyper
QuaternionSpinlock	kernel/quaternion_spinlock.hpp	/^class QuaternionSpinlock {$/;"	c	namespace:hyper
R10_OFF	kernel/mpx64.cpp	20;"	d	file:
R11_OFF	kernel/mpx64.cpp	21;"	d	file:
R12_OFF	kernel/mpx64.cpp	22;"	d	file:
R13_OFF	kernel/mpx64.cpp	23;"	d	file:
R14_OFF	kernel/mpx64.cpp	24;"	d	file:
R15_OFF	kernel/mpx64.cpp	25;"	d	file:
R8_OFF	kernel/mpx64.cpp	18;"	d	file:
R9_OFF	kernel/mpx64.cpp	19;"	d	file:
RAM_DEV	h/com.hpp	/^inline constexpr int RAM_DEV = 0;  \/* minor device for \/dev\/ram *\/$/;"	v
RANDOMBYTES_H	crypto/kyber_impl/randombytes.h	2;"	d
RAW	include/sgtty.hpp	/^    RAW = 0000040,    \/**< enable raw mode *\/$/;"	m	class:SgFlags
RAX_OFF	kernel/mpx64.cpp	11;"	d	file:
RBP_OFF	kernel/mpx64.cpp	17;"	d	file:
RBX_OFF	kernel/mpx64.cpp	12;"	d	file:
RCX_OFF	kernel/mpx64.cpp	13;"	d	file:
RD	commands/mined1.cpp	/^RD() {$/;"	f
RDI_OFF	kernel/mpx64.cpp	16;"	d	file:
RDX_OFF	kernel/mpx64.cpp	14;"	d	file:
READ	commands/ar.cpp	/^constexpr int READ = 0;$/;"	v
READ	commands/dosread.cpp	69;"	d	file:
READ	commands/mined.hpp	/^    READ,$/;"	e	enum:ReturnCode::FLAG
READ	h/callnr.hpp	/^inline constexpr int READ = 3;$/;"	v
READ	include/mined.hpp	/^    READ,$/;"	e	enum:ReturnCode::FLAG
READING	h/const.hpp	/^inline constexpr int READING = 0;      \/\/ copy data to user$/;"	v
READMODE	include/stdio.hpp	/^constexpr int READMODE = 1;$/;"	v
REAL_TIME	h/com.hpp	/^inline constexpr int REAL_TIME = 1;  \/* reply from CLOCK: here is real time *\/$/;"	v
RECEIVE	h/com.hpp	/^inline constexpr int RECEIVE = 2;          \/* function code for receiving messages *\/$/;"	v
RECEIVING	kernel/proc.hpp	/^inline constexpr unsigned int RECEIVING = 010;   \/* set when process blocked trying to recv *\/$/;"	v
REDUCE_H	crypto/kyber_impl/reduce.h	2;"	d
REGULAR_FILE	tools/fsck.cpp	/^    REGULAR_FILE,$/;"	m	class:minix::fsck::InodeType	file:
REG_ERROR	commands/mined.hpp	112;"	d
REG_ERROR	include/mined.hpp	105;"	d
RELEASE_FLAGS	tools/Makefile	/^RELEASE_FLAGS := -DNDEBUG -flto$/;"	m
REPORT	commands/mined.hpp	54;"	d
REPORT	include/mined.hpp	54;"	d
REPT_ERR	commands/make.cpp	140;"	d	file:
RESTART	commands/svcctl.hpp	/^    RESTART = 4,       \/\/!< Restart a service$/;"	m	class:svcctl::Message
RET_CODE	commands/cc.cpp	/^int RET_CODE = 0;$/;"	v
RET_REG	kernel/const.hpp	/^inline constexpr int RET_REG = 0; \/* system call return codes go in this reg *\/$/;"	v
REVERSE	commands/mined.hpp	/^    REVERSE,$/;"	e	enum:ReturnCode::FLAG
REVERSE	include/mined.hpp	/^    REVERSE,$/;"	e	enum:ReturnCode::FLAG
REVIVE	h/callnr.hpp	/^inline constexpr int REVIVE = 67;     \/* to FS: revive a sleeping process *\/$/;"	v
REVIVING	fs/fproc.hpp	28;"	d
ROL	crypto/kyber_impl/fips202.c	11;"	d	file:
RONLY	include/sh.hpp	/^    RONLY = 01,  \/* variable is read-only *\/$/;"	e	enum:VarFlag
ROOT_DEV	h/const.hpp	/^inline constexpr dev_nr ROOT_DEV = static_cast<dev_nr>(256);$/;"	v
ROOT_DIR	tools/find_knr.py	/^ROOT_DIR = SCRIPT_DIR.parent$/;"	v
ROOT_INODE	fs/const.hpp	/^inline constexpr inode_nr ROOT_INODE =$/;"	v
ROOT_INODE	tools/fsck.cpp	/^constexpr inode_nr ROOT_INODE = 1;$/;"	v
RSI_OFF	kernel/mpx64.cpp	15;"	d	file:
RT	commands/mined2.cpp	/^void RT() {$/;"	f
RUN	include/sh.hpp	318;"	d
RUNNING	kernel/tty.cpp	142;"	d	file:
RWX_MODES	h/const.hpp	/^inline constexpr mask_bits RWX_MODES = 0000777;       \/\/ RWX permission bits$/;"	v
R_BIT	h/const.hpp	/^inline constexpr mask_bits R_BIT = 0000004;           \/\/ read protection bit$/;"	v
Regular	include/minix/fs/inode.hpp	/^    Regular = std::to_underlying(FileTypes::kRegular),$/;"	m	class:minix::fs::InodeType
Remote	kernel/net_driver.cpp	/^struct Remote {$/;"	s	namespace:net::__anon16	file:
RestartPolicy	kernel/service.hpp	/^    struct RestartPolicy {$/;"	s	class:svc::ServiceManager
ReturnCode	commands/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	c
ReturnCode	include/mined.hpp	/^enum class ReturnCode { Errors = -1, NoLine = -2, Fine = 0, NoInput = 1 };$/;"	c
Rflag	commands/dosread.cpp	/^BOOL Rflag, Lflag, Aflag, dos_read, dos_write, dos_dir;$/;"	v
Running	kernel/wormhole.hpp	/^enum class ThreadStatus { Running, Blocked, SendBlocked, RecvBlocked };$/;"	m	class:fastpath::ThreadStatus
S	h/const.hpp	/^inline constexpr int S = 2;         \/\/ stack segment index$/;"	v
SAME	commands/mined.hpp	/^    SAME,$/;"	e	enum:ReturnCode::FLAG
SAME	commands/sort.cpp	57;"	d	file:
SAME	include/mined.hpp	/^    SAME,$/;"	e	enum:ReturnCode::FLAG
SCHED_QUEUES	kernel/const.hpp	/^inline constexpr int SCHED_QUEUES = NQ;$/;"	v
SCHED_QUEUES	kernel/const.hpp	/^inline constexpr int SCHED_QUEUES = NR_SCHED_QUEUES;$/;"	v
SCHED_RATE	kernel/clock.cpp	51;"	d	file:
SCHED_ROUND_ROBIN	kernel/const.hpp	43;"	d
SCREENMAX	commands/mined.hpp	33;"	d
SCREENMAX	include/mined.hpp	33;"	d
SCREEN_SIZE	commands/mined.hpp	43;"	d
SCREEN_SIZE	include/mined.hpp	43;"	d
SCRIPT_DIR	tools/find_knr.py	/^SCRIPT_DIR = Path(__file__).resolve().parent$/;"	v
SCR_LINES	kernel/tty.cpp	801;"	d	file:
SD	commands/mined2.cpp	/^SD() {$/;"	f
SE	commands/mined1.cpp	/^char *CE, *VS, *SO, *SE, *CL, *AL, *CM;$/;"	v
SECTOR_SIZE	kernel/at_wini.cpp	/^inline constexpr int SECTOR_SIZE = 512; \/* physical sector size in bytes *\/$/;"	m	namespace:__anon18	file:
SECTOR_SIZE	kernel/floppy.cpp	87;"	d	file:
SECTOR_SIZE	kernel/wini.cpp	70;"	d	file:
SECTOR_SIZE	kernel/xt_wini.cpp	67;"	d	file:
SECTOR_SIZE	tools/bootblok1.cpp	/^    static constexpr std::size_t SECTOR_SIZE = 512;$/;"	m	class:minix::bootloader::BootSector	file:
SECTOR_SIZE	tools/build.cpp	/^    static constexpr std::size_t SECTOR_SIZE = 512; \/\/\/< Standard disk sector size in bytes$/;"	m	struct:minix::builder::BuildConstants	file:
SECTOR_SIZE	tools/diskio.hpp	/^    static constexpr std::size_t SECTOR_SIZE = 512;               \/\/\/< Standard sector size$/;"	m	struct:diskio::DiskConstants
SEC_DAY	commands/dosread.cpp	511;"	d	file:
SEC_HOUR	commands/dosread.cpp	510;"	d	file:
SEC_LYEAR	commands/dosread.cpp	513;"	d	file:
SEC_MIN	commands/dosread.cpp	509;"	d	file:
SEC_YEAR	commands/dosread.cpp	512;"	d	file:
SEEK_ST0	kernel/floppy.cpp	68;"	d	file:
SELECT	kernel/printer.cpp	39;"	d	file:
SEND	h/com.hpp	/^inline constexpr int SEND = 1;             \/* function code for sending messages *\/$/;"	v
SENDING	kernel/proc.hpp	/^inline constexpr unsigned int SENDING = 004;     \/* set when process blocked trying to send *\/$/;"	v
SEP	mm/exec.cpp	31;"	d	file:
SEPARATE	mm/mproc.hpp	/^inline constexpr unsigned int SEPARATE = 040; \/**< Process has separate I&D space. *\/$/;"	v
SEPBIT	commands/chmem.cpp	16;"	d	file:
SEPBIT	commands/size.cpp	15;"	d	file:
SEP_ID_BIT	tools/build.cpp	/^    static constexpr std::size_t SEP_ID_BIT =$/;"	m	struct:minix::builder::BuildConstants	file:
SERVER_Q	kernel/const.hpp	/^inline constexpr int SERVER_Q = 1; \/* ready servers are scheduled via queue 1 *\/$/;"	v
SETGID	h/callnr.hpp	/^inline constexpr int SETGID = 46;$/;"	v
SETJMP_H	include/setjmp.hpp	8;"	d
SETUID	h/callnr.hpp	/^inline constexpr int SETUID = 23;$/;"	v
SET_ALARM	h/com.hpp	/^inline constexpr int SET_ALARM = 1;  \/* fcn code to CLOCK, set up alarm *\/$/;"	v
SET_TIME	h/com.hpp	/^inline constexpr int SET_TIME = 4;   \/* fcn code to CLOCK, set real time *\/$/;"	v
SF	commands/mined2.cpp	/^SF() { search("Search forward:", FORWARD); }$/;"	f
SH	commands/mined1.cpp	/^SH() {$/;"	f
SHA3_256_RATE	crypto/kyber_impl/fips202.h	9;"	d
SHA3_512_RATE	crypto/kyber_impl/fips202.h	10;"	d
SHAKE128_RATE	crypto/kyber_impl/fips202.h	7;"	d
SHAKE256_RATE	crypto/kyber_impl/fips202.h	8;"	d
SHELL	commands/cc.cpp	/^char *SHELL = "\/bin\/sh";$/;"	v
SHELL	commands/make.cpp	24;"	d	file:
SHIFT_MARK	commands/mined.hpp	36;"	d
SHIFT_MARK	include/mined.hpp	36;"	d
SHIFT_SIZE	commands/mined.hpp	35;"	d
SHIFT_SIZE	include/mined.hpp	35;"	d
SHRINKBY	commands/sh1.cpp	734;"	d	file:
SHUTDOWN	commands/svcctl.hpp	/^    SHUTDOWN = 8       \/\/!< Terminate the manager thread$/;"	m	class:svcctl::Message
SIGALRM	include/shared/signal_constants.hpp	/^inline constexpr int SIGALRM = 14; \/* alarm clock *\/$/;"	v
SIGBUS	include/shared/signal_constants.hpp	/^inline constexpr int SIGBUS = 10;  \/* bus error *\/$/;"	v
SIGEMT	include/shared/signal_constants.hpp	/^inline constexpr int SIGEMT = 7;   \/* EMT instruction *\/$/;"	v
SIGFPE	include/shared/signal_constants.hpp	/^inline constexpr int SIGFPE = 8;   \/* floating point exception *\/$/;"	v
SIGHUP	include/shared/signal_constants.hpp	/^inline constexpr int SIGHUP = 1;   \/* hangup *\/$/;"	v
SIGILL	include/shared/signal_constants.hpp	/^inline constexpr int SIGILL = 4;   \/* illegal instruction (not reset when caught)*\/$/;"	v
SIGINT	include/shared/signal_constants.hpp	/^inline constexpr int SIGINT = 2;   \/* interrupt (DEL) *\/$/;"	v
SIGIOT	include/shared/signal_constants.hpp	/^inline constexpr int SIGIOT = 6;   \/* IOT instruction *\/$/;"	v
SIGKILL	include/shared/signal_constants.hpp	/^inline constexpr int SIGKILL = 9;  \/* kill (cannot be caught or ignored) *\/$/;"	v
SIGNAL	h/callnr.hpp	/^inline constexpr int SIGNAL = 48;$/;"	v
SIGPIPE	include/shared/signal_constants.hpp	/^inline constexpr int SIGPIPE = 13; \/* write on a pipe with no one to read it *\/$/;"	v
SIGQUIT	include/shared/signal_constants.hpp	/^inline constexpr int SIGQUIT = 3;  \/* quit (ASCII FS) *\/$/;"	v
SIGSEGV	include/shared/signal_constants.hpp	/^inline constexpr int SIGSEGV = 11; \/* segmentation violation *\/$/;"	v
SIGSYS	include/shared/signal_constants.hpp	/^inline constexpr int SIGSYS = 12;  \/* bad argument to system call *\/$/;"	v
SIGTERM	include/shared/signal_constants.hpp	/^inline constexpr int SIGTERM = 15; \/* software termination signal from kill *\/$/;"	v
SIGTRAP	include/shared/signal_constants.hpp	/^inline constexpr int SIGTRAP = 5;  \/* trace trap (not reset when caught) *\/$/;"	v
SIG_DFL	include/shared/signal_constants.hpp	/^inline constexpr sighandler_t SIG_DFL = nullptr;$/;"	v
SIG_IGN	include/shared/signal_constants.hpp	/^inline const sighandler_t SIG_IGN = reinterpret_cast<sighandler_t>(1);$/;"	v
SIG_PUSH_BYTES	h/const.hpp	/^inline constexpr int SIG_PUSH_BYTES = 8;      \/\/ bytes pushed by signal$/;"	v
SIMPLE	lib/regexp.cpp	151;"	d	file:
SINGLE_INDIRECT	tools/fsck.cpp	/^    SINGLE_INDIRECT = 1,$/;"	m	class:minix::fsck::ZoneLevel	file:
SIZE	commands/echo.cpp	9;"	d	file:
SMALLER	commands/mined.hpp	/^    SMALLER,$/;"	e	enum:ReturnCode::FLAG
SMALLER	include/mined.hpp	/^    SMALLER,$/;"	e	enum:ReturnCode::FLAG
SO	commands/mined1.cpp	/^char *CE, *VS, *SO, *SE, *CL, *AL, *CM;$/;"	v
SOURCES	common/math/Makefile	/^SOURCES := quaternion.cpp octonion.cpp sedenion.cpp$/;"	m
SOURCES	tools/Makefile	/^SOURCES := $(wildcard $(SRCDIR)\/*.cpp)$/;"	m
SPEC1	kernel/floppy.cpp	91;"	d	file:
SPEC2	kernel/floppy.cpp	92;"	d	file:
SPSTART	lib/regexp.cpp	152;"	d	file:
SP_OFF	kernel/mpx64.cpp	26;"	d	file:
SQUARE_WAVE	kernel/clock.cpp	57;"	d	file:
SR	commands/mined2.cpp	/^SR() { search("Search reverse:", REVERSE); }$/;"	f
SRCDIR	tools/Makefile	/^SRCDIR := .$/;"	m
SRCFILES	commands/cc.cpp	/^struct arglist SRCFILES;$/;"	v	typeref:struct:arglist
SS_REG	kernel/const.hpp	/^inline constexpr int SS_REG = 0;$/;"	v
ST0	kernel/floppy.cpp	47;"	d	file:
ST0_BITS	kernel/floppy.cpp	63;"	d	file:
ST1	kernel/floppy.cpp	48;"	d	file:
ST2	kernel/floppy.cpp	49;"	d	file:
ST3	kernel/floppy.cpp	50;"	d	file:
ST3_FAULT	kernel/floppy.cpp	64;"	d	file:
ST3_READY	kernel/floppy.cpp	66;"	d	file:
ST3_WR_PROTECT	kernel/floppy.cpp	65;"	d	file:
STACKSIZE	tools/init.cpp	10;"	d	file:
STACK_CHANGED	mm/break.cpp	/^constexpr int STACK_CHANGED = 2; \/* flag value when stack size changed *\/$/;"	v
STACK_FAULT	include/shared/signal_constants.hpp	/^inline constexpr int STACK_FAULT = 16; \/* used by kernel to signal stack fault *\/$/;"	v
STACK_SAFETY	kernel/main.cpp	/^static constexpr std::size_t STACK_SAFETY = Traits::SAFETY;$/;"	v	file:
STAR	commands/mined2.cpp	1229;"	d	file:
STAR	lib/regexp.cpp	88;"	d	file:
START	commands/svcctl.hpp	/^    START = 2,         \/\/!< Start a service$/;"	m	class:svcctl::Message
STARTC	commands/stty.cpp	17;"	d	file:
STAT	h/callnr.hpp	/^inline constexpr int STAT = 18;$/;"	v
STATIC	lib/regexp.cpp	168;"	d	file:
STDIO_EOF	include/stdio.hpp	/^inline constexpr int STDIO_EOF = -1; \/\/ Renamed from EOF$/;"	v
STDOUTPUT	fs/putc.cpp	11;"	d	file:
STD_OUT	commands/dosread.cpp	86;"	d	file:
STD_OUT	commands/mined.hpp	50;"	d
STD_OUT	commands/sort.cpp	48;"	d	file:
STD_OUT	include/mined.hpp	50;"	d
STD_OUTPUT	mm/putc.cpp	10;"	d	file:
STICKY_BIT	tools/fsck.cpp	/^    static constexpr std::uint16_t STICKY_BIT = 01000;$/;"	m	struct:minix::fsck::FsckConstants	file:
STIME	h/callnr.hpp	/^inline constexpr int STIME = 25;$/;"	v
STOP	commands/svcctl.hpp	/^    STOP = 3,          \/\/!< Stop a service$/;"	m	class:svcctl::Message
STOPC	commands/stty.cpp	18;"	d	file:
STOPPED	kernel/tty.cpp	143;"	d	file:
STRINGS	include/stdio.hpp	/^constexpr int STRINGS = 128;$/;"	v
ST_CYL	kernel/floppy.cpp	51;"	d	file:
ST_HEAD	kernel/floppy.cpp	52;"	d	file:
ST_PCN	kernel/floppy.cpp	54;"	d	file:
ST_SEC	kernel/floppy.cpp	53;"	d	file:
SU	commands/mined2.cpp	/^SU() {$/;"	f
SUB_DIR	commands/dosread.cpp	52;"	d	file:
SUFFIXES	commands/make.cpp	93;"	d	file:
SUFTAB	commands/roff.cpp	14;"	d	file:
SUMMARY_FILE	tools/migration_dashboard.py	/^SUMMARY_FILE = Path('kr_cpp_summary.json')$/;"	v
SUPER_BLOCK	fs/const.hpp	/^inline constexpr block_nr SUPER_BLOCK = static_cast<block_nr>(1); \/* block number of super block *\/$/;"	v
SUPER_BLOCK	tools/fsck.cpp	/^constexpr std::uint32_t SUPER_BLOCK = 1;$/;"	v
SUPER_MAGIC	fs/const.hpp	/^inline constexpr int SUPER_MAGIC = 0x137F;          \/* magic number contained in super-block *\/$/;"	v
SUPER_SIZE	fs/const.hpp	/^inline constexpr std::size_t SUPER_SIZE = sizeof(super_block);             \/* super_block size *\/$/;"	v
SUSPEND	h/com.hpp	/^inline constexpr int SUSPEND = -998;   \/* used in interrupts when tty has no data *\/$/;"	v
SUSPENDED	fs/fproc.hpp	26;"	d
SU_UID	fs/const.hpp	/^inline constexpr uid SU_UID = static_cast<uid>(0);  \/* super_user's uid *\/$/;"	v
SWAB	commands/dd.cpp	74;"	d	file:
SWITCHCHAR	commands/make.cpp	17;"	d	file:
SWITCHCHAR	commands/make.cpp	25;"	d	file:
SYMMETRIC_H	crypto/kyber_impl/symmetric.h	2;"	d
SYNC	commands/dd.cpp	78;"	d	file:
SYNC	h/callnr.hpp	/^inline constexpr int SYNC = 36;$/;"	v
SYNTAXERR	commands/sh2.cpp	46;"	d	file:
SYSTASK	h/com.hpp	/^inline constexpr int SYSTASK = -2;   \/* internal functions *\/$/;"	v
SYS_ABORT	h/com.hpp	/^inline constexpr int SYS_ABORT = 9;  \/* fcn code for sys_abort() *\/$/;"	v
SYS_COPY	h/com.hpp	/^inline constexpr int SYS_COPY = 6;   \/* fcn code for sys_copy(ptr) *\/$/;"	v
SYS_EXEC	h/com.hpp	/^inline constexpr int SYS_EXEC = 7;   \/* fcn code for sys_exec(procno, new_sp) *\/$/;"	v
SYS_FORK	h/com.hpp	/^inline constexpr int SYS_FORK = 4;   \/* fcn code for sys_fork(parent, child) *\/$/;"	v
SYS_GETSP	h/com.hpp	/^inline constexpr int SYS_GETSP = 2;  \/* fcn code for sys_sp(proc, &new_sp) *\/$/;"	v
SYS_GID	fs/const.hpp	/^inline constexpr gid SYS_GID = static_cast<gid>(0); \/* gid for processes MM and INIT *\/$/;"	v
SYS_NEWMAP	h/com.hpp	/^inline constexpr int SYS_NEWMAP = 5; \/* fcn code for sys_newmap(procno, map_ptr) *\/$/;"	v
SYS_SIG	h/com.hpp	/^inline constexpr int SYS_SIG = 3;    \/* fcn code for sys_sig(proc, sig) *\/$/;"	v
SYS_TIMES	h/com.hpp	/^inline constexpr int SYS_TIMES = 8;  \/* fcn code for sys_times(procno, bufptr) *\/$/;"	v
SYS_UID	fs/const.hpp	/^inline constexpr uid SYS_UID = static_cast<uid>(0); \/* uid for processes MM and INIT *\/$/;"	v
SYS_VECTOR	kernel/const.hpp	/^inline constexpr int SYS_VECTOR = 48;$/;"	v
SYS_XIT	h/com.hpp	/^inline constexpr int SYS_XIT = 1;    \/* fcn code for sys_xit(parent, proc) *\/$/;"	v
S_IEXEC	h/stat.hpp	/^inline constexpr xinim::mode_t S_IEXEC = 00100;   \/* execute\/search permission, owner *\//;"	v
S_IEXEC	include/stat.hpp	/^inline constexpr xinim::mode_t S_IEXEC = 00100;   \/* execute\/search permission, owner *\/$/;"	v
S_IFBLK	h/stat.hpp	/^inline constexpr xinim::mode_t S_IFBLK = 0060000; \/* block special *\/$/;"	v
S_IFBLK	include/stat.hpp	/^inline constexpr xinim::mode_t S_IFBLK = 0060000; \/* block special *\/$/;"	v
S_IFCHR	h/stat.hpp	/^inline constexpr xinim::mode_t S_IFCHR = 0020000; \/* character special *\/$/;"	v
S_IFCHR	include/stat.hpp	/^inline constexpr xinim::mode_t S_IFCHR = 0020000; \/* character special *\/$/;"	v
S_IFDIR	h/stat.hpp	/^inline constexpr xinim::mode_t S_IFDIR = 0040000; \/* directory *\/$/;"	v
S_IFDIR	include/stat.hpp	/^inline constexpr xinim::mode_t S_IFDIR = 0040000; \/* directory *\/$/;"	v
S_IFMT	h/stat.hpp	/^inline constexpr xinim::mode_t S_IFMT = 0170000;  \/* type of file *\/$/;"	v
S_IFMT	include/stat.hpp	/^inline constexpr xinim::mode_t S_IFMT = 0170000;  \/* type of file *\/$/;"	v
S_IFREG	h/stat.hpp	/^inline constexpr xinim::mode_t S_IFREG = 0100000; \/* regular *\/$/;"	v
S_IFREG	include/stat.hpp	/^inline constexpr xinim::mode_t S_IFREG = 0100000; \/* regular *\/$/;"	v
S_IREAD	h/stat.hpp	/^inline constexpr xinim::mode_t S_IREAD = 00400;   \/* read permission, owner *\/$/;"	v
S_IREAD	include/stat.hpp	/^inline constexpr xinim::mode_t S_IREAD = 00400;   \/* read permission, owner *\/$/;"	v
S_ISGID	h/stat.hpp	/^inline constexpr xinim::mode_t S_ISGID = 02000;   \/* set group id on execution *\/$/;"	v
S_ISGID	include/stat.hpp	/^inline constexpr xinim::mode_t S_ISGID = 02000;   \/* set group id on execution *\/$/;"	v
S_ISUID	h/stat.hpp	/^inline constexpr xinim::mode_t S_ISUID = 04000;   \/* set user id on execution *\/$/;"	v
S_ISUID	include/stat.hpp	/^inline constexpr xinim::mode_t S_ISUID = 04000;   \/* set user id on execution *\/$/;"	v
S_ISVTX	h/stat.hpp	/^inline constexpr xinim::mode_t S_ISVTX = 01000;   \/* save swapped text even after use *\/$/;"	v
S_ISVTX	include/stat.hpp	/^inline constexpr xinim::mode_t S_ISVTX = 01000;   \/* save swapped text even after use *\/$/;"	v
S_IWRITE	h/stat.hpp	/^inline constexpr xinim::mode_t S_IWRITE = 00200;  \/* write permission, owner *\/$/;"	v
S_IWRITE	include/stat.hpp	/^inline constexpr xinim::mode_t S_IWRITE = 00200;  \/* write permission, owner *\/$/;"	v
S_flag	commands/cc.cpp	/^int S_flag = 0;$/;"	v
SafeBuffer	include/lib.hpp	/^    explicit SafeBuffer(std::size_t count = 1)$/;"	f	class:SafeBuffer
SafeBuffer	include/lib.hpp	/^template <typename Type> class SafeBuffer {$/;"	c
Save	commands/roff.cpp	/^FILE *Save;$/;"	v
Scheduler	kernel/schedule.hpp	/^class Scheduler {$/;"	c	namespace:sched
ScopedPortLock	kernel/at_wini.cpp	/^    ScopedPortLock() { lock(); }$/;"	f	class:ScopedPortLock
ScopedPortLock	kernel/at_wini.cpp	/^class ScopedPortLock {$/;"	c	file:
ScopedPortLock	kernel/wini.cpp	/^    ScopedPortLock() { lock(); }$/;"	f	class:ScopedPortLock
ScopedPortLock	kernel/wini.cpp	/^class ScopedPortLock {$/;"	c	file:
ScopedPortLock	kernel/xt_wini.cpp	/^    ScopedPortLock() { lock(); }$/;"	f	class:ScopedPortLock
ScopedPortLock	kernel/xt_wini.cpp	/^class ScopedPortLock {$/;"	c	file:
SectorAddress	tools/diskio.hpp	/^struct SectorAddress {$/;"	s	namespace:diskio
SectorBuffer	tools/build.cpp	/^class SectorBuffer {$/;"	c	class:minix::builder::ProgramType	file:
SectorBuffer	tools/diskio.hpp	/^    SectorBuffer(const void *src, std::size_t size)$/;"	f	class:SectorBuffer
SectorBuffer	tools/diskio.hpp	/^    explicit SectorBuffer(std::size_t size = DiskConstants::SECTOR_SIZE)$/;"	f	class:SectorBuffer
SectorBuffer	tools/diskio.hpp	/^class SectorBuffer {$/;"	c
Sedenion	common/math/sedenion.cpp	/^Sedenion::Sedenion(const Octonion& o1, const Octonion& o2) {$/;"	f	class:Common::Math::Sedenion
Sedenion	kernel/sedenion.hpp	/^struct Sedenion {$/;"	s	namespace:hyper
Send	kernel/wormhole.hpp	/^enum class EndpointState { Idle, Send, Recv };$/;"	m	class:fastpath::EndpointState
SendBlocked	kernel/wormhole.hpp	/^enum class ThreadStatus { Running, Blocked, SendBlocked, RecvBlocked };$/;"	m	class:fastpath::ThreadStatus
ServiceInfo	kernel/service.hpp	/^    struct ServiceInfo {$/;"	s	class:svc::ServiceManager
ServiceManager	kernel/service.cpp	/^ServiceManager::ServiceManager() { load(); }$/;"	f	class:svc::ServiceManager
ServiceManager	kernel/service.hpp	/^class ServiceManager {$/;"	c	namespace:svc
SgFlags	include/sgtty.hpp	/^enum class SgFlags : int {$/;"	c
State	kernel/wormhole.hpp	/^struct State {$/;"	s	namespace:fastpath
Stream	include/minix/io/stream.hpp	/^class Stream {$/;"	c	namespace:minix::io
SuperBlock	include/minix/fs/const.hpp	/^    SuperBlock = 5,$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
SuperBlock	tools/fsck.cpp	/^class SuperBlock {$/;"	c	class:minix::fsck::ZoneLevel	file:
T	h/const.hpp	/^inline constexpr int T = 0;         \/\/ text segment index$/;"	v
TAB	commands/tail.cpp	13;"	d	file:
TAB_MASK	kernel/tty.cpp	67;"	d	file:
TAB_SIZE	kernel/tty.cpp	66;"	d	file:
TAG_SIZE	crypto/kyber.cpp	/^constexpr std::size_t TAG_SIZE = 16;$/;"	m	namespace:pq::kyber::__anon21	file:
TAG_SIZE	kernel/lattice_ipc.cpp	/^constexpr std::size_t TAG_SIZE = lattice::AEAD_TAG_SIZE;$/;"	m	namespace:__anon15	file:
TAND	include/sh.hpp	/^    TAND,     \/* && *\/$/;"	e	enum:OpType
TARGET	tools/Makefile	/^TARGET := $(BUILDDIR)\/build$/;"	m
TARGET_LIB	common/math/Makefile	/^TARGET_LIB := libmathalgebras.a$/;"	m
TASK_Q	kernel/const.hpp	/^inline constexpr int TASK_Q = 0;   \/* ready tasks are scheduled via queue 0 *\/$/;"	v
TASK_REPLY	h/callnr.hpp	/^inline constexpr int TASK_REPLY = 68; \/* to FS: reply code from tty task *\/$/;"	v
TASK_STACK_BYTES	kernel/const.hpp	/^inline constexpr std::size_t TASK_STACK_BYTES = 256; \/* how many bytes for each task stack *\/$/;"	v
TASYNC	include/sh.hpp	/^    TASYNC  \/* c & *\/$/;"	e	enum:OpType
TBRACE	include/sh.hpp	/^    TBRACE, \/* {c-list} *\/$/;"	e	enum:OpType
TCASE	include/sh.hpp	/^    TCASE,$/;"	e	enum:OpType
TCOM	include/sh.hpp	/^    TCOM = 1, \/* command *\/$/;"	e	enum:OpType
TCP_CHILD_PORT	tests/test_net_driver_ipv6.cpp	/^constexpr uint16_t TCP_CHILD_PORT = 17003;$/;"	m	namespace:__anon11	file:
TCP_PARENT_PORT	tests/test_net_driver_ipv6.cpp	/^constexpr uint16_t TCP_PARENT_PORT = 17002;$/;"	m	namespace:__anon11	file:
TDO	include/sh.hpp	/^    TDO,$/;"	e	enum:OpType
TELIF	include/sh.hpp	/^    TELIF,$/;"	e	enum:OpType
TEXT	commands/chmem.cpp	11;"	d	file:
TEXT	commands/size.cpp	10;"	d	file:
TEXTB	mm/exec.cpp	32;"	d	file:
TFOR	include/sh.hpp	/^    TFOR,$/;"	e	enum:OpType
THEN	commands/sh2.cpp	28;"	d	file:
TIF	include/sh.hpp	/^    TIF,$/;"	e	enum:OpType
TIME	commands/make.cpp	35;"	d	file:
TIME	h/callnr.hpp	/^inline constexpr int TIME = 13;$/;"	v
TIMER0	kernel/clock.cpp	54;"	d	file:
TIMER2	kernel/tty.cpp	807;"	d	file:
TIMER3	kernel/tty.cpp	808;"	d	file:
TIMER_MODE	kernel/clock.cpp	55;"	d	file:
TIMES	h/callnr.hpp	/^inline constexpr int TIMES = 43;$/;"	v
TIOCGETC	include/sgtty.hpp	/^constexpr int TIOCGETC = ('t' << 8) | 18; \/**< get control chars *\/$/;"	m	class:SgFlags
TIOCGETP	include/sgtty.hpp	/^constexpr int TIOCGETP = ('t' << 8) | 8;  \/**< get parameters *\/$/;"	m	class:SgFlags
TIOCSETC	include/sgtty.hpp	/^constexpr int TIOCSETC = ('t' << 8) | 17; \/**< set control chars *\/$/;"	m	class:SgFlags
TIOCSETP	include/sgtty.hpp	/^constexpr int TIOCSETP = ('t' << 8) | 9;  \/**< set parameters *\/$/;"	m	class:SgFlags
TLIST	include/sh.hpp	/^    TLIST,    \/* a [&;] b *\/$/;"	e	enum:OpType
TOP_ROW	kernel/tty.cpp	84;"	d	file:
TOR	include/sh.hpp	/^    TOR,      \/* || *\/$/;"	e	enum:OpType
TOT	commands/chmem.cpp	14;"	d	file:
TOTB	mm/exec.cpp	35;"	d	file:
TOTPOS	commands/chmem.cpp	15;"	d	file:
TO_USER	h/const.hpp	/^inline constexpr int TO_USER = 0;      \/\/ copy from fs to user$/;"	v
TPAREN	include/sh.hpp	/^    TPAREN,   \/* (c-list) *\/$/;"	e	enum:OpType
TPAT	include/sh.hpp	/^    TPAT,   \/* pattern in case *\/$/;"	e	enum:OpType
TPIPE	include/sh.hpp	/^    TPIPE,    \/* a | b *\/$/;"	e	enum:OpType
TRANSFER_UNIT	commands/cp.cpp	12;"	d	file:
TRANS_ST0	kernel/floppy.cpp	67;"	d	file:
TRIPLE_INDIRECT	tools/fsck.cpp	/^    TRIPLE_INDIRECT = 3$/;"	m	class:minix::fsck::ZoneLevel	file:
TRUE	commands/ar.cpp	/^constexpr bool TRUE = true;$/;"	v
TRUE	commands/dosread.cpp	63;"	d	file:
TRUE	commands/make.cpp	128;"	d	file:
TRUE	commands/tail.cpp	10;"	d	file:
TRUE	commands/tar.cpp	28;"	d	file:
TRUE	commands/tr.cpp	19;"	d	file:
TRUE	h/const.hpp	/^inline constexpr bool TRUE = true;   \/\/\/< Boolean true$/;"	v
TRUE	include/mined.hpp	/^    TRUE,$/;"	e	enum:ReturnCode::FLAG
TRUE_ENUM	commands/mined.hpp	/^    TRUE_ENUM = 1,  \/\/ Renamed to avoid conflict with potential macros\/keywords$/;"	e	enum:ReturnCode::FLAG
TRUE_ENUM	commands/sort.cpp	/^            TRUE_ENUM$/;"	e	enum:BOOL	file:
TRUNC_SIZE	lib/prints.cpp	10;"	d	file:
TTY	h/com.hpp	/^inline constexpr int TTY = -7;         \/* terminal I\/O class *\/$/;"	v
TTY_BUF_SIZE	kernel/tty.cpp	65;"	d	file:
TTY_CHAR_INT	h/com.hpp	/^inline constexpr int TTY_CHAR_INT = 1; \/* fcn code for tty input interrupt *\/$/;"	v
TTY_IN_BYTES	kernel/tty.cpp	63;"	d	file:
TTY_IOCTL	h/com.hpp	/^inline constexpr int TTY_IOCTL = 5;    \/* fcn code for ioctl *\/$/;"	v
TTY_O_DONE	h/com.hpp	/^inline constexpr int TTY_O_DONE = 2;   \/* fcn code for tty output done *\/$/;"	v
TTY_RAM_WORDS	kernel/tty.cpp	64;"	d	file:
TTY_READ	h/com.hpp	/^inline constexpr int TTY_READ = 3;     \/* fcn code for reading from tty *\/$/;"	v
TTY_WRITE	h/com.hpp	/^inline constexpr int TTY_WRITE = 4;    \/* fcn code for writing to tty *\/$/;"	v
TUNTIL	include/sh.hpp	/^    TUNTIL,$/;"	e	enum:OpType
TWHILE	include/sh.hpp	/^    TWHILE,$/;"	e	enum:OpType
TWO	commands/cmp.cpp	64;"	d	file:
TWO_INTS	kernel/tty.cpp	147;"	d	file:
TXTLEN	commands/roff.cpp	15;"	d	file:
TYPE_H	h/type.hpp	5;"	d
TYPE_TOKENS	tools/classify_style.py	/^TYPE_TOKENS = {$/;"	v
TableFull	include/minix/fs/inode.hpp	/^    TableFull,$/;"	m	class:minix::fs::InodeError
ThreadStatus	kernel/wormhole.hpp	/^enum class ThreadStatus { Running, Blocked, SendBlocked, RecvBlocked };$/;"	c	namespace:fastpath
ThreadTemplate	kernel/wormhole.hpp	/^template <size_t MR_COUNT = 8> struct ThreadTemplate {$/;"	s	namespace:fastpath
U64_C	include/defs.hpp	31;"	d
UCASE	commands/dd.cpp	76;"	d	file:
UCHARAT	lib/regexp.cpp	134;"	d	file:
UCHARAT	lib/regexp.cpp	136;"	d	file:
UCHARAT	lib/regsub.cpp	30;"	d	file:
UCHARAT	lib/regsub.cpp	32;"	d	file:
UDP_CHILD_PORT	tests/test_net_driver_ipv6.cpp	/^constexpr uint16_t UDP_CHILD_PORT = 17001;$/;"	m	namespace:__anon11	file:
UDP_PARENT_PORT	tests/test_net_driver_ipv6.cpp	/^constexpr uint16_t UDP_PARENT_PORT = 17000;$/;"	m	namespace:__anon11	file:
UI	commands/make.cpp	33;"	d	file:
UMASK	h/callnr.hpp	/^inline constexpr int UMASK = 60;$/;"	v
UMOUNT	h/callnr.hpp	/^inline constexpr int UMOUNT = 22;$/;"	v
UNBUFF	include/stdio.hpp	/^constexpr int UNBUFF = 4;$/;"	v
UNCALIBRATED	kernel/floppy.cpp	129;"	d	file:
UNDEF	commands/mined1.cpp	1055;"	d	file:
UNDERL	commands/roff.cpp	20;"	d	file:
UNIX	commands/mkfs.cpp	48;"	d	file:
UNIX	tools/mkfs.cpp	42;"	d	file:
UNLINK	h/callnr.hpp	/^inline constexpr int UNLINK = 10;$/;"	v
UNPAUSE	h/callnr.hpp	/^inline constexpr int UNPAUSE = 65;    \/* to MM or FS: check for ErrorCode::EINTR *\/$/;"	v
UNTIL	commands/sh2.cpp	36;"	d	file:
UP	commands/mined2.cpp	/^void UP() {$/;"	f
UPPER	commands/sort.cpp	67;"	d	file:
USAGE	commands/sort.cpp	/^char USAGE[] = "Usage: sort [-funbirdcmt'x'] [+beg_pos [-end_pos]] [-o outfile] [file] ..";$/;"	v
USER_Q	kernel/const.hpp	/^inline constexpr int USER_Q = 2;   \/* ready users are scheduled via queue 2 *\/$/;"	v
USTR_SIZE	commands/cc.cpp	/^constexpr int USTR_SIZE = 64; \/* maximum length of string variable *\/$/;"	v
UTIME	h/callnr.hpp	/^inline constexpr int UTIME = 30;$/;"	v
Usage	commands/chmod.cpp	/^static void Usage(void) {$/;"	f	file:
UserInterface	tools/fsck.cpp	/^    explicit UserInterface(FsckMode mode) : mode_(mode) {}$/;"	f	class:minix::fsck::ZoneLevel::UserInterface
UserInterface	tools/fsck.cpp	/^class UserInterface {$/;"	c	class:minix::fsck::ZoneLevel	file:
VALID	commands/mined.hpp	/^    VALID,$/;"	e	enum:ReturnCode::FLAG
VALID	include/mined.hpp	/^    VALID,$/;"	e	enum:ReturnCode::FLAG
VECTOR_BYTES	kernel/const.hpp	/^inline constexpr std::size_t VECTOR_BYTES = 1024;$/;"	v
VERIFY_H	crypto/kyber_impl/verify.h	2;"	d
VGA_CMD_CURSOR_HIGH_BYTE	console.cpp	9;"	d	file:
VGA_CMD_CURSOR_LOW_BYTE	console.cpp	10;"	d	file:
VGA_COLOR_BLACK	console.h	7;"	d
VGA_COLOR_BLUE	console.h	8;"	d
VGA_COLOR_BROWN	console.h	13;"	d
VGA_COLOR_CYAN	console.h	10;"	d
VGA_COLOR_DARK_GREY	console.h	15;"	d
VGA_COLOR_GREEN	console.h	9;"	d
VGA_COLOR_LIGHT_BLUE	console.h	16;"	d
VGA_COLOR_LIGHT_BROWN	console.h	21;"	d
VGA_COLOR_LIGHT_CYAN	console.h	18;"	d
VGA_COLOR_LIGHT_GREEN	console.h	17;"	d
VGA_COLOR_LIGHT_GREY	console.h	14;"	d
VGA_COLOR_LIGHT_MAGENTA	console.h	20;"	d
VGA_COLOR_LIGHT_RED	console.h	19;"	d
VGA_COLOR_MAGENTA	console.h	12;"	d
VGA_COLOR_RED	console.h	11;"	d
VGA_COLOR_WHITE	console.h	22;"	d
VGA_CTRL_REGISTER	console.cpp	5;"	d	file:
VGA_DATA_REGISTER	console.cpp	6;"	d	file:
VGA_HEIGHT	console.cpp	/^const int VGA_HEIGHT = 25;$/;"	v
VGA_WIDTH	console.cpp	/^const int VGA_WIDTH = 80;$/;"	v
VI	commands/mined1.cpp	/^VI() {$/;"	f
VID_ORG	kernel/tty.cpp	819;"	d	file:
VMM_H	vmm.h	2;"	d
VM_ANON	include/vm.hpp	/^    VM_ANON = 0x20    \/**< Region is anonymous. *\/$/;"	m	class:VmFlags
VM_EXEC	include/vm.hpp	/^    VM_EXEC = 0x4,    \/**< Region is executable. *\/$/;"	m	class:VmFlags
VM_H	include/vm.hpp	8;"	d
VM_MAX_AREAS	include/vm.hpp	/^inline constexpr int VM_MAX_AREAS = 16;$/;"	m	class:VmFlags
VM_PRIVATE	include/vm.hpp	/^    VM_PRIVATE = 0x8, \/**< Region is private. *\/$/;"	m	class:VmFlags
VM_READ	include/vm.hpp	/^    VM_READ = 0x1,    \/**< Region is readable. *\/$/;"	m	class:VmFlags
VM_SHARED	include/vm.hpp	/^    VM_SHARED = 0x10, \/**< Region is shared. *\/$/;"	m	class:VmFlags
VM_WRITE	include/vm.hpp	/^    VM_WRITE = 0x2,   \/**< Region is writable. *\/$/;"	m	class:VmFlags
VS	commands/mined1.cpp	/^char *CE, *VS, *SO, *SE, *CL, *AL, *CM;$/;"	v
V_FLAG	commands/cc.cpp	/^char *V_FLAG = "-Vs2.2w2.2i2.2l4.2f4.2d8.2p2.2";$/;"	v
VarFlag	include/sh.hpp	/^enum VarFlag {$/;"	g
VmFlags	include/vm.hpp	/^enum class VmFlags : int {$/;"	c
WAIT	commands/make.cpp	150;"	d	file:
WAIT	commands/make.cpp	171;"	d	file:
WAIT	h/callnr.hpp	/^inline constexpr int WAIT = 7;$/;"	v
WAITING	kernel/tty.cpp	149;"	d	file:
WAITING	mm/mproc.hpp	/^inline constexpr unsigned int WAITING = 002;  \/**< Set by the WAIT system call. *\/$/;"	v
WB	commands/mined2.cpp	/^WB() {$/;"	f
WEEKS_PER_MONTH	commands/cal.cpp	/^constexpr int WEEKS_PER_MONTH = 6; \/* Max. weeks in a month	*\/$/;"	v
WHILE	commands/sh2.cpp	35;"	d	file:
WINCHESTER	h/com.hpp	/^inline constexpr int WINCHESTER = -6; \/* winchester (hard) disk class *\/$/;"	v
WINI_DRIVER	kernel/Makefile	/^                                                                       ON) WINI_DRIVER = pc endif$/;"	m
WIN_DATA	kernel/wini.cpp	41;"	d	file:
WIN_DATA	kernel/xt_wini.cpp	38;"	d	file:
WIN_DMA	kernel/wini.cpp	44;"	d	file:
WIN_DMA	kernel/xt_wini.cpp	41;"	d	file:
WIN_ECC_READ	kernel/wini.cpp	58;"	d	file:
WIN_ECC_READ	kernel/xt_wini.cpp	55;"	d	file:
WIN_READ	kernel/at_wini.cpp	/^inline constexpr uint8_t WIN_READ = 0x20;        \/**< command for the drive to read *\/$/;"	m	namespace:__anon18	file:
WIN_READ	kernel/wini.cpp	55;"	d	file:
WIN_READ	kernel/xt_wini.cpp	52;"	d	file:
WIN_RECALIBRATE	kernel/at_wini.cpp	/^inline constexpr uint8_t WIN_RECALIBRATE = 0x10; \/**< command for the drive to recalibrate *\/$/;"	m	namespace:__anon18	file:
WIN_RECALIBRATE	kernel/wini.cpp	53;"	d	file:
WIN_RECALIBRATE	kernel/xt_wini.cpp	50;"	d	file:
WIN_REG1	kernel/at_wini.cpp	/^inline constexpr uint16_t WIN_REG1 = 0x1F0;$/;"	m	namespace:__anon18	file:
WIN_REG2	kernel/at_wini.cpp	/^inline constexpr uint16_t WIN_REG2 = 0x1F1;$/;"	m	namespace:__anon18	file:
WIN_REG3	kernel/at_wini.cpp	/^inline constexpr uint16_t WIN_REG3 = 0x1F2;$/;"	m	namespace:__anon18	file:
WIN_REG4	kernel/at_wini.cpp	/^inline constexpr uint16_t WIN_REG4 = 0x1F3;$/;"	m	namespace:__anon18	file:
WIN_REG5	kernel/at_wini.cpp	/^inline constexpr uint16_t WIN_REG5 = 0x1F4;$/;"	m	namespace:__anon18	file:
WIN_REG6	kernel/at_wini.cpp	/^inline constexpr uint16_t WIN_REG6 = 0x1F5;$/;"	m	namespace:__anon18	file:
WIN_REG7	kernel/at_wini.cpp	/^inline constexpr uint16_t WIN_REG7 = 0x1F6;$/;"	m	namespace:__anon18	file:
WIN_REG8	kernel/at_wini.cpp	/^inline constexpr uint16_t WIN_REG8 = 0x1F7;$/;"	m	namespace:__anon18	file:
WIN_REG9	kernel/at_wini.cpp	/^inline constexpr uint16_t WIN_REG9 = 0x3F6;$/;"	m	namespace:__anon18	file:
WIN_SELECT	kernel/wini.cpp	43;"	d	file:
WIN_SELECT	kernel/xt_wini.cpp	40;"	d	file:
WIN_SENSE	kernel/wini.cpp	54;"	d	file:
WIN_SENSE	kernel/xt_wini.cpp	51;"	d	file:
WIN_SPECIFY	kernel/at_wini.cpp	/^inline constexpr uint8_t WIN_SPECIFY = 0x91;     \/**< command for the controller to accept params *\/$/;"	m	namespace:__anon18	file:
WIN_SPECIFY	kernel/wini.cpp	57;"	d	file:
WIN_SPECIFY	kernel/xt_wini.cpp	54;"	d	file:
WIN_STATUS	kernel/wini.cpp	42;"	d	file:
WIN_STATUS	kernel/xt_wini.cpp	39;"	d	file:
WIN_WRITE	kernel/at_wini.cpp	/^inline constexpr uint8_t WIN_WRITE = 0x30;       \/**< command for the drive to write *\/$/;"	m	namespace:__anon18	file:
WIN_WRITE	kernel/wini.cpp	56;"	d	file:
WIN_WRITE	kernel/xt_wini.cpp	53;"	d	file:
WORD	commands/sh2.cpp	23;"	d	file:
WORD_H	include/sh.hpp	322;"	d
WORD_MASK	kernel/tty.cpp	795;"	d	file:
WORD_SIZE	h/const.hpp	/^inline constexpr int WORD_SIZE = 2; \/\/ number of bytes per word$/;"	v
WORST	lib/regexp.cpp	153;"	d	file:
WRITE	commands/dosread.cpp	70;"	d	file:
WRITE	commands/libpack.cpp	16;"	d	file:
WRITE	commands/mined.hpp	/^    WRITE$/;"	e	enum:ReturnCode::FLAG
WRITE	h/callnr.hpp	/^inline constexpr int WRITE = 4;$/;"	v
WRITE	include/mined.hpp	/^    WRITE$/;"	e	enum:ReturnCode::FLAG
WRITEMODE	include/stdio.hpp	/^constexpr int WRITEMODE = 2;$/;"	v
WRITE_ERROR	commands/uniq.cpp	20;"	d	file:
WRITE_PROTECT	kernel/floppy.cpp	71;"	d	file:
WRITING	h/const.hpp	/^inline constexpr int WRITING = 1;      \/\/ copy data from user$/;"	v
WT	commands/mined1.cpp	/^WT() {$/;"	f
W_BIT	h/const.hpp	/^inline constexpr mask_bits W_BIT = 0000002;           \/\/ write protection bit$/;"	v
W_BUFLEN	commands/make.cpp	2188;"	d	file:
W_PERLINE	commands/make.cpp	2187;"	d	file:
WaitCore	include/sh.hpp	/^constexpr bool WaitCore(int s) { return (s & 0200) != 0; }$/;"	f
WaitForGraph	kernel/wait_graph.hpp	/^class WaitForGraph {$/;"	c	namespace:lattice
WaitSig	include/sh.hpp	/^constexpr int WaitSig(int s) { return s & 0177; }$/;"	f
WaitVal	include/sh.hpp	/^constexpr int WaitVal(int s) { return (s >> 8) & 0377; }$/;"	f
WriteImmediate	fs/buf.hpp	/^    WriteImmediate = 0100,$/;"	m	class:BlockType
X86_64	kernel/main.cpp	/^    X86_64,$/;"	m	class:Architecture	file:
XBREAK	commands/mined.hpp	34;"	d
XBREAK	include/mined.hpp	34;"	d
XDOLL	include/sh.hpp	/^    XDOLL,      \/* expanding ${} *\/$/;"	e	enum:IoTask
XGRAVE	include/sh.hpp	/^    XGRAVE,     \/* expanding `'s *\/$/;"	e	enum:IoTask
XINIM_CORE_TYPES_HPP	include/xinim/core_types.hpp	2;"	d
XIO	include/sh.hpp	/^    XIO         \/* file IO *\/$/;"	e	enum:IoTask
XMAX	commands/mined.hpp	32;"	d
XMAX	include/mined.hpp	32;"	d
XOFF_CHAR	kernel/tty.cpp	74;"	d	file:
XOF_BLOCKBYTES	crypto/kyber_impl/symmetric.h	24;"	d
XON_CHAR	kernel/tty.cpp	75;"	d	file:
XOTHER	include/sh.hpp	/^    XOTHER = 0, \/* none of the below *\/$/;"	e	enum:IoTask
XPIPE	fs/const.hpp	/^inline constexpr int XPIPE = 0; \/* used in fp_task when suspended on pipe *\/$/;"	v
XT	commands/mined1.cpp	/^XT() {$/;"	f
XTABS	include/sgtty.hpp	/^    XTABS = 0006000,  \/**< do tab expansion *\/$/;"	m	class:SgFlags
XT_WINI_VECTOR	kernel/const.hpp	/^inline constexpr int XT_WINI_VECTOR = 34;$/;"	v
X_BIT	h/const.hpp	/^inline constexpr mask_bits X_BIT = 0000001;           \/\/ execute protection bit$/;"	v
X_PLUS	commands/mined.hpp	28;"	d
X_PLUS	include/mined.hpp	28;"	d
YA	commands/mined2.cpp	/^YA() { set_up(NO_DELETE); }$/;"	f
YEAR	commands/ar.cpp	474;"	d	file:
YEAR	commands/dosread.cpp	632;"	d	file:
YEAR	commands/ls.cpp	445;"	d	file:
YMAX	commands/mined.hpp	19;"	d
YMAX	commands/mined.hpp	21;"	d
YMAX	include/mined.hpp	19;"	d
YMAX	include/mined.hpp	21;"	d
YYERRCODE	commands/sh2.cpp	40;"	d	file:
YYSTYPE	commands/sh2.cpp	/^} YYSTYPE;$/;"	t	typeref:union:__anon26	file:
Y_PLUS	commands/mined.hpp	29;"	d
Y_PLUS	include/mined.hpp	29;"	d
ZEROBUF_SIZE	mm/const.hpp	/^inline constexpr std::size_t ZEROBUF_SIZE = 1024; \/* buffer size for erasing memory *\/$/;"	v
ZMAP_SLOTS	fs/const.hpp	/^inline constexpr int ZMAP_SLOTS = 6;               \/* max # of blocks in the zone bit map *\/$/;"	v
ZMap	fs/buf.hpp	/^    ZMap = 4 + WriteImmediate + OneShot,$/;"	m	class:BlockType
ZONE_MAP	commands/mkfs.cpp	57;"	d	file:
ZONE_MAP	tools/mkfs.cpp	51;"	d	file:
ZONE_NUM_SIZE	fs/const.hpp	/^inline constexpr std::size_t ZONE_NUM_SIZE = sizeof(zone_nr);              \/* # bytes in zone nr*\/$/;"	v
ZPair	kernel/sedenion.hpp	/^struct ZPair {$/;"	s	namespace:hyper
ZmapBlock	include/minix/fs/const.hpp	/^    ZmapBlock = 4,$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
ZoneLevel	tools/fsck.cpp	/^enum class ZoneLevel : std::uint8_t {$/;"	c	namespace:minix::fsck	file:
Zuper	fs/buf.hpp	/^    Zuper = 5 + WriteImmediate + OneShot,$/;"	m	class:BlockType
_EOF	include/stdio.hpp	/^constexpr int _EOF = 8;$/;"	v
_ERR	include/stdio.hpp	/^constexpr int _ERR = ERR; \/\/ compatibility with historical macro$/;"	v
_GNU_SOURCE	crypto/kyber_impl/randombytes.c	13;"	d	file:
_LARGEFILE64_SOURCE	test/test12.cpp	1;"	d	file:
__fflush	lib/fflush.cpp	/^int __fflush(FILE *iop) {$/;"	f
__stdin	lib/printdat.cpp	/^char  __stdin[BUFSIZ];$/;"	v
__stdout	lib/printdat.cpp	/^char  __stdout[BUFSIZ];$/;"	v
_bintoascii	lib/doprintf.cpp	/^static void _bintoascii(long num, int radix, char *a) {$/;"	f	file:
_buf	include/stdio.hpp	/^    char *_buf; \/** buffer start *\/$/;"	m	struct:_io_buf
_buf	lib/getgrent.cpp	/^static char *_buf;$/;"	v	file:
_buf	lib/getpwent.cpp	/^static char *_buf;$/;"	v	file:
_bufcnt	lib/getgrent.cpp	/^static int _bufcnt;$/;"	v	file:
_bufcnt	lib/getpwent.cpp	/^static int _bufcnt;$/;"	v	file:
_buffer	lib/getgrent.cpp	/^static char _buffer[1024];$/;"	v	file:
_buffer	lib/getpwent.cpp	/^static char _buffer[1024];$/;"	v	file:
_cleanup	lib/cleanup.cpp	/^void _cleanup(void) {$/;"	f
_contains_type	tools/classify_style.py	/^def _contains_type(text: str) -> bool:$/;"	f
_count	include/stdio.hpp	/^    int _count; \/** bytes remaining in buffer *\/$/;"	m	struct:_io_buf
_data_org	lib/minix/head.cpp	/^long _data_org[] = {0xDADA, 0, 0, 0, 0, 0, 0, 0};$/;"	v
_doprintf	lib/doprintf.cpp	/^static void _doprintf(FILE *fp, char *format, int args) {$/;"	f	file:
_edata	lib/minix/end.cpp	/^char _edata;$/;"	v
_end	lib/minix/end.cpp	/^char _end;$/;"	v
_environ	lib/crt0.cpp	/^char **_environ;$/;"	v
_environ	lib/crtso.cpp	/^char **_environ;$/;"	v
_environ	lib/minix/crtso.cpp	/^char **_environ;$/;"	v
_fd	include/stdio.hpp	/^    int _fd;    \/** file descriptor *\/$/;"	m	struct:_io_buf
_flags	include/stdio.hpp	/^    int _flags; \/** status flags *\/$/;"	m	struct:_io_buf
_flush	commands/mined1.cpp	/^_flush() { (void)fflush(stdout); }$/;"	f
_getchar	commands/mined1.cpp	/^_getchar() {$/;"	f
_gfd	lib/getgrent.cpp	/^static int _gfd = -1;$/;"	v	file:
_gr_file	lib/getgrent.cpp	/^static char _gr_file[] = "\/etc\/group";$/;"	v	file:
_grbuf	lib/getgrent.cpp	/^static char _grbuf[256];$/;"	v	file:
_io_buf	include/stdio.hpp	/^extern struct _io_buf {$/;"	s
_io_table	lib/printdat.cpp	/^struct  _io_buf  *_io_table[NFILES] = {$/;"	v	typeref:struct:_io_buf
_longjmp	lib/minix/setjmp.cpp	/^void _longjmp(jmp_buf env, int val) {$/;"	f
_longjmp	lib/setjmp.cpp	/^void _longjmp(jmp_buf env, int val) {$/;"	f
_pnt	lib/getgrent.cpp	/^static char *_pnt;$/;"	v	file:
_pnt	lib/getpwent.cpp	/^static char *_pnt;$/;"	v	file:
_printit	lib/doprintf.cpp	/^static void _printit(char *str, int w1, int w2, char padchar, int length, FILE *file) {$/;"	f	file:
_ptr	include/stdio.hpp	/^    char *_ptr; \/** next char in buffer *\/$/;"	m	struct:_io_buf
_pw	lib/getpwent.cpp	/^static int _pw = -1;$/;"	v	file:
_pw_file	lib/getpwent.cpp	/^static char _pw_file[] = "\/etc\/passwd";$/;"	v	file:
_pwbuf	lib/getpwent.cpp	/^static char _pwbuf[256];$/;"	v	file:
_setjmp	lib/minix/setjmp.cpp	/^int _setjmp(jmp_buf env) { return std::setjmp(env); }$/;"	f
_setjmp	lib/setjmp.cpp	/^int _setjmp(jmp_buf env) {$/;"	f
_stack	commands/make.cpp	/^int _stack = 4000;$/;"	v
_start	boot.S	/^_start:$/;"	l
_start	lib/crt0.cpp	/^void _start(void) {$/;"	f
_start	lib/crtso.cpp	/^void _start(void) {$/;"	f
_start	lib/minix/crtso.cpp	/^void _start(void) {$/;"	f
_start	lib/minix/head.cpp	/^void _start(void) {$/;"	f
_stderr	lib/printdat.cpp	/^struct _io_buf _stderr = {$/;"	v	typeref:struct:_io_buf
_stdin	lib/printdat.cpp	/^struct _io_buf _stdin = {$/;"	v	typeref:struct:_io_buf
_stdout	lib/printdat.cpp	/^struct _io_buf _stdout = {$/;"	v	typeref:struct:_io_buf
_vec_table	kernel/klib88.cpp	/^PUBLIC unsigned _vec_table[142];$/;"	v
a	commands/sh1.cpp	/^int a;$/;"	v
a	commands/sh1.cpp	/^void freearea(a) register int a;$/;"	v
a	commands/time.cpp	/^char a[12] = {"        . \\n"};$/;"	v
a0	commands/sh4.cpp	/^glob0(a0, a1, a2, a3) char *a0;$/;"	v
a1	commands/sh4.cpp	/^unsigned a1;$/;"	v
a1	kernel/make.bat	/^:a1$/;"	l
a2	commands/sh4.cpp	/^int a2;$/;"	v
a3	commands/sh4.cpp	/^int (*a3)();$/;"	v
a_bss	tools/c86/dos2out.cpp	/^	long		a_bss;		\/* size of bss (stack) segment   *\/$/;"	m	struct:a_out_hdr	file:
a_cpu	tools/c86/dos2out.cpp	/^	unsigned char   a_cpu;		\/* cpu-type *\/$/;"	m	struct:a_out_hdr	file:
a_data	tools/c86/dos2out.cpp	/^	long		a_data;		\/* size of data-segment in bytes *\/$/;"	m	struct:a_out_hdr	file:
a_entry	tools/c86/dos2out.cpp	/^	long		a_entry;	\/* program entry-point *\/$/;"	m	struct:a_out_hdr	file:
a_flags	tools/c86/dos2out.cpp	/^	unsigned char	a_flags;	\/* flags for sep I&D etc *\/$/;"	m	struct:a_out_hdr	file:
a_hdrlen	tools/c86/dos2out.cpp	/^	unsigned char	a_hdrlen;	\/* length of header *\/$/;"	m	struct:a_out_hdr	file:
a_magic	tools/c86/dos2out.cpp	/^	unsigned char	a_magic[2];	\/* magic number *\/$/;"	m	struct:a_out_hdr	file:
a_out_hdr	tools/c86/dos2out.cpp	/^struct a_out_hdr {$/;"	s	file:
a_ptr	tools/c86/dos2out.cpp	/^struct a_out_hdr *a_ptr= outbuf;$/;"	v	typeref:struct:a_out_hdr
a_syms	tools/c86/dos2out.cpp	/^	long		a_syms;		\/* symbol-table size *\/$/;"	m	struct:a_out_hdr	file:
a_text	tools/c86/dos2out.cpp	/^	long		a_text;		\/* size of text segment in bytes *\/$/;"	m	struct:a_out_hdr	file:
a_totb	tools/c86/dos2out.cpp	/^	long		a_totb;		\/* other, eg initial stack-ptr *\/$/;"	m	struct:a_out_hdr	file:
a_unused	tools/c86/dos2out.cpp	/^	unsigned char	a_unused;	\/* sic *\/$/;"	m	struct:a_out_hdr	file:
a_version	tools/c86/dos2out.cpp	/^	unsigned short	a_version;	\/* version stamp *\/$/;"	m	struct:a_out_hdr	file:
aa	test/test0.cpp	/^char aa[100];$/;"	v
abort	lib/abort.cpp	/^[[noreturn]] void abort() { exit(99); }$/;"	f
abort_mined	commands/mined1.cpp	/^abort_mined() {$/;"	f
acc_time	fs/param.hpp	2;"	d
access	lib/access.cpp	/^int access(const char *name, int mode) {$/;"	f
act	commands/sh3.cpp	/^int act;$/;"	v
add	commands/ar.cpp	/^static void add(char *name, int fd, char mess) {$/;"	f	file:
add_dependency	kernel/service.cpp	/^void ServiceManager::add_dependency(xinim::pid_t pid, xinim::pid_t dep) {$/;"	f	class:svc::ServiceManager
add_edge	kernel/wait_graph.cpp	/^bool WaitForGraph::add_edge(xinim::pid_t src, xinim::pid_t dst) {$/;"	f	class:lattice::WaitForGraph
add_path	commands/make.cpp	/^static void add_path(char *p) {$/;"	f	file:
add_remote	kernel/net_driver.cpp	/^void add_remote(node_t node, const std::string &host, uint16_t port, Protocol proto) {$/;"	f	namespace:net
add_to_cache	tools/diskio.cpp	/^void DiskInterface::add_to_cache(SectorAddress sector, SectorBuffer data) const {$/;"	f	class:diskio::DiskInterface
addr	fs/param.hpp	3;"	d
addr	include/paging.hpp	/^    phys_addr64 addr;$/;"	m	struct:pt_entry
addr	mm/param.hpp	8;"	d
addr	multiboot.h	/^    uint64_t addr;$/;"	m	struct:multiboot_mmap_entry
addr	test/test9.cpp	/^char *addr() {$/;"	f
addr	tools/r.cpp	/^static long addr;$/;"	v	file:
address	commands/dosread.cpp	/^DIRECTORY *address;$/;"	v
address	commands/mined1.cpp	/^char *address;$/;"	v
address	commands/sort.cpp	/^char *address;$/;"	v
address	commands/tar.cpp	/^char *address;$/;"	v
address	tools/diskio.hpp	/^        SectorAddress address;$/;"	m	struct:DiskInterface::CacheEntry
adep	commands/make.cpp	/^add_rule2(adep, atarg, arule, aflag) char *adep, *atarg;$/;"	v
adflag	commands/roff.cpp	/^writeline(adflag, flushflag) int adflag, flushflag;$/;"	v
adjtoggle	commands/roff.cpp	/^int adjtoggle;$/;"	v
adjust	mm/break.cpp	/^[[nodiscard]] PUBLIC int adjust(struct mproc *rmp, std::size_t data_clicks,$/;"	f
adjust_boundary	commands/tar.cpp	/^adjust_boundary() {$/;"	f
advance	fs/path.cpp	/^struct inode *advance(struct inode *dirp, char string[NAME_SIZE]) {$/;"	f
aead_decrypt	kernel/lattice_ipc.cpp	/^aead_decrypt(std::span<const std::byte> cipher,$/;"	f	namespace:__anon15
aead_encrypt	kernel/lattice_ipc.cpp	/^aead_encrypt(std::span<const std::byte> plain,$/;"	f	namespace:__anon15
aes_gcm_decrypt	crypto/kyber.cpp	/^std::vector<std::byte> aes_gcm_decrypt(std::span<const std::byte> cipher,$/;"	f	namespace:pq::kyber::__anon21
aes_gcm_encrypt	crypto/kyber.cpp	/^std::vector<std::byte> aes_gcm_encrypt(std::span<const std::byte> plain,$/;"	f	namespace:pq::kyber::__anon21
afile	include/sh.hpp	/^    int afile; \/* file descriptor *\/$/;"	m	struct:ioarg
aflag	commands/make.cpp	/^int aflag;$/;"	v
al_argc	commands/cc.cpp	/^    int al_argc;$/;"	m	struct:arglist	file:
al_argv	commands/cc.cpp	/^    char *al_argv[MAXARGC];$/;"	m	struct:arglist	file:
alarm	lib/alarm.cpp	/^int alarm(unsigned int sec) {$/;"	f
alarms	test/test5.cpp	/^int childsigs, parsigs, alarms;$/;"	v
alfun	lib/sleep.cpp	/^static void alfun(int signum) { (void)signum; }$/;"	f	file:
align	commands/mined1.cpp	1139;"	d	file:
align_down	vmm.h	/^static inline uintptr_t align_down(uintptr_t addr, size_t alignment) {$/;"	f
align_up	vmm.h	/^static inline uintptr_t align_up(uintptr_t addr, size_t alignment) {$/;"	f
alignment	include/psd/vm/semantic_memory.hpp	/^    static constexpr std::size_t alignment = 16;$/;"	m	struct:psd::vm::semantic_traits
alignment	include/psd/vm/semantic_memory.hpp	/^    static constexpr std::size_t alignment = 64;$/;"	m	struct:psd::vm::semantic_traits
alignment	include/psd/vm/semantic_memory.hpp	/^    static constexpr std::size_t alignment = 8;         \/\/ required byte alignment$/;"	m	struct:psd::vm::semantic_traits
alloc	commands/cc.cpp	/^static char *alloc(unsigned u) {$/;"	f	file:
alloc_extent_table	fs/compat.cpp	/^PUBLIC int alloc_extent_table(struct inode *ip, unsigned short count) {$/;"	f
alloc_inode	fs/inode.cpp	/^PUBLIC struct inode *alloc_inode(uint16_t dev,$/;"	f
alloc_zone	commands/mkfs.cpp	/^int alloc_zone() {$/;"	f
alloc_zone	tools/mkfs.cpp	/^int alloc_zone() {$/;"	f
alpha	commands/mined.hpp	206;"	d
alpha	include/mined.hpp	199;"	d
alt	kernel/tty.cpp	/^PRIVATE int control, alt;                         \/* keep track of key statii *\/$/;"	v
analyze	tools/arch_scan.py	/^def analyze(path: str) -> Tuple[str, List[str], List[str]]:$/;"	f
analyze_dependencies	tools/migration_dashboard.py	/^def analyze_dependencies(files):$/;"	f
andor	commands/sh2.cpp	/^static struct op *andor() {$/;"	f	file:
aout	kernel/dmp.cpp	/^uint64_t aout[NR_PROCS]; \/* pointers to the program names (phys_bytes -> uint64_t) *\/$/;"	v
ap	commands/sh4.cpp	/^register char **ap;$/;"	v
ap	commands/sh5.cpp	/^register struct ioarg *ap;$/;"	v	typeref:struct:ioarg
ap	commands/sh5.cpp	/^struct ioarg *ap;$/;"	v	typeref:struct:ioarg
app_fl	commands/ar.cpp	/^BOOL app_fl;$/;"	v
append	commands/cc.cpp	/^static void append(struct arglist *al, char *arg) {$/;"	f	file:
append	include/minix/io/file_operations.hpp	/^    append = 1 << 5$/;"	m	class:minix::io::OpenMode
ar_fd	commands/ar.cpp	/^int ar_fd;$/;"	v
arch	kernel/main.cpp	/^static constexpr Architecture arch =$/;"	v	file:
area	commands/sh1.cpp	/^    int area;$/;"	m	struct:region	file:
area1	commands/sh1.cpp	/^static struct region area1 = {&area2, BUSY};$/;"	v	typeref:struct:region	file:
area2	commands/sh1.cpp	/^static struct region area2 = {&area1, BUSY};$/;"	v	typeref:struct:region	file:
areabrk	commands/sh1.cpp	/^static struct region *areabrk;$/;"	v	typeref:struct:region	file:
areanum	include/sh.hpp	/^int areanum; \/* current allocation area *\/$/;"	v
areap	commands/sh1.cpp	/^static struct region *areap = &area1;$/;"	v	typeref:struct:region	file:
areas	include/vm.hpp	/^    std::vector<vm_area> areas; \/\/\/< List of owned areas.$/;"	m	struct:VmFlags::vm_proc
areatop	commands/sh1.cpp	/^static struct region *areatop = &area1;$/;"	v	typeref:struct:region	file:
arg	commands/sh3.cpp	/^run(arg, f) struct ioarg arg;$/;"	v	typeref:struct:ioarg
arg	commands/sh5.cpp	/^void pushio(arg, fn) struct ioarg arg;$/;"	v	typeref:struct:ioarg
arg	commands/sort.cpp	/^register char *message, *arg;$/;"	v
arg	include/sh.hpp	/^    struct ioarg arg;$/;"	m	struct:io	typeref:struct:io::ioarg
argc	commands/ls.cpp	/^int argc;$/;"	v
argc	commands/mined1.cpp	/^main(argc, argv) int argc;$/;"	v
argc	commands/od.cpp	/^int argc;$/;"	v
argc	tools/c86/dos2out.cpp	/^int argc;$/;"	v
arglist	commands/cc.cpp	/^struct arglist {$/;"	s	file:
arglist	commands/make.cpp	/^struct llist *arglist;$/;"	v	typeref:struct:llist
argptr	commands/sort.cpp	/^char **argptr;   \/* Pointer to argv structure *\/$/;"	v
args	commands/dosread.cpp	/^int args;$/;"	v
args	commands/grep.cpp	/^int args;$/;"	v
args	commands/mined1.cpp	/^int args;$/;"	v
args	commands/stty.cpp	/^struct sgttyb args;$/;"	v	typeref:struct:sgttyb
args	commands/tar.cpp	/^int args;$/;"	v
args	commands/time.cpp	/^char **args;$/;"	v
args	lib/sprintf.cpp	/^int args;$/;"	v
args_limit	commands/sort.cpp	/^int args_limit;  \/* Nr of args given *\/$/;"	v
args_offset	commands/sort.cpp	/^int args_offset; \/* Nr of args spilled on options *\/$/;"	v
argv	commands/ls.cpp	/^char *argv[];$/;"	v
argv	commands/mined1.cpp	/^char *argv[];$/;"	v
argv	commands/od.cpp	/^char *argv[];$/;"	v
argv	tools/c86/dos2out.cpp	/^char *argv[];$/;"	v
arule	commands/make.cpp	/^struct llist *arule;$/;"	v	typeref:struct:llist
as	commands/sh3.cpp	/^getn(as) char *as;$/;"	v
as	commands/sh4.cpp	/^register char *as;$/;"	v
ascii	commands/sort.cpp	/^    BOOL ascii;$/;"	m	struct:FIELD	file:
ask_repair	tools/fsck.cpp	/^    [[nodiscard]] bool ask_repair(std::string_view question) {$/;"	f	class:minix::fsck::ZoneLevel::UserInterface
ask_save	commands/mined1.cpp	/^ask_save() {$/;"	f
asm	tools/c86/_fsck.bat	/^:asm$/;"	l
assylen	commands/roff.cpp	/^int assylen;$/;"	v
assyline	commands/roff.cpp	/^char assyline[MAXLENGTH];$/;"	v
at	tools/diskio.hpp	/^    [[nodiscard]] const std::uint8_t &at(std::size_t offset) const {$/;"	f	class:SectorBuffer
at	tools/diskio.hpp	/^    [[nodiscard]] std::uint8_t &at(std::size_t offset) {$/;"	f	class:SectorBuffer
atarg	commands/make.cpp	/^add_rule2(adep, atarg, arule, aflag) char *adep, *atarg;$/;"	v
ato	commands/sh5.cpp	/^register char *ato, *from;$/;"	v
atoi	commands/mknod.cpp	/^static int atoi(const char *p) {$/;"	f	file:
author	docs/sphinx/conf.py	/^author = "The 2025 XINIM team with deep gratitude and thanks to Andrew Tanenbaum"$/;"	v
aword	include/sh.hpp	/^    char *aword;$/;"	m	struct:ioarg
awordlist	include/sh.hpp	/^    char **awordlist;$/;"	m	struct:ioarg
b	fs/buf.hpp	/^    } b; \/\/\/< Buffer data section.$/;"	m	struct:buf	typeref:union:buf::__anon2
b	lib/regexp.cpp	/^static void regc(b) char b;$/;"	v
b	test/test0.cpp	/^char b[4] = {0, 1, 2, 3}, c[4] = {10, 20, 30, 40}, d[4] = {6, 7, 8, 9};$/;"	v
b1	lib/times.cpp	/^    long b1, b2, b3, b4;$/;"	m	struct:tbuf	file:
b2	lib/times.cpp	/^    long b1, b2, b3, b4;$/;"	m	struct:tbuf	file:
b3	lib/times.cpp	/^    long b1, b2, b3, b4;$/;"	m	struct:tbuf	file:
b4	lib/times.cpp	/^    long b1, b2, b3, b4;$/;"	m	struct:tbuf	file:
b__data	fs/buf.hpp	/^        char b__data[BLOCK_SIZE];              \/\/\/< Raw block data.$/;"	m	union:buf::__anon2
b__dir	fs/buf.hpp	/^        dir_struct b__dir[NR_DIR_ENTRIES];     \/\/\/< Directory entries.$/;"	m	union:buf::__anon2
b__ind	fs/buf.hpp	/^        zone_nr b__ind[NR_INDIRECTS];          \/\/\/< Indirect block zones.$/;"	m	union:buf::__anon2
b__inode	fs/buf.hpp	/^        d_inode b__inode[INODES_PER_BLOCK];    \/\/\/< Inode table block.$/;"	m	union:buf::__anon2
b__int	fs/buf.hpp	/^        int b__int[INTS_PER_BLOCK];            \/\/\/< Integer array (e.g., bitmaps).$/;"	m	union:buf::__anon2
b_blocknr	fs/buf.hpp	/^    block_nr b_blocknr; \/\/\/< Block number within device.$/;"	m	struct:buf
b_count	fs/buf.hpp	/^    char b_count;       \/\/\/< Number of active users holding this buffer.$/;"	m	struct:buf
b_data	fs/buf.hpp	58;"	d
b_dev	fs/buf.hpp	/^    dev_nr b_dev;       \/\/\/< Device identifier (major | minor).$/;"	m	struct:buf
b_dir	fs/buf.hpp	59;"	d
b_dirt	fs/buf.hpp	/^    char b_dirt;        \/\/\/< DIRTY if modified; CLEAN otherwise.$/;"	m	struct:buf
b_hash	fs/buf.hpp	/^    buf* b_hash;    \/\/\/< Next in hash table chain.$/;"	m	struct:buf
b_ind	fs/buf.hpp	60;"	d
b_inode	fs/buf.hpp	61;"	d
b_int	fs/buf.hpp	62;"	d
b_line	commands/sh5.cpp	/^    char *b_line;$/;"	m	struct:block	file:
b_next	commands/sh5.cpp	/^    char *b_next;$/;"	m	struct:block	file:
b_next	fs/buf.hpp	/^    buf* b_next;    \/\/\/< Next buffer in LRU or hash chain.$/;"	m	struct:buf
b_prev	fs/buf.hpp	/^    buf* b_prev;    \/\/\/< Previous buffer in LRU chain.$/;"	m	struct:buf
b_size	commands/sh5.cpp	/^    int b_size;$/;"	m	struct:block	file:
b_start	commands/sh5.cpp	/^    char *b_start;$/;"	m	struct:block	file:
backup	commands/make.cpp	/^char *fword, *restline, line[INMAX], backup[INMAX];$/;"	v
bad	commands/date.cpp	/^static void bad(void) {$/;"	f	file:
bad	commands/dosread.cpp	/^bad() {$/;"	f
bad	commands/passwd.cpp	/^char bad[] = "Permission denied\\n";$/;"	v
badarg	commands/cal.cpp	/^char *badarg = {"Bad argument\\n"};$/;"	v
badcomm	commands/mknod.cpp	/^[[noreturn]] static void badcomm() {$/;"	f	file:
barrett_reduce	crypto/kyber_impl/reduce.c	/^int16_t barrett_reduce(int16_t a) {$/;"	f
barrett_reduce	crypto/kyber_impl/reduce.h	13;"	d
base	commands/sh4.cpp	/^glob1(base, lim) char *base, *lim;$/;"	v
base	kernel/idt64.cpp	/^    u64_t base;$/;"	m	struct:idt_ptr	file:
base	mm/alloc.cpp	/^    uint64_t base; \/\/\/< Start address of the hole in clicks.$/;"	m	struct:Hole	file:
basemul	crypto/kyber_impl/ntt.c	/^void basemul(int16_t r[2], const int16_t a[2], const int16_t b[2], int16_t zeta)$/;"	f
basemul	crypto/kyber_impl/ntt.h	16;"	d
basename	commands/ar.cpp	/^static char *basename(char *path) {$/;"	f	file:
basename	commands/cc.cpp	/^static void basename(char *str, char *dst) {$/;"	f	file:
basis_mul	kernel/fano_octonion.hpp	/^constexpr std::pair<int, int> basis_mul(int i, int j) {$/;"	f	namespace:lattice::__anon14
bc	commands/sh3.cpp	/^static void brkset(bc) struct brkcon *bc;$/;"	v	typeref:struct:brkcon
bcopy	lib/bcopy.cpp	/^void bcopy(char *src, char *dest, int n) {$/;"	f
beg_field	commands/sort.cpp	/^    int beg_field, beg_pos; \/* Begin field + offset *\/$/;"	m	struct:FIELD	file:
beg_fl	commands/sort.cpp	/^BOOL beg_fl;                                            \/* Assign beg or end of field *\/$/;"	v
beg_pos	commands/sort.cpp	/^    int beg_field, beg_pos; \/* Begin field + offset *\/$/;"	m	struct:FIELD	file:
begbss	lib/head.cpp	/^char begbss;$/;"	v
begbss	lib/minix/head.cpp	/^char begbss;$/;"	v
begdata	lib/head.cpp	/^char begdata;$/;"	v
begdata	lib/minix/head.cpp	/^char begdata;$/;"	v
begin	commands/c86/make.bat	/^:begin$/;"	l
begin	lib/c86/make.bat	/^:begin$/;"	l
beginpage	commands/roff.cpp	/^beginpage() {$/;"	f
begtext	lib/head.cpp	/^char begtext;$/;"	v
begtext	lib/minix/head.cpp	/^char begtext;$/;"	v
bench	tests/test_fastpath_cache_performance.cpp	/^static double bench(State &state, std::size_t iters) {$/;"	f	file:
bflag	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
bill_ptr	kernel/proc.hpp	/^EXTERN struct proc *bill_ptr;                        \/* ptr to process to bill for clock ticks *\/$/;"	v	typeref:struct:proc
bintoascii	lib/printk.cpp	/^static int bintoascii(long num, int radix, char a[MAXDIGITS]) {$/;"	f	file:
bit	commands/mkfs.cpp	/^insert_bit(block, bit, count) int block, bit, count;$/;"	v
bit	tools/mkfs.cpp	/^insert_bit(block, bit, count) int block, bit, count;$/;"	v
bit_blocks	fs/super.cpp	/^unshort bit_blocks;    \/* how many blocks are there in the bit map? *\/$/;"	v
bit_count	commands/df.cpp	/^static int bit_count(int blocks, int bits, int fd) {$/;"	f	file:
bit_count_	tools/fsck.cpp	/^    std::size_t bit_count_;$/;"	m	class:minix::fsck::ZoneLevel::Bitmap	file:
bit_nr	include/minix/fs/const.hpp	/^enum class bit_nr : std::uint32_t {};$/;"	c	namespace:minix::fs
bit_returned	fs/super.cpp	/^bit_nr bit_returned;   \/* number of bit to insert into the map *\/$/;"	v
bitmap_clear	pmm.cpp	/^static inline void bitmap_clear(size_t bit) {$/;"	f	file:
bitmap_set	pmm.cpp	/^static inline void bitmap_set(size_t bit) {$/;"	f	file:
bitmap_test	pmm.cpp	/^static inline bool bitmap_test(size_t bit) {$/;"	f	file:
bits_	include/minix/fs/inode.hpp	/^    mask_bits bits_;$/;"	m	class:minix::fs::InodeType::Permissions
blank	commands/sh4.cpp	/^static char *blank(f) {$/;"	f	file:
blank_line	commands/mined1.cpp	/^char blank_line[LINE_LEN];   \/* Line filled with spaces *\/$/;"	v
blankline	commands/roff.cpp	/^blankline() {$/;"	f
blankpage	commands/roff.cpp	/^blankpage() {$/;"	f
blanks	commands/sort.cpp	/^    BOOL blanks;$/;"	m	struct:FIELD	file:
block	commands/mkfs.cpp	/^insert_bit(block, bit, count) int block, bit, count;$/;"	v
block	commands/sh5.cpp	/^struct block {$/;"	s	file:
block	tools/mkfs.cpp	/^insert_bit(block, bit, count) int block, bit, count;$/;"	v
block_nr	include/minix/fs/const.hpp	/^enum class block_nr : std::uint32_t {};$/;"	c	namespace:minix::fs
block_on	kernel/schedule.cpp	/^bool Scheduler::block_on(xinim::pid_t src, xinim::pid_t dst) {$/;"	f	class:sched::Scheduler
block_size	commands/tar.cpp	73;"	d	file:
block_type_	include/minix/fs/buffer.hpp	/^    BlockType block_type_;$/;"	m	class:minix::fs::BufferGuard
blockbuf	commands/mkfs.cpp	/^    char blockbuf[BLOCK_SIZE];$/;"	m	struct:cache	file:
blockbuf	tools/mkfs.cpp	/^    char blockbuf[BLOCK_SIZE];$/;"	m	struct:cache	file:
blocknr	commands/mkfs.cpp	/^mx_read(blocknr, buf) int blocknr;$/;"	v
blocknr	commands/mkfs.cpp	/^mx_write(blocknr, buf) int blocknr;$/;"	v
blocknr	tools/mkfs.cpp	/^mx_read(blocknr, buf) int blocknr;$/;"	v
blocknr	tools/mkfs.cpp	/^mx_write(blocknr, buf) int blocknr;$/;"	v
blocknum	commands/mkfs.cpp	/^    int blocknum;$/;"	m	struct:cache	file:
blocknum	tools/mkfs.cpp	/^    int blocknum;$/;"	m	struct:cache	file:
bol	commands/libpack.cpp	/^int bol = 1;$/;"	v
bomb	commands/roff.cpp	/^bomb() {$/;"	f
boot_sector_data	tools/bootblok1.cpp	/^    static constexpr std::array<u8_t, SECTOR_SIZE> boot_sector_data = {$/;"	m	class:minix::bootloader::BootSector	file:
boot_time	kernel/clock.cpp	/^static int64_t boot_time;                 \/\/ real_time -> int64_t$/;"	v	file:
bootloader	tools/bootblok1.cpp	/^namespace minix::bootloader {$/;"	n	class:minix	file:
bot_line	commands/mined1.cpp	/^LINE *bot_line;           \/* Last line of screen *\/$/;"	v
bottom	lib/malloc.cpp	/^static char *bottom, *top;$/;"	v	file:
bp	commands/sh5.cpp	/^herein(bp, xdoll) struct block *bp;$/;"	v	typeref:struct:block
bp	commands/sh5.cpp	/^static savec(c, bp) register struct block *bp;$/;"	v	typeref:struct:block
breathe_default_project	docs/sphinx/conf.py	/^breathe_default_project = "XINIM"  # Activate this project by default$/;"	v
breathe_projects	docs/sphinx/conf.py	/^breathe_projects = {$/;"	v
brk	lib/brk.cpp	/^char *brk(char *addr) {$/;"	f
brk2	lib/brk2.cpp	/^void brk2() {$/;"	f
brkcon	include/sh.hpp	/^struct brkcon {$/;"	s
brklist	include/sh.hpp	/^} *brklist;$/;"	v	typeref:struct:brkcon
brkpt	include/sh.hpp	/^    jmp_buf brkpt;$/;"	m	struct:brkcon
brksize	lib/brksize.cpp	/^char *brksize = &endbss;$/;"	v
brksize	lib/head.cpp	/^char *brksize = &endbss;$/;"	v
brksize	lib/minix/head.cpp	/^char *brksize = &endbss;$/;"	v
bs	commands/dd.cpp	/^unsigned cbs, bs, skip, nseek, count;$/;"	v
buf	commands/cc.cpp	/^char buf[BUFSIZE];$/;"	v
buf	commands/comm.cpp	/^    char buf[BUFSIZ]; \/* buffer storage *\/$/;"	m	struct:file	file:
buf	commands/echo.cpp	/^char buf[SIZE];$/;"	v
buf	commands/mined1.cpp	/^build_string(buf, fmt, args) register char *buf, *fmt;$/;"	v
buf	commands/mkfs.cpp	/^char buf[BLOCK_SIZE];$/;"	v
buf	commands/od.cpp	/^char buf[512], buffer[BUFSIZ];$/;"	v
buf	commands/passwd.cpp	/^char buf[512];$/;"	v
buf	commands/rev.cpp	/^char buf[BLOCK_SIZE];$/;"	v
buf	commands/x.cpp	/^char buf[30000];$/;"	v
buf	fs/buf.hpp	/^EXTERN struct buf {$/;"	s
buf	fs/buf.hpp	/^} buf[NR_BUFS]; \/\/\/< Global buffer array.$/;"	v	typeref:struct:buf
buf	kernel/at_wini.cpp	/^PRIVATE unsigned char buf[BLOCK_SIZE]; \/* Buffer used by the startup routine *\/$/;"	v
buf	kernel/wini.cpp	/^PRIVATE unsigned char buf[BLOCK_SIZE]; \/* Buffer used by the startup routine *\/$/;"	v
buf	kernel/xt_wini.cpp	/^PRIVATE unsigned char buf[BLOCK_SIZE]; \/* Buffer used by the startup routine *\/$/;"	v
buf	lib/sprintf.cpp	/^char *buf, *format;$/;"	v
buf	test/test2.cpp	/^char buf[2048];$/;"	v
buf	test/test4.cpp	/^char buf[1024];$/;"	v
buf	test/test9.cpp	/^char buf[512];$/;"	v
buf	tools/init.cpp	/^char *buf;$/;"	v
buf	tools/mkfs.cpp	/^char buf[BLOCK_SIZE];$/;"	v
buf1	commands/uniq.cpp	/^char *nowline, *prevline, buf1[1024], buf2[1024];$/;"	v
buf2	commands/uniq.cpp	/^char *nowline, *prevline, buf1[1024], buf2[1024];$/;"	v
buf_count	mm/putc.cpp	/^PRIVATE int buf_count;            \/* # characters in the buffer *\/$/;"	v
buf_hash	fs/buf.hpp	/^EXTERN struct buf* buf_hash[NR_BUF_HASH];$/;"	v	typeref:struct:buf
buf_pool	fs/main.cpp	/^static void buf_pool() {$/;"	f	file:
buf_size	commands/sort.cpp	/^int buf_size;              \/* Size of core available for each struct *\/$/;"	v
bufcount	fs/putc.cpp	/^PRIVATE int bufcount;           \/* # characters in the buffer *\/$/;"	v
buff	commands/tail.cpp	/^char buff[BUFSIZ];$/;"	v
buff	fs/device.cpp	/^char *buff;  \/* virtual address of the buffer *\/$/;"	v
buffer	commands/ls.cpp	/^char buffer[BUFSIZ];$/;"	v
buffer	commands/mined1.cpp	/^char *buffer;$/;"	v
buffer	commands/mined1.cpp	/^register char *buffer;$/;"	v
buffer	commands/od.cpp	/^char buf[512], buffer[BUFSIZ];$/;"	v
buffer	commands/sort.cpp	/^    char *buffer;   \/* Buffer for reads *\/$/;"	m	struct:MERGE	file:
buffer	commands/tar.cpp	/^string_print(buffer, fmt, args) char *buffer;$/;"	v
buffer	commands/uniq.cpp	/^char buffer[BUFSIZ];$/;"	v
buffer	fs/param.hpp	4;"	d
buffer	lib/setbuf.cpp	/^char *buffer;$/;"	v
buffer_	include/minix/fs/buffer.hpp	/^    class Buffer *buffer_;$/;"	m	class:minix::fs::BufferHandle	typeref:class:minix::fs::BufferHandle::Buffer
buffer_	tools/build.cpp	/^    SectorBuffer buffer_;           \/\/\/< Internal sector buffer for sequential writes$/;"	m	class:minix::builder::ProgramType::ImageFile	file:
bufptr	commands/cc.cpp	/^char *bufptr = &buf[0];$/;"	v
bufs_in_use	fs/buf.hpp	/^EXTERN int bufs_in_use;$/;"	v
build	tools/build.cpp	/^    void build(const std::vector<std::string> &input_files) {$/;"	f	class:minix::builder::ProgramType::BootImageBuilder
builder	tools/build.cpp	/^namespace minix::builder {$/;"	n	class:minix	file:
builtin	commands/sh3.cpp	/^static struct builtin builtin[] = {$/;"	v	typeref:struct:builtin	file:
builtin	commands/sh3.cpp	/^struct builtin {$/;"	s	file:
bumpword	commands/roff.cpp	/^bumpword() {$/;"	f
busy_map	kernel/proc.hpp	/^EXTERN unsigned int busy_map;            \/* bit map of busy tasks *\/$/;"	v
bytes	commands/dosread.cpp	/^register unsigned bytes;$/;"	v
bytes	commands/dosread.cpp	/^short bytes;$/;"	v
bytes	commands/mined1.cpp	/^int bytes;$/;"	v
bytes	commands/mined2.cpp	/^register int bytes;$/;"	v
bytes	commands/mkfs.cpp	/^long bytes, cur_time;$/;"	v
bytes	commands/sort.cpp	/^register int bytes;$/;"	v
bytes	commands/tar.cpp	/^mread(fd, address, bytes) int fd, bytes;$/;"	v
bytes	commands/tar.cpp	/^mwrite(fd, address, bytes) int fd, bytes;$/;"	v
bytes	commands/tar.cpp	/^register long bytes;$/;"	v
bytes	fs/device.cpp	/^int bytes;   \/* how many bytes to transfer *\/$/;"	v
bytes	fs/pipe.cpp	/^int bytes;   \/* if hanging on task, how many bytes read *\/$/;"	v
bytes	fs/pipe.cpp	/^register int bytes;          \/* bytes to be read or written (all chunks) *\/$/;"	v
bytes	tools/mkfs.cpp	/^long bytes, cur_time;$/;"	v
bytespresent	commands/od.cpp	/^int bytespresent;$/;"	v
c	commands/dd.cpp	/^int c;$/;"	v
c	commands/mined1.cpp	/^_putchar(c) char c;$/;"	v
c	commands/mined1.cpp	/^char c;$/;"	v
c	commands/mined2.cpp	/^char c;$/;"	v
c	commands/od.cpp	/^char c;$/;"	v
c	commands/roff.cpp	/^char *p, c;$/;"	v
c	commands/roff.cpp	/^char *t, c;$/;"	v
c	commands/roff.cpp	/^int c; \/* LAST CHAR READ *\/$/;"	v
c	commands/roff.cpp	/^int c;$/;"	v
c	commands/roff.cpp	/^spit(c) char c;$/;"	v
c	commands/sh1.cpp	/^register int c;$/;"	v
c	commands/sh2.cpp	/^static void musthave(c, cf) int c, cf;$/;"	v
c	commands/sh3.cpp	/^char *c, **v, **envp;$/;"	v
c	commands/sh5.cpp	/^void ioecho(c) char c;$/;"	v
c	commands/sh5.cpp	/^void putc(c) char c;$/;"	v
c	fs/putc.cpp	/^char c;$/;"	v
c	kernel/tty.cpp	/^char c; \/* character to print *\/$/;"	v
c	lib/rindex.cpp	/^register char *s, c;$/;"	v
c	mm/putc.cpp	/^char c;$/;"	v
c	test/test0.cpp	/^char b[4] = {0, 1, 2, 3}, c[4] = {10, 20, 30, 40}, d[4] = {6, 7, 8, 9};$/;"	v
c	tools/r.cpp	/^static char c;$/;"	v	file:
c1	tools/c86/_fsck.bat	/^:c1$/;"	l
c_list	commands/sh2.cpp	/^static struct op *c_list() {$/;"	f	file:
cache	commands/mkfs.cpp	/^struct cache {$/;"	s	file:
cache	commands/mkfs.cpp	/^} cache[CACHE_SIZE];$/;"	v	typeref:struct:cache
cache	tools/mkfs.cpp	/^struct cache {$/;"	s	file:
cache	tools/mkfs.cpp	/^} cache[CACHE_SIZE];$/;"	v	typeref:struct:cache
cache_	tools/diskio.hpp	/^    mutable std::vector<CacheEntry> cache_;       \/\/\/< Sector cache$/;"	m	class:DiskInterface
cache_init	commands/mkfs.cpp	/^cache_init() { return; }$/;"	f
cache_init	commands/mkfs.cpp	/^cache_init() {$/;"	f
cache_init	tools/mkfs.cpp	/^cache_init() { return; }$/;"	f
cache_init	tools/mkfs.cpp	/^cache_init() {$/;"	f
cache_next_victim_	tools/diskio.cpp	/^      cache_next_victim_(other.cache_next_victim_) {$/;"	f	namespace:diskio
calendar	commands/cal.cpp	/^static void calendar(int year, int month, int index) \/* Which of the three months *\/$/;"	f	file:
call_nr	fs/pipe.cpp	/^int call_nr;               \/* READ or WRITE *\/$/;"	v
call_vec	mm/table.cpp	/^int (*call_vec[NCALLS])() = {$/;"	v
call_vector	fs/table.cpp	/^int (*call_vector[NCALLS])() = {$/;"	v
caller	kernel/printer.cpp	/^static int caller;             \/* process to tell when printing done (FS) *\/$/;"	v	file:
caller_	kernel/memory.cpp	/^    int caller_;$/;"	m	class:MessageReply	file:
canintr	commands/sh3.cpp	/^int canintr;$/;"	v
cant	commands/mv.cpp	/^static void cant(const char *name) {$/;"	f	file:
cantopen	commands/cmp.cpp	/^static void cantopen(char *s) {$/;"	f	file:
cap	kernel/wormhole.hpp	/^    Capability cap;      \/\/ capability used by sender$/;"	m	struct:fastpath::State
capslock	kernel/tty.cpp	/^PRIVATE int shift1, shift2, capslock, numlock;    \/* keep track of shift keys *\/$/;"	v
caselist	commands/sh2.cpp	/^static struct op *caselist() {$/;"	f	file:
casepart	commands/sh2.cpp	/^static struct op *casepart() {$/;"	f	file:
cast	commands/mined1.cpp	1138;"	d	file:
cat	commands/shar.cpp	/^static void cat(int fd) {$/;"	f	file:
cbc	commands/dd.cpp	/^int cbc;$/;"	v
cbd2	crypto/kyber_impl/cbd.c	/^static void cbd2(poly *r, const uint8_t buf[2*KYBER_N\/4])$/;"	f	file:
cbd3	crypto/kyber_impl/cbd.c	/^static void cbd3(poly *r, const uint8_t buf[3*KYBER_N\/4])$/;"	f	file:
cbs	commands/dd.cpp	/^unsigned cbs, bs, skip, nseek, count;$/;"	v
cbuf	commands/tail.cpp	/^char cbuf[BUF_SIZE];$/;"	v
cc	commands/make.cpp	/^char cc;$/;"	v
cc	fs/c86/make.bat	/^:cc$/;"	l
cc	kernel/make.bat	/^:cc$/;"	l
cc	mm/c86/make.bat	/^:cc$/;"	l
cc	tools/c86/_build.bat	/^:cc$/;"	l
ccount	commands/wc.cpp	/^long ccount; \/* Count of characters *\/$/;"	v
cd_flag	fs/param.hpp	5;"	d
cd_mul	kernel/sedenion.hpp	/^constexpr std::array<float, N> cd_mul(const std::array<float, N> &a,$/;"	f	namespace:hyper::detail
center	commands/roff.cpp	/^int center = 0;$/;"	v
cf	commands/sh1.cpp	/^int cf;$/;"	v
cf	commands/sh2.cpp	/^int cf;$/;"	v
cf	commands/sh2.cpp	/^static void musthave(c, cf) int c, cf;$/;"	v
cflag	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
cflag	commands/uniq.cpp	/^int cflag = 0;$/;"	v
cflag	commands/wc.cpp	/^int cflag; \/* Count characters *\/$/;"	v
ch	lib/putc.cpp	/^char ch;$/;"	v
ch	lib/ungetc.cpp	/^int ch;$/;"	v
changed	commands/mined1.cpp	/^FLAG writefl, changed;$/;"	v
character	commands/mined2.cpp	/^register char character;$/;"	v
chars	commands/tail.cpp	/^int lines, chars;$/;"	v
chars	commands/uniq.cpp	/^int chars = 0;$/;"	v
chars_saved	commands/mined1.cpp	/^long chars_saved; \/* Nr of chars in buffer *\/$/;"	v
chdir	lib/chdir.cpp	/^int chdir(const char *name) { return callm3(FS, CHDIR, 0, const_cast<char *>(name)); }$/;"	f
check	commands/sort.cpp	/^BOOL check = FALSE;$/;"	v
check_consistency	tools/fsck.cpp	/^    void check_consistency(UserInterface &ui) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
check_directory_recursive	tools/fsck.cpp	/^    void check_directory_recursive(inode_nr dir_ino, inode_nr parent_ino, PathTracker path) {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
check_filesystem	tools/fsck.cpp	/^    [[nodiscard]] bool check_filesystem() {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker
check_sign	commands/sort.cpp	/^BOOL check_sign; \/* True if sign must be checked *\/$/;"	v
checkmark	commands/mined2.cpp	/^FLAG checkmark() {$/;"	f
checksum	commands/tar.cpp	/^checksum() {$/;"	f
child	commands/mkfs.cpp	/^enter_dir(parent, name, child) int parent, child; \/* inode nums *\/$/;"	v
child	fs/param.hpp	6;"	d
child	mm/forkexit.cpp	/^register struct mproc *child; \/* tells which process is exiting *\/$/;"	v	typeref:struct:mproc
child	tools/mkfs.cpp	/^enter_dir(parent, name, child) int parent, child; \/* inode nums *\/$/;"	v
child_once	tests/test_net_driver_reconnect.cpp	/^int child_once() {$/;"	f	namespace:__anon12
child_proc	tests/test_lattice_ipv6.cpp	/^static int child_proc() {$/;"	f	file:
child_proc	tests/test_lattice_network.cpp	/^static int child_proc() {$/;"	f	file:
child_proc	tests/test_lattice_network_encrypted.cpp	/^static int child_proc() {$/;"	f	file:
child_proc	tests/test_net_driver.cpp	/^int child_proc() {$/;"	f
child_proc	tests/test_net_driver_drop_newest.cpp	/^int child_proc() {$/;"	f	namespace:__anon13
child_proc	tests/test_net_driver_overflow.cpp	/^int child_proc() {$/;"	f	namespace:__anon6
child_proc	tests/test_net_driver_tcp.cpp	/^int child_proc() {$/;"	f	namespace:__anon9
child_proc	tests/test_net_two_node.cpp	/^static int child_proc() {$/;"	f	file:
child_proc	tests/test_poll_network.cpp	/^static int child_proc() {$/;"	f	file:
child_second	tests/test_net_driver_reconnect.cpp	/^int child_second() {$/;"	f	namespace:__anon12
child_stime	kernel/proc.hpp	/^    real_time child_stime; \/* cumulative sys time of children (real_time -> xinim::time_t) *\/$/;"	m	struct:proc
child_utime	kernel/proc.hpp	/^    real_time child_utime; \/* cumulative user time of children (real_time -> xinim::time_t) *\/$/;"	m	struct:proc
childpid	test/test1.cpp	/^parent1(childpid) int childpid;$/;"	v
childpid	test/test5.cpp	/^parent(childpid) int childpid;$/;"	v
childs	commands/time.cpp	/^    long childu, childs;$/;"	m	struct:time_buf	file:
childsigs	test/test5.cpp	/^int childsigs, parsigs, alarms;$/;"	v
childu	commands/time.cpp	/^    long childu, childs;$/;"	m	struct:time_buf	file:
chksum	tools/c86/dos2out.cpp	/^	unsigned int	chksum;		\/* neg. sum of all words in file *\/$/;"	m	struct:d_fmt_hdr	file:
chmod	lib/chmod.cpp	/^int chmod(const char *name, int mode) { return callm3(FS, CHMOD, mode, const_cast<char *>(name)); }$/;"	f
chown	lib/chown.cpp	/^int chown(const char *name, int owner, int grp) {$/;"	f
chroot	lib/chroot.cpp	/^int chroot(const char *name) { return callm3(FS, CHROOT, 0, const_cast<char *>(name)); }$/;"	f
cindex	commands/cc.cpp	/^char *static char *cindex(char *s, char c) {$/;"	f	file:
cl	commands/sh4.cpp	/^static struct wdblock *cl, *nl;$/;"	v	typeref:struct:wdblock	file:
cl_1	commands/dosread.cpp	/^link_fat(cl_1, cl_2) unsigned short cl_1;$/;"	v
cl_2	commands/dosread.cpp	/^register unsigned short cl_2;$/;"	v
cl_no	commands/dosread.cpp	/^register unsigned short cl_no;$/;"	v
classify_file	tools/classify_style.py	/^def classify_file(path: str) -> str:$/;"	f
cleanup	commands/cc.cpp	87;"	d	file:
clear	tools/diskio.hpp	/^    void clear() { data_.clear(); }$/;"	f	class:SectorBuffer
clear	tools/fsck.cpp	/^    void clear() {$/;"	f	class:minix::fsck::ZoneLevel::Inode
clear_bit	tools/fsck.cpp	/^    void clear_bit(BitNumber bit) {$/;"	f	class:minix::fsck::ZoneLevel::Bitmap
clear_buffer	commands/mined.hpp	173;"	d
clear_buffer	include/mined.hpp	166;"	d
clear_header	commands/tar.cpp	/^clear_header() {$/;"	f
clear_line	commands/mined1.cpp	/^FLAG clear_line;                               \/* Clear to eoln if TRUE *\/$/;"	v
clear_status	commands/mined.hpp	229;"	d
clear_status	include/mined.hpp	222;"	d
clear_zone	fs/write.cpp	/^PUBLIC void clear_zone(struct inode *rip, int32_t pos, int flag) {$/;"	f
clearfl	commands/mined1.cpp	/^FLAG clearfl;$/;"	v
clock_mess	fs/time.cpp	/^PRIVATE message clock_mess;$/;"	v
clock_time	fs/utility.cpp	/^[[nodiscard]] real_time clock_time() {$/;"	f
close	include/minix/io/stream.hpp	/^    virtual std::error_code close() { return {}; }$/;"	f	class:minix::io::Stream
close	lib/close.cpp	/^int close(int fd) { return callm1(FS, CLOSE, fd, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
close	lib/io/src/file_stream.cpp	/^std::error_code FileStream::close() {$/;"	f	class:minix::io::FileStream
closeall	commands/sh5.cpp	/^void closeall() {$/;"	f
clraa	test/test0.cpp	/^static void clraa(void) {$/;"	f	file:
clus_add	commands/dosread.cpp	32;"	d	file:
cluster	commands/dosread.cpp	/^register unsigned short cluster;$/;"	v
cluster_size	commands/dosread.cpp	/^short total_clusters, cluster_size, fat_size, root_entries, data_start, sub_entries;$/;"	v
cmd	commands/make.cpp	/^exec_how(cmd) char *cmd;$/;"	v
cmov	crypto/kyber_impl/verify.c	/^void cmov(uint8_t *r, const uint8_t *x, size_t len, uint8_t b)$/;"	f
cmov	crypto/kyber_impl/verify.h	11;"	d
cmov_int16	crypto/kyber_impl/verify.c	/^void cmov_int16(int16_t *r, int16_t v, uint16_t b)$/;"	f
cmov_int16	crypto/kyber_impl/verify.h	14;"	d
cmp	commands/cmp.cpp	/^static int cmp(int fd1, int fd2) {$/;"	f	file:
cmp_string	fs/utility.cpp	/^[[nodiscard]] int cmp_string(const char *rsp1, const char *rsp2, int n) {$/;"	f
cname	commands/make.cpp	/^perform(cname, syscmd) char *cname; \/* the name of the command *\/$/;"	v
cnt	commands/sort.cpp	/^    int cnt;        \/* Nr of chars taken out of buffer *\/$/;"	m	struct:MERGE	file:
cnull	commands/dd.cpp	/^static void cnull(int c) {$/;"	f	file:
co_mode	fs/param.hpp	7;"	d
code	lib/c86/prologue.hpp	/^prologue.h;	standard prologue for c86 assembly code$/;"	v
coeffs	crypto/kyber_impl/poly.h	/^  int16_t coeffs[KYBER_N];$/;"	m	struct:__anon22
colbuf	commands/pr.cpp	/^char *colbuf;$/;"	v
colflgs	commands/comm.cpp	/^int colflgs[3] = {1, 2, 3}; \/* number of tabs + 1: 0 => no column *\/$/;"	v
collect	commands/echo.cpp	/^static void collect(char *s) {$/;"	f	file:
color	kernel/tty.cpp	/^PUBLIC int color;                                 \/* 1 if console is color, 0 if it is mono *\/$/;"	v
column	commands/lpr.cpp	/^int cur_in, in_count, out_count, column;$/;"	v
columns	commands/pr.cpp	/^short columns;$/;"	v
comm	commands/comm.cpp	/^static void comm(void) {$/;"	f	file:
command	commands/sh3.cpp	/^    char *command;$/;"	m	struct:builtin	file:
command	kernel/wini.cpp	/^PRIVATE int command[6]; \/* Common command block *\/$/;"	v
command	kernel/xt_wini.cpp	/^PRIVATE int command[6]; \/* Common command block *\/$/;"	v
comp	kernel/octonion.hpp	/^    std::array<std::uint32_t, 8> comp; \/\/\/< Scalar and imaginary parts$/;"	m	struct:lattice::Octonion
compat	include/minix/io/stdio_compat.hpp	/^namespace minix::io::compat {$/;"	n	class:minix::io
compat	lib/io/src/stdio_compat.cpp	/^namespace minix::io::compat {$/;"	n	class:minix::io	file:
compat_get_size	fs/compat.cpp	/^PUBLIC file_pos64 compat_get_size(const struct inode *ip) {$/;"	f
compat_set_size	fs/compat.cpp	/^PUBLIC void compat_set_size(struct inode *ip, file_pos64 sz) {$/;"	f
complement	commands/tr.cpp	/^static void complement(unsigned char *buffer) {$/;"	f	file:
compute_expected	tests/test_net_driver_id.cpp	/^[[nodiscard]] net::node_t compute_expected() {$/;"	f	namespace:__anon10
compute_shared_secret	crypto/pqcrypto_shared.cpp	/^[[nodiscard]] std::array<std::uint8_t, pqcrystals_kyber512_BYTES> compute_shared_secret($/;"	f	namespace:pqcrypto
concat	commands/cc.cpp	/^static void concat(struct arglist *al1, struct arglist *al2) {$/;"	f	file:
confirm	commands/rm.cpp	/^static int confirm(void) {$/;"	f	file:
connect	kernel/lattice_ipc.cpp	/^Channel &Graph::connect(xinim::pid_t src, xinim::pid_t dst, net::node_t node_id) {$/;"	f	class:lattice::Graph
console_clear	console.cpp	/^void console_clear(uint8_t background, uint8_t foreground) {$/;"	f
console_get_cursor	console.cpp	/^void console_get_cursor(int* x, int* y) {$/;"	f
console_init	console.cpp	/^void console_init(uint8_t background, uint8_t foreground) {$/;"	f
console_putc_at	console.cpp	/^void console_putc_at(char c, uint8_t color, int x, int y) {$/;"	f
console_set_cursor	console.cpp	/^void console_set_cursor(int x, int y) {$/;"	f
console_set_cursor_hw	console.cpp	/^void console_set_cursor_hw(int x, int y) {$/;"	f
console_set_vga_buffer_address	console.cpp	/^void console_set_vga_buffer_address(volatile unsigned short* new_address) {$/;"	f
console_write_char	console.cpp	/^void console_write_char(char c, uint8_t color) {$/;"	f
console_write_dec	console.cpp	/^void console_write_dec(unsigned int n, uint8_t color) {$/;"	f
console_write_hex	console.cpp	/^void console_write_hex(unsigned int n, uint8_t color) {$/;"	f
console_write_string	console.cpp	/^void console_write_string(const char* str, uint8_t color) {$/;"	f
contract	kernel/service.cpp	/^const ServiceManager::LivenessContract &ServiceManager::contract(xinim::pid_t pid) const {$/;"	f	class:svc::ServiceManager
control	kernel/tty.cpp	/^PRIVATE int control, alt;                         \/* keep track of key statii *\/$/;"	v
conv	commands/date.cpp	/^static int conv(char **ptr, int max) {$/;"	f	file:
convert	commands/tr.cpp	/^static void convert() {$/;"	f	file:
convflag	commands/dd.cpp	/^int convflag = 0;$/;"	v
copy	commands/lpr.cpp	/^static void copy(int fd) {$/;"	f	file:
copy	fs/utility.cpp	/^inline void copy(void *dest, const void *source, int bytes) {$/;"	f
copy_bootblock	tools/build.cpp	/^    void copy_bootblock(const std::string &bootblock_path) {$/;"	f	class:minix::builder::ProgramType::BootImageBuilder	file:
copy_info	h/type.hpp	/^struct copy_info { \/* used by sys_copy(src, dst, bytes) *\/$/;"	s
copy_member	commands/ar.cpp	/^static void copy_member(MEMBER *member, int from, int to) {$/;"	f	file:
copy_mess	mm/utility.cpp	/^PRIVATE message copy_mess;$/;"	v
copy_program	tools/build.cpp	/^    void copy_program(ProgramType type, const std::string &program_path) {$/;"	f	class:minix::builder::ProgramType::BootImageBuilder	file:
copyfile	commands/cat.cpp	/^static void copyfile(int fd1, int fd2) {$/;"	f	file:
copyfile	commands/cp.cpp	/^static void copyfile(int fd1, int fd2) {$/;"	f	file:
copyio	commands/sh2.cpp	/^static struct ioword **copyio() {$/;"	f	file:
copyline	commands/roff.cpp	/^int copyline() {$/;"	f
copyw	commands/sh2.cpp	/^static char **copyw() {$/;"	f	file:
core_bits	mm/table.cpp	/^uint16_t core_bits = 0x0EFC;  \/* which signals cause core images (unshort -> uint16_t) *\/$/;"	v
core_name	mm/table.cpp	/^char core_name[] = {"core"}; \/* file name where core images are produced *\/$/;"	v
count	commands/dd.cpp	/^unsigned cbs, bs, skip, nseek, count;$/;"	v
count	commands/echo.cpp	/^int count;$/;"	v
count	commands/ls.cpp	/^int count;$/;"	v
count	commands/mined1.cpp	/^register int count;$/;"	v
count	commands/mined1.cpp	/^register long count; \/* Contains number of characters in file *\/$/;"	v
count	commands/mkfs.cpp	/^insert_bit(block, bit, count) int block, bit, count;$/;"	v
count	commands/mkfs.cpp	/^int count;$/;"	v
count	commands/mkfs.cpp	/^long count;$/;"	v
count	commands/wc.cpp	/^static void count() {$/;"	f	file:
count	fs/pipe.cpp	/^int count;                 \/* max number of processes to release *\/$/;"	v
count	tools/mkfs.cpp	/^insert_bit(block, bit, count) int block, bit, count;$/;"	v
count	tools/mkfs.cpp	/^int count;$/;"	v
count	tools/mkfs.cpp	/^long count;$/;"	v
cp	commands/sh1.cpp	/^register char *cp;$/;"	v
cp	commands/sh1.cpp	/^void freecell(cp) char *cp;$/;"	v
cp	commands/sh1.cpp	/^void setarea(cp, a) char *cp;$/;"	v
cp	commands/sh2.cpp	/^    char *cp;$/;"	m	union:__anon26	file:
cp	commands/sh2.cpp	/^char *cp;$/;"	v
cp	commands/sh2.cpp	/^static void word(cp) char *cp;$/;"	v
cp	commands/sh3.cpp	/^register char *cp;$/;"	v
cp	commands/sh4.cpp	/^char *cp;$/;"	v
cp	commands/sh4.cpp	/^register char *cp;$/;"	v
cp_bytes	h/type.hpp	/^    vir_bytes cp_bytes;$/;"	m	struct:copy_info
cp_dst_proc	h/type.hpp	/^    int cp_dst_proc;$/;"	m	struct:copy_info
cp_dst_space	h/type.hpp	/^    int cp_dst_space;$/;"	m	struct:copy_info
cp_dst_vir	h/type.hpp	/^    vir_bytes cp_dst_vir;$/;"	m	struct:copy_info
cp_src_proc	h/type.hpp	/^    int cp_src_proc;$/;"	m	struct:copy_info
cp_src_space	h/type.hpp	/^    int cp_src_space;$/;"	m	struct:copy_info
cp_src_vir	h/type.hpp	/^    vir_bytes cp_src_vir;$/;"	m	struct:copy_info
cp_to_dir	commands/cp.cpp	/^static void cp_to_dir(int argc, char *argv[]) {$/;"	f	file:
cprompt	include/sh.hpp	/^struct var *cprompt; \/* continuation prompt *\/$/;"	v	typeref:struct:var
cpycol	commands/comm.cpp	/^static void cpycol(int col) {$/;"	f	file:
cr3	kernel/proc.hpp	/^    xinim::phys_addr_t cr3;   \/* page table base - Formerly u64_t *\/$/;"	m	struct:proc
crash	kernel/schedule.cpp	/^void Scheduler::crash(xinim::pid_t pid) {$/;"	f	class:sched::Scheduler
creat	lib/creat.cpp	/^int creat(const char *name, int mode) { return callm3(FS, CREAT, mode, const_cast<char *>(name)); }$/;"	f
creat_fl	commands/tar.cpp	/^BOOL show_fl, creat_fl, ext_fl;$/;"	v
create	include/minix/io/file_operations.hpp	/^    create = 1 << 2,$/;"	m	class:minix::io::OpenMode
create_directories	tools/bootblok1.cpp	/^inline bool create_directories(const std::string &path) {$/;"	f	namespace:fs
create_stream	lib/io/src/file_operations.cpp	/^Result<StreamPtr> create_stream(std::string_view path, Permissions perms) {$/;"	f	namespace:minix::io
crypt	lib/crypt.cpp	/^char *crypt(char *pw, char *salt) {$/;"	f
crypto_aead_chacha20poly1305_ietf_ABYTES	tests/sodium.h	32;"	d
crypto_aead_chacha20poly1305_ietf_decrypt	tests/sodium_stub.cpp	/^int crypto_aead_chacha20poly1305_ietf_decrypt(unsigned char *m, unsigned long long *mlen,$/;"	f
crypto_aead_chacha20poly1305_ietf_encrypt	tests/sodium_stub.cpp	/^int crypto_aead_chacha20poly1305_ietf_encrypt(unsigned char *c, unsigned long long *clen,$/;"	f
crypto_aead_xchacha20poly1305_ietf_ABYTES	tests/sodium.h	33;"	d
crypto_aead_xchacha20poly1305_ietf_KEYBYTES	tests/sodium.h	34;"	d
crypto_aead_xchacha20poly1305_ietf_NPUBBYTES	tests/sodium.h	35;"	d
crypto_aead_xchacha20poly1305_ietf_decrypt	tests/sodium_stub.cpp	/^int crypto_aead_xchacha20poly1305_ietf_decrypt(unsigned char *m, unsigned long long *mlen,$/;"	f
crypto_aead_xchacha20poly1305_ietf_encrypt	tests/sodium_stub.cpp	/^int crypto_aead_xchacha20poly1305_ietf_encrypt(unsigned char *c, unsigned long long *clen,$/;"	f
crypto_kem_dec	crypto/kyber_impl/kem.c	/^int crypto_kem_dec(uint8_t *ss,$/;"	f
crypto_kem_dec	crypto/kyber_impl/kem.h	32;"	d
crypto_kem_enc	crypto/kyber_impl/kem.c	/^int crypto_kem_enc(uint8_t *ct,$/;"	f
crypto_kem_enc	crypto/kyber_impl/kem.h	29;"	d
crypto_kem_enc_derand	crypto/kyber_impl/kem.c	/^int crypto_kem_enc_derand(uint8_t *ct,$/;"	f
crypto_kem_enc_derand	crypto/kyber_impl/kem.h	26;"	d
crypto_kem_keypair	crypto/kyber_impl/kem.c	/^int crypto_kem_keypair(uint8_t *pk,$/;"	f
crypto_kem_keypair	crypto/kyber_impl/kem.h	23;"	d
crypto_kem_keypair_derand	crypto/kyber_impl/kem.c	/^int crypto_kem_keypair_derand(uint8_t *pk,$/;"	f
crypto_kem_keypair_derand	crypto/kyber_impl/kem.h	20;"	d
cs_seg	tools/c86/dos2out.cpp	/^	unsigned int	cs_seg;		\/* offset of code-seg in load-module *\/$/;"	m	struct:d_fmt_hdr	file:
csv	lib/csv.cpp	/^void csv() {}$/;"	f
ctotal	commands/wc.cpp	/^long ctotal; \/* Total count of characters *\/$/;"	v
ctype_	lib/ctype.cpp	/^char ctype_[] = {0,$/;"	v
cum_count	kernel/printer.cpp	/^PUBLIC int cum_count;      \/* cumulative # characters printed *\/$/;"	v
cumbuf	commands/roff.cpp	/^char cumbuf[BUFSIZ];$/;"	v
cumsig	test/test3.cpp	/^int sigct, cumsig, errct;$/;"	v
cur_in	commands/lpr.cpp	/^int cur_in, in_count, out_count, column;$/;"	v
cur_line	commands/mined1.cpp	/^LINE *cur_line;           \/* Current line in use *\/$/;"	v
cur_pos	commands/sort.cpp	/^char *cur_pos;       \/* First free position in mem *\/$/;"	v
cur_proc	kernel/glo.hpp	/^EXTERN xinim::pid_t cur_proc;  \/* current process - Formerly int *\/$/;"	v
cur_text	commands/mined1.cpp	/^char *cur_text;           \/* Current char on current line in use *\/$/;"	v
cur_time	commands/mkfs.cpp	/^long bytes, cur_time;$/;"	v
cur_time	tools/mkfs.cpp	/^long bytes, cur_time;$/;"	v
current_	tools/fsck.cpp	/^    std::shared_ptr<PathNode> current_;$/;"	m	class:minix::fsck::ZoneLevel::PathTracker	file:
current_color	console.cpp	/^uint8_t current_color = DEFAULT_COLOR;$/;"	v
current_cpu	kernel/glo.hpp	/^EXTERN int current_cpu;$/;"	v
current_time	commands/mkfs.cpp	/^long current_time;$/;"	v
current_time	tools/mkfs.cpp	/^long current_time;$/;"	v
cursor_x	console.cpp	/^int cursor_x = 0;$/;"	v
cursor_y	console.cpp	/^int cursor_y = 0;$/;"	v
curtime	commands/ls.cpp	/^long curtime;$/;"	v
cut_line	commands/split.cpp	/^int cut_line = 1000;$/;"	v
cv_time	commands/date.cpp	/^static void cv_time(long t) {$/;"	f	file:
cwidth	commands/pr.cpp	/^short cwidth;$/;"	v
d	commands/make.cpp	/^struct llist *d, *h;    \/* pointers to depends, howto *\/$/;"	v	typeref:struct:llist
d	kernel/floppy.cpp	/^PRIVATE int d;            \/* diskette\/drive combination *\/$/;"	v
d	kernel/klib64.cpp	/^    int *d = dst_off;$/;"	v
d	test/test0.cpp	/^char b[4] = {0, 1, 2, 3}, c[4] = {10, 20, 30, 40}, d[4] = {6, 7, 8, 9};$/;"	v
d	tools/c86/_fsck.bat	/^:d$/;"	l
d_attribute	commands/dosread.cpp	/^    unsigned char d_attribute;$/;"	m	struct:dir_entry	file:
d_cluster	commands/dosread.cpp	/^    unsigned short d_cluster;$/;"	m	struct:dir_entry	file:
d_date	commands/dosread.cpp	/^    unsigned short d_date;$/;"	m	struct:dir_entry	file:
d_ext	commands/dosread.cpp	/^    unsigned char d_ext[3];$/;"	m	struct:dir_entry	file:
d_fmt_hdr	tools/c86/dos2out.cpp	/^struct d_fmt_hdr {$/;"	s	file:
d_ino	commands/pwd.cpp	/^    unsigned short d_ino;$/;"	m	struct:direct	file:
d_ino	commands/rm.cpp	/^    unsigned short d_ino;$/;"	m	struct:direct	file:
d_ino	commands/rmdir.cpp	/^    unsigned short d_ino;$/;"	m	struct:direct	file:
d_ino	commands/sh4.cpp	/^    unsigned short d_ino;$/;"	m	struct:direct	file:
d_ino	commands/tar.cpp	/^    unsigned short d_ino;$/;"	m	struct:direct	file:
d_inode	fs/type.hpp	/^struct d_inode {                  \/* disk inode.  Memory inode is in "inotab.h" *\/$/;"	s
d_inode	tools/fsck.cpp	/^struct d_inode {$/;"	s	class:minix::fsck::ZoneLevel	file:
d_inum	fs/type.hpp	/^    inode_nr d_inum;        \/* inode number *\/$/;"	m	struct:dir_struct
d_inum	tools/fsck.cpp	/^    inode_nr d_inum;$/;"	m	struct:minix::fsck::ZoneLevel::dir_struct	file:
d_name	commands/dosread.cpp	/^    unsigned char d_name[8];$/;"	m	struct:dir_entry	file:
d_name	commands/pwd.cpp	/^    char d_name[14];$/;"	m	struct:direct	file:
d_name	commands/rm.cpp	/^    char d_name[14];$/;"	m	struct:direct	file:
d_name	commands/rmdir.cpp	/^    char d_name[14];$/;"	m	struct:direct	file:
d_name	commands/sh4.cpp	/^    char d_name[DIRSIZ];$/;"	m	struct:direct	file:
d_name	commands/tar.cpp	/^    char d_name[14];$/;"	m	struct:direct	file:
d_name	fs/type.hpp	/^    char d_name[NAME_SIZE]; \/* character string *\/$/;"	m	struct:dir_struct
d_name	tools/fsck.cpp	/^    std::array<char, 14> d_name;$/;"	m	struct:minix::fsck::ZoneLevel::dir_struct	file:
d_ptr	tools/c86/dos2out.cpp	/^struct d_fmt_hdr *d_ptr= inbuf;$/;"	v	typeref:struct:d_fmt_hdr
d_reloctab	tools/c86/dos2out.cpp	/^struct d_reloctab {		\/* DOS relocation table entry *\/$/;"	s	file:
d_reserved	commands/dosread.cpp	/^    unsigned char d_reserved[10];$/;"	m	struct:dir_entry	file:
d_size	commands/dosread.cpp	/^    unsigned long d_size;$/;"	m	struct:dir_entry	file:
d_time	commands/dosread.cpp	/^    unsigned short d_time;$/;"	m	struct:dir_entry	file:
data	include/minix/io/memory_stream.hpp	/^    const std::vector<std::byte> &data() const { return buffer_; }$/;"	f	class:minix::io::MemoryStream
data	tools/diskio.hpp	/^        SectorBuffer data;$/;"	m	struct:DiskInterface::CacheEntry
data_	tools/diskio.hpp	/^    std::vector<std::uint8_t> data_;$/;"	m	class:SectorBuffer
data_	tools/fsck.cpp	/^    std::vector<std::uint32_t> data_;$/;"	m	class:minix::fsck::ZoneLevel::Bitmap	file:
data_org	lib/head.cpp	/^long data_org[] = {0xDADA, 0, 0, 0, 0, 0, 0, 0};$/;"	v
data_start	commands/dosread.cpp	/^short total_clusters, cluster_size, fat_size, root_entries, data_start, sub_entries;$/;"	v
date	commands/ar.cpp	/^static void date(long t) {$/;"	f	file:
date	commands/cal.cpp	/^int static int date(int year, int month, int week, int wday) \/* Calendar date being computed *\/$/;"	f	file:
date	commands/ls.cpp	/^static void date(long t) {$/;"	f	file:
day	commands/date.cpp	/^    int year, month, day, hour, min, sec;$/;"	m	struct:__anon25	file:
day_month	commands/cal.cpp	/^static int day_month[] = {\/* 30 days hath September...		*\/$/;"	v	file:
days	commands/date.cpp	/^std::array<std::string_view, 7> days = {"Thu", "Fri", "Sat", "Sun", "Mon", "Tue", "Wed"};$/;"	v
days_in_month	commands/cal.cpp	/^    int days_in_month; \/* Number of days in this month		*\/$/;"	m	struct:__anon29	file:
days_per_month	commands/date.cpp	/^std::array<int, 12> days_per_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};$/;"	v
decrypt	crypto/kyber.cpp	/^decrypt(std::span<const std::byte> ciphertext,$/;"	f	namespace:pq::kyber
def_flag	commands/make.cpp	/^    int def_flag;$/;"	m	struct:rulerec	file:
def_list	commands/make.cpp	/^char *def_list[] = {$/;"	v
def_ready	commands/make.cpp	/^int sending, def_ready, gdone, rule_send, rule_ready;$/;"	v
defargv	commands/sum.cpp	/^char *defargv[] = {"-", nullptr};$/;"	v
defmac	commands/roff.cpp	/^defmac() {$/;"	f
defnlist	commands/make.cpp	/^struct defnrec *defnlist = NULL;$/;"	v	typeref:struct:defnrec
defnp	commands/make.cpp	/^struct defnrec *defnp;$/;"	v	typeref:struct:defnrec
defnrec	commands/make.cpp	/^struct defnrec {$/;"	s	file:
del_fl	commands/ar.cpp	/^BOOL del_fl;$/;"	v
dep	commands/make.cpp	/^    char *dep, *targ; \/* order is important because there are defaults *\/$/;"	m	struct:rulerec	file:
dependson	commands/make.cpp	/^    struct llist *dependson;$/;"	m	struct:defnrec	typeref:struct:defnrec::llist	file:
deprec3	commands/make.cpp	/^struct llist *fdeps, *deprec3;$/;"	v	typeref:struct:
deps	kernel/service.hpp	/^        std::vector<xinim::pid_t> deps; \/\/\/< Services this one depends on$/;"	m	struct:svc::ServiceManager::ServiceInfo
depth	commands/roff.cpp	/^int depth;$/;"	v
derrtab	commands/mkfs.cpp	/^char *derrtab[14] = {"no error",$/;"	v
derrtab	tools/mkfs.cpp	/^char *derrtab[14] = {"no error",$/;"	v
dest	commands/dosread.cpp	/^bcopy(src, dest, bytes) register char *src, *dest;$/;"	v
dest	commands/make.cpp	/^char *src, *dest;$/;"	v
dest	commands/make.cpp	/^get_element(src, p, dest) char *src, *dest;$/;"	v
dest	commands/sort.cpp	/^build_field(dest, field, src) char *dest; \/* Holds result *\/$/;"	v
dest	commands/sort.cpp	/^copy(dest, src) register char *dest, *src;$/;"	v
detail	kernel/sedenion.hpp	/^namespace detail {$/;"	n	namespace:hyper
detail	kernel/wormhole.cpp	/^namespace detail {$/;"	n	namespace:fastpath	file:
detail	kernel/wormhole.hpp	/^namespace detail {$/;"	n	namespace:fastpath
dev	fs/device.cpp	/^dev_nr dev;  \/* major-minor device number *\/$/;"	v
dev	fs/device.cpp	/^dev_nr dev; \/* device *\/$/;"	v
dev	fs/device.cpp	/^dev_nr dev; \/* which device to close *\/$/;"	v
dev	fs/device.cpp	/^dev_nr dev; \/* which device to open *\/$/;"	v
dev	fs/super.cpp	/^dev_nr dev; \/* device number whose super_block is sought *\/$/;"	v
dev	fs/super.cpp	/^dev_nr dev; \/* which device is being unmounted? *\/$/;"	v
dev	fs/super.cpp	/^dev_nr dev; \/* which device? *\/$/;"	v
dev_mess	fs/device.cpp	/^PRIVATE message dev_mess;$/;"	v
dev_nr	include/minix/fs/const.hpp	/^enum class dev_nr : std::uint16_t {};$/;"	c	namespace:minix::fs
device	commands/dosread.cpp	/^char null[MAX_CLUSTER_SIZE], device[] = DRIVE, path[128];$/;"	v
device_path_	tools/diskio.hpp	/^    std::string device_path_;         \/\/\/< Path to disk device$/;"	m	class:DiskInterface
device_path_	tools/diskio.hpp	/^    std::string device_path_;$/;"	m	class:DiskIoError
device_path_	tools/fsck.cpp	/^    std::string device_path_;$/;"	m	class:minix::fsck::ZoneLevel::FsckApplication	file:
df	commands/df.cpp	/^static void df(char *name) {$/;"	f	file:
dflag	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
dflag	commands/uniq.cpp	/^int dflag = 1; \/* flags are mutually exclusive *\/$/;"	v
dictionary	commands/sort.cpp	/^    BOOL dictionary;$/;"	m	struct:FIELD	file:
diff	test/t11a.cpp	/^static bool diff(const char *s1, const char *s2) {$/;"	f	file:
diff	test/t11b.cpp	/^static bool diff(const char *s1, const char *s2) {$/;"	f	file:
diff	test/t16a.cpp	/^static bool diff(const char *s1, const char *s2) {$/;"	f	file:
diff	test/t16b.cpp	/^static bool diff(const char *s1, const char *s2) {$/;"	f	file:
digit_seen	commands/time.cpp	/^int digit_seen;$/;"	v
dir	commands/ls.cpp	/^struct dir {$/;"	s	file:
dir	commands/ls.cpp	/^} dir[INODES_PER_BLOCK * NDIRBLOCKS];$/;"	v	typeref:struct:dir
dir_entry	commands/dosread.cpp	/^struct dir_entry {$/;"	s	file:
dir_name	commands/tar.cpp	/^mkdir(dir_name) char *dir_name;$/;"	v
dir_ptr	commands/dosread.cpp	/^show(dir_ptr, name) DIRECTORY *dir_ptr;$/;"	v
dir_struct	fs/type.hpp	/^struct dir_struct {         \/* directory entry *\/$/;"	s
dir_struct	tools/fsck.cpp	/^struct dir_struct {$/;"	s	class:minix::fsck::ZoneLevel	file:
direct	commands/pwd.cpp	/^struct direct {$/;"	s	file:
direct	commands/rm.cpp	/^struct direct {$/;"	s	file:
direct	commands/rmdir.cpp	/^struct direct {$/;"	s	file:
direct	commands/sh4.cpp	/^struct direct {$/;"	s	file:
direct	commands/tar.cpp	/^struct direct {$/;"	s	file:
direct_handoff	kernel/schedule.cpp	/^void Scheduler::direct_handoff(xinim::pid_t receiver) {$/;"	f	class:sched::Scheduler
directory	commands/dosread.cpp	/^static DIRECTORY *directory(DIRECTORY *dir, short entries, BOOL function, char *pathname) {$/;"	f	file:
dirname	commands/ls.cpp	/^    char dirname[DIRNAMELEN];$/;"	m	struct:dir	file:
dirs	include/paging.hpp	/^    struct page_directory *dirs[PT_ENTRIES];$/;"	m	struct:page_dir_ptr	typeref:struct:page_dir_ptr::page_directory
dirty	commands/mkfs.cpp	/^    int dirty;$/;"	m	struct:cache	file:
dirty	tools/mkfs.cpp	/^    int dirty;$/;"	m	struct:cache	file:
disabled	commands/sort.cpp	/^int disabled;        \/* Nr of files done *\/$/;"	v
disk	commands/dosread.cpp	/^short disk;$/;"	v
disk	commands/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
disk	tools/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
disk_	tools/fsck.cpp	/^    diskio::DiskInterface &disk_;$/;"	m	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
disk_int	kernel/mpx64.cpp	/^void disk_int(void) {$/;"	f
disk_read	commands/dosread.cpp	71;"	d	file:
disk_write	commands/dosread.cpp	72;"	d	file:
diskio	tools/diskio.cpp	/^namespace diskio {$/;"	n	file:
diskio	tools/diskio.hpp	/^namespace diskio {$/;"	n
divide	kernel/mpx64.cpp	/^void divide(void) {$/;"	f
dmap	fs/dev.hpp	/^EXTERN struct dmap {$/;"	s
dmap	fs/dev.hpp	/^} dmap[];$/;"	v	typeref:struct:dmap
dmap	fs/table.cpp	/^struct dmap dmap[] = {$/;"	v	typeref:struct:dmap
dmap_close	fs/dev.hpp	/^    int (*dmap_close)();$/;"	m	struct:dmap
dmap_open	fs/dev.hpp	/^    int (*dmap_open)();$/;"	m	struct:dmap
dmap_rw	fs/dev.hpp	/^    int (*dmap_rw)();$/;"	m	struct:dmap
dmap_task	fs/dev.hpp	/^    int dmap_task;$/;"	m	struct:dmap
do3months	commands/cal.cpp	15;"	d	file:
do_access	fs/protect.cpp	/^PUBLIC std::expected<void, std::error_code> do_access() {$/;"	f
do_brk	mm/break.cpp	/^PUBLIC int do_brk() {$/;"	f
do_chdir	fs/stadir.cpp	/^PUBLIC int do_chdir() {$/;"	f
do_chmod	fs/protect.cpp	/^PUBLIC std::expected<void, std::error_code> do_chmod() {$/;"	f
do_chown	fs/protect.cpp	/^PUBLIC std::expected<void, std::error_code> do_chown() {$/;"	f
do_chroot	fs/stadir.cpp	/^PUBLIC int do_chroot() {$/;"	f
do_close	fs/open.cpp	/^int do_close() {$/;"	f
do_creat	fs/open.cpp	/^int do_creat() {$/;"	f
do_dup	fs/misc.cpp	/^int do_dup() {$/;"	f
do_exec	mm/exec.cpp	/^PUBLIC int do_exec() {$/;"	f
do_exit	fs/misc.cpp	/^int do_exit() {$/;"	f
do_file	commands/head.cpp	/^static void do_file(int n) {$/;"	f	file:
do_fork	fs/misc.cpp	/^int do_fork() {$/;"	f
do_fork	mm/forkexit.cpp	/^PUBLIC int do_fork() {$/;"	f
do_fstat	fs/stadir.cpp	/^PUBLIC int do_fstat() {$/;"	f
do_ioctl	fs/device.cpp	/^PUBLIC do_ioctl() {$/;"	f
do_line	commands/head.cpp	/^static void do_line() {$/;"	f	file:
do_link	fs/link.cpp	/^PUBLIC int do_link() {$/;"	f
do_lseek	fs/open.cpp	/^int do_lseek() {$/;"	f
do_mknod	fs/open.cpp	/^int do_mknod() {$/;"	f
do_mm_exit	mm/forkexit.cpp	/^PUBLIC int do_mm_exit() {$/;"	f
do_mount	fs/mount.cpp	/^int do_mount() {$/;"	f
do_newmap	kernel/system.cpp	/^PRIVATE int do_newmap(message *m_ptr) \/* pointer to request message *\/$/;"	f
do_nx	commands/roff.cpp	/^do_nx() {$/;"	f
do_open	fs/open.cpp	/^int do_open() {$/;"	f
do_pipe	fs/pipe.cpp	/^PUBLIC int do_pipe() {$/;"	f
do_read	fs/read.cpp	/^PUBLIC int do_read() { return (read_write(READING)); }$/;"	f
do_revive	fs/misc.cpp	/^int do_revive() {$/;"	f
do_set	fs/misc.cpp	/^int do_set() {$/;"	f
do_stat	fs/stadir.cpp	/^PUBLIC int do_stat() {$/;"	f
do_stime	fs/time.cpp	/^PUBLIC int do_stime() {$/;"	f
do_sync	fs/misc.cpp	/^int do_sync() {$/;"	f
do_ta	commands/roff.cpp	/^do_ta() {$/;"	f
do_time	fs/time.cpp	/^PUBLIC int do_time()$/;"	f
do_tims	fs/time.cpp	/^PUBLIC int do_tims() {$/;"	f
do_tr	commands/roff.cpp	/^do_tr() {$/;"	f
do_umask	fs/protect.cpp	/^PUBLIC std::expected<uint16_t, std::error_code> do_umask() {$/;"	f
do_umount	fs/mount.cpp	/^int do_umount() {$/;"	f
do_unlink	fs/link.cpp	/^PUBLIC int do_unlink() {$/;"	f
do_unpause	fs/pipe.cpp	/^PUBLIC int do_unpause() {$/;"	f
do_utime	fs/time.cpp	/^PUBLIC int do_utime() {$/;"	f
do_wait	mm/forkexit.cpp	/^PUBLIC int do_wait() {$/;"	f
do_write	fs/write.cpp	/^PUBLIC int do_write() {$/;"	f
doit	commands/touch.cpp	/^static int doit(const char *name) {$/;"	f	file:
dolabel	commands/sh3.cpp	/^dolabel() { return (0); }$/;"	f
dolc	include/sh.hpp	/^int dolc;$/;"	v
dolev	test/test9.cpp	/^dolev() {$/;"	f
dolist	commands/make.cpp	/^struct llist *dolist = NULL;$/;"	v	typeref:struct:llist
dolv	include/sh.hpp	/^char **dolv;$/;"	v
domonth	commands/cal.cpp	/^static void domonth(int year, int month)$/;"	f	file:
done	commands/dd.cpp	/^static void done(int n) {$/;"	f	file:
done	commands/grep.cpp	/^static void done(int n) {$/;"	f	file:
done	commands/gres.cpp	/^static void done(int n) {$/;"	f	file:
done	commands/make.cpp	/^static void done(int n) {$/;"	f	file:
done	commands/tail.cpp	/^[[noreturn]] static void done(int n) {$/;"	f	file:
dont_reply	fs/glo.hpp	/^EXTERN int dont_reply;             \/* normally 0; set to 1 to inhibit reply *\/$/;"	v
dos_dir	commands/dosread.cpp	/^BOOL Rflag, Lflag, Aflag, dos_read, dos_write, dos_dir;$/;"	v
dos_read	commands/dosread.cpp	/^BOOL Rflag, Lflag, Aflag, dos_read, dos_write, dos_dir;$/;"	v
dos_write	commands/dosread.cpp	/^BOOL Rflag, Lflag, Aflag, dos_read, dos_write, dos_dir;$/;"	v
dosub	commands/gres.cpp	/^static void dosub(regexp *exp, char ibuf[], char *repstr) {$/;"	f	file:
dothis	commands/make.cpp	/^char dothis[INMAX]; \/* generic temporary storage *\/$/;"	v
dow_first	commands/cal.cpp	/^    int dow_first;     \/* Day of week of the 1st day in month	*\/$/;"	m	struct:__anon29	file:
doyear	commands/cal.cpp	/^static void doyear(int year)$/;"	f	file:
dsb	tools/fsck.cpp	/^struct dsb {$/;"	s	file:
dst	kernel/lattice_ipc.hpp	/^    xinim::pid_t dst; \/\/!< Destination process identifier$/;"	m	struct:lattice::Channel
dst_click	kernel/klib64.cpp	/^    (void)dst_click;$/;"	v
dummy	fs/device.cpp	/^int dummy;         \/* not used - for compatibility with rw_dev() *\/$/;"	v
dummy_line	commands/mined2.cpp	/^dummy_line() {$/;"	f
dumpfile	commands/od.cpp	/^dumpfile() {$/;"	f
dup	lib/dup.cpp	/^int dup(int fd) { return callm1(FS, DUP, fd, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
dup2	lib/dup2.cpp	/^int dup2(int fd, int fd2) { return callm1(FS, DUP, fd + 0100, fd2, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
dup_inode	fs/inode.cpp	/^PUBLIC void dup_inode(struct inode *ip) { \/\/ Added void return$/;"	f
e	commands/sh1.cpp	/^struct env e = {line, iostack, iostack - 1, NULL, FDBASE, NULL};$/;"	v	typeref:struct:env
e	test/t11a.cpp	/^static void e(int n) { std::printf("Error %d\\n", n); }$/;"	f	file:
e	test/t11b.cpp	/^static void e(int n) { std::printf("Error %d\\n", n); }$/;"	f	file:
e	test/t16a.cpp	/^static void e(int n) { std::printf("Error %d\\n", n); }$/;"	f	file:
e	test/t16b.cpp	/^static void e(int n) { std::printf("Error %d\\n", n); }$/;"	f	file:
e	test/test0.cpp	/^static void e(int n) {$/;"	f	file:
e	test/test9.cpp	/^e(n) {$/;"	f
e_count	fs/extent.hpp	/^    zone_nr e_count; \/* number of zones in the extent *\/$/;"	m	struct:extent
e_start	fs/extent.hpp	/^    zone_nr e_start; \/* first zone in the extent *\/$/;"	m	struct:extent
eat_path	fs/path.cpp	/^struct inode *eat_path(char *path) {$/;"	f
ec	commands/sh2.cpp	/^static void diag(ec) register int ec;$/;"	v
ec	commands/sh4.cpp	/^register char ec;$/;"	v
ec	commands/sh5.cpp	/^register int ec;$/;"	v
edges_	kernel/lattice_ipc.hpp	/^        edges_;                                        \/\/!< channel storage keyed by (src,dst,node)$/;"	m	class:lattice::Graph
eff_grp_id	fs/param.hpp	8;"	d
eff_user_id	fs/param.hpp	9;"	d
eflag	commands/make.cpp	/^int eflag;$/;"	v
efoot	commands/roff.cpp	/^char ehead[100], efoot[100], ohead[100], ofoot[100];$/;"	v
ehead	commands/roff.cpp	/^char ehead[100], efoot[100], ohead[100], ofoot[100];$/;"	v
ei	commands/sort.cpp	/^incr(si, ei) register int si, ei;$/;"	v
eind	commands/c86/make.bat	/^:eind$/;"	l
eind	lib/c86/make.bat	/^:eind$/;"	l
eind	tools/c86/_fsck.bat	/^:eind$/;"	l
einde	tools/c86/_build.bat	/^:einde$/;"	l
el1	commands/sort.cpp	/^cmp(el1, el2, field) register char *el1, *el2;$/;"	v
el1	commands/sort.cpp	/^cmp_fields(el1, el2) register char *el1, *el2;$/;"	v
el1	commands/sort.cpp	/^compare(el1, el2) register char *el1, *el2;$/;"	v
el2	commands/sort.cpp	/^cmp(el1, el2, field) register char *el1, *el2;$/;"	v
el2	commands/sort.cpp	/^cmp_fields(el1, el2) register char *el1, *el2;$/;"	v
el2	commands/sort.cpp	/^compare(el1, el2) register char *el1, *el2;$/;"	v
elinep	commands/sh1.cpp	/^char *elinep = line + sizeof(line) - 5;$/;"	v
elinep	include/sh.hpp	/^char *elinep;$/;"	v
elsepart	commands/sh2.cpp	/^static struct op *elsepart() {$/;"	f	file:
encrypt	crypto/kyber.cpp	/^encrypt(std::span<const std::byte> message,$/;"	f	namespace:pq::kyber
encrypt_sedenion	kernel/sedenion.hpp	/^inline void encrypt_sedenion(std::span<const std::uint8_t> in, std::span<std::uint8_t> out,$/;"	f	namespace:hyper
end	commands/sh4.cpp	/^char *middle, *end;$/;"	v
end	include/vm.hpp	/^    virt_addr64 end;   \/\/\/< Exclusive end address.$/;"	m	struct:VmFlags::vm_area
end1	commands/sh4.cpp	/^register char *end1;$/;"	v
end_field	commands/sort.cpp	/^    int end_field, end_pos; \/* End field + offset. ERROR == EOLN *\/$/;"	m	struct:FIELD	file:
end_line	commands/mined2.cpp	/^LINE *end_line;$/;"	v
end_line	commands/mined2.cpp	/^yank(start_line, start_textp, end_line, end_textp, remove) LINE *start_line, *end_line;$/;"	v
end_pos	commands/sort.cpp	/^    int end_field, end_pos; \/* End field + offset. ERROR == EOLN *\/$/;"	m	struct:FIELD	file:
end_position	commands/mined2.cpp	/^register char *end_position;$/;"	v
end_ptr	commands/mined.hpp	/^    char *end_ptr;$/;"	m	struct:ReturnCode::regex
end_ptr	include/mined.hpp	/^    char *end_ptr;$/;"	m	struct:ReturnCode::regex
end_textp	commands/mined2.cpp	/^char *start_textp, *end_textp;$/;"	v
endbss	lib/end.cpp	/^char endbss;$/;"	v
endbss	lib/minix/end.cpp	/^char endbss;$/;"	v
enddata	lib/end.cpp	/^char enddata;$/;"	v
enddata	lib/minix/end.cpp	/^char enddata;$/;"	v
endgrent	lib/getgrent.cpp	/^void endgrent() {$/;"	f
endmac	commands/roff.cpp	/^endmac() {$/;"	f
endp	commands/comm.cpp	/^    char *endp;       \/* the first invalid character *\/$/;"	m	struct:file	file:
endp	include/regexp.hpp	/^    char *endp[NSUBEXP];   \/\/\/< Pointers to end of matches.$/;"	m	struct:regexp
endpage	commands/roff.cpp	/^endpage() {$/;"	f
endpoint	kernel/wormhole.hpp	/^    Endpoint endpoint;   \/\/ communication endpoint$/;"	m	struct:fastpath::State
endpwent	lib/getpwent.cpp	/^void endpwent(void) {$/;"	f
endtext	lib/end.cpp	/^char endtext;$/;"	v
endtext	lib/minix/end.cpp	/^char endtext;$/;"	v
enqueue	kernel/schedule.hpp	/^    void enqueue(xinim::pid_t pid) { ready_.push_back(pid); }$/;"	f	class:sched::Scheduler
enqueue_packet	kernel/net_driver.cpp	/^static void enqueue_packet(Packet &&pkt) {$/;"	f	namespace:net::__anon16
ensure_connection	commands/svcctl.cpp	/^static void ensure_connection() {$/;"	f	namespace:svcctl
enter_directory	tools/fsck.cpp	/^    void enter_directory(std::string_view name, inode_nr inode) {$/;"	f	class:minix::fsck::ZoneLevel::PathTracker
enter_string	commands/mined1.cpp	/^char *enter_string = "\\033 8\\033~0"; \/* String printed on entering mined *\/$/;"	v
entries	include/paging.hpp	/^    struct pt_entry entries[PT_ENTRIES];$/;"	m	struct:page_table	typeref:struct:page_table::pt_entry
entries_	tools/fsck.cpp	/^    std::vector<Entry> entries_;$/;"	m	class:minix::fsck::ZoneLevel::DirectoryEntry	file:
entry_size	multiboot.h	/^    uint32_t entry_size;$/;"	m	struct:multiboot_tag_mmap
entry_version	multiboot.h	/^    uint32_t entry_version;$/;"	m	struct:multiboot_tag_mmap
entsize	multiboot.h	/^    uint32_t entsize;$/;"	m	struct:multiboot_tag_elf_sections
env	include/sh.hpp	/^extern struct env {$/;"	s
env	test/test9.cpp	/^jmp_buf env;$/;"	v
environ	commands/sh1.cpp	/^char **environ; \/* environment pointer *\/$/;"	v
environ	lib/getenv.cpp	/^extern "C" char **environ;$/;"	v
envp	commands/sh3.cpp	/^char *c, **v, **envp;$/;"	v
envp	test/test11.cpp	/^char *envp[3] = {"spring", "summer", 0};$/;"	v
eopen	commands/comm.cpp	/^static int eopen(char *fn, struct file *file) {$/;"	f	file:
equal	commands/ar.cpp	/^inline bool equal(const char *str1, const char *str2) {$/;"	f
equal	commands/cp.cpp	/^static int equal(char *s1, char *s2) {$/;"	f	file:
erki	fs/param.hpp	10;"	d
err	commands/mkfs.cpp	/^dexit(s, sectnum, err) int sectnum, err;$/;"	v
err	lib/c86/make.bat	/^:err$/;"	l
err	tools/mkfs.cpp	/^dexit(s, sectnum, err) int sectnum, err;$/;"	v
err_code	fs/glo.hpp	/^EXTERN int err_code; \/* temporary storage for error number *\/$/;"	v
err_fl	commands/dosread.cpp	/^print_string(err_fl, fmt, args) BOOL err_fl;$/;"	v
err_mess	commands/mined.hpp	/^        char *err_mess;$/;"	m	union:ReturnCode::regex::__anon27
err_mess	include/mined.hpp	/^        char *err_mess;$/;"	m	union:ReturnCode::regex::__anon19
errct	test/test0.cpp	/^int errct;$/;"	v
errct	test/test1.cpp	/^int errct;$/;"	v
errct	test/test10.cpp	/^int errct;$/;"	v
errct	test/test11.cpp	/^int errct;$/;"	v
errct	test/test3.cpp	/^int sigct, cumsig, errct;$/;"	v
errct	test/test5.cpp	/^int errct;$/;"	v
errct	test/test6.cpp	/^int errct;$/;"	v
errct	test/test7.cpp	/^int errct;$/;"	v
errno	lib/call.cpp	/^int errno = 0; \/\/ accessed by system call wrappers$/;"	v
error	commands/ar.cpp	/^static void error(BOOL quit, char *str1, char *str2) {$/;"	f	file:
error	commands/comm.cpp	/^static void error(char *s, char *f) {$/;"	f	file:
error	commands/mined.hpp	227;"	d
error	commands/mkdir.cpp	/^int error = 0;$/;"	v
error	commands/mv.cpp	/^int error = 0;$/;"	v
error	commands/rmdir.cpp	/^int error = 0;$/;"	v
error	commands/size.cpp	/^int error;$/;"	v
error	commands/sum.cpp	/^static void error(const char *s, const char *f) {$/;"	f	file:
error	include/mined.hpp	220;"	d
error_message	lib/perror.cpp	/^const char *error_message[NERROR + 1] = {"Error 0",$/;"	v
errorp	commands/dd.cpp	/^char *pch, *errorp;$/;"	v
errors	commands/rm.cpp	/^int errors = 0;$/;"	v
errpt	include/sh.hpp	/^    jmp_buf *errpt; \/* saved error jump buffer *\/$/;"	m	struct:env
errpt	include/sh.hpp	/^jmp_buf *errpt;  \/* current error handler *\/$/;"	v
es	kernel/printer.cpp	/^static int es;     \/* (es, offset) point to next character to - segment part from phys addr *\/$/;"	v	file:
even	commands/ar.cpp	/^[[nodiscard]] constexpr int even(int nr) { return odd(nr) ? nr + 1 : nr; }$/;"	f
ever	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
ex	commands/make.cpp	/^get_ext(n, ex) char *ex, *n;$/;"	v
ex	test/test5.cpp	/^ex() {$/;"	f
ex_fl	commands/ar.cpp	/^BOOL ex_fl;$/;"	v
ex_vec	commands/cc.cpp	/^static void ex_vec(struct arglist *vec) {$/;"	f	file:
exclusive	include/minix/io/file_operations.hpp	/^    exclusive = 1 << 3,$/;"	m	class:minix::io::OpenMode
exec_len	mm/param.hpp	10;"	d
exec_name	mm/param.hpp	9;"	d
execflg	include/sh.hpp	/^int execflg;$/;"	v
execl	lib/exec.cpp	/^int execl(const char *name, char *arg0) { return execve(name, &arg0, null_argv); }$/;"	f
execle	lib/exec.cpp	/^int execle(const char *name, char *argv) {$/;"	f
execn	lib/exec.cpp	/^int execn(const char *name) {$/;"	f
execute	commands/make.cpp	/^int execute = TRUE;$/;"	v
execute	commands/time.cpp	/^static void execute() {$/;"	f	file:
execv	lib/exec.cpp	/^int execv(const char *name, char *argv[]) { return execve(name, argv, null_argv); }$/;"	f
execve	lib/exec.cpp	/^int execve(const char *name, char *argv[], char *envp[]) {$/;"	f
exists	commands/make.cpp	/^static int exists(char *name, char *suffix) {$/;"	f	file:
exit	lib/exit.cpp	/^int exit(int status) { return callm1(MM, EXIT, status, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
exit_directory	tools/fsck.cpp	/^    void exit_directory() {$/;"	f	class:minix::fsck::ZoneLevel::PathTracker
exit_status	mm/forkexit.cpp	/^int exit_status;            \/* the process' exit status (for parent) *\/$/;"	v
exp_buffer	commands/mined2.cpp	/^int exp_buffer[BLOCK_SIZE];$/;"	v
exp_dir	commands/ls.cpp	/^static void exp_dir(struct file *fp) {$/;"	f	file:
expan	commands/make.cpp	/^add_macro(mname, expan) char *mname, *expan;$/;"	v
expand	commands/make.cpp	/^static void expand(char *src, char *dest, char *target, int flag) \/* expand any macros found*\/$/;"	f	file:
expand	commands/tr.cpp	/^static void expand(char *arg, unsigned char *buffer) {$/;"	f	file:
expand_args	commands/ls.cpp	/^static void expand_args(int argc, char *argv[]) {$/;"	f	file:
expected	include/minix/fs/buffer.hpp	/^        -> std::expected<BufferHandle, BufferError>;$/;"	m	class:minix::fs::BufferPool::std
expected	include/minix/fs/inode.hpp	/^        -> std::expected<InodeHandle, InodeError>;$/;"	m	class:minix::fs::InodeType::InodeTable::std
expected	include/minix/fs/inode.hpp	/^        -> std::expected<void, InodeError>;$/;"	m	class:minix::fs::InodeType::Inode::std
expected	include/minix/fs/inode.hpp	/^    -> std::expected<InodeHandle, InodeError>;$/;"	m	class:minix::fs::InodeType::std
expected	include/minix/fs/inode.hpp	/^    auto allocate_extent_table(std::size_t initial_capacity) -> std::expected<void, InodeError>;$/;"	m	class:minix::fs::InodeType::Inode::std
expression	commands/mined.hpp	/^        int *expression;$/;"	m	union:ReturnCode::regex::__anon27
expression	commands/mined2.cpp	/^int *expression;$/;"	v
expression	include/mined.hpp	/^        int *expression;$/;"	m	union:ReturnCode::regex::__anon19
exstat	include/sh.hpp	/^int exstat;$/;"	v
exstatus	commands/rm.cpp	/^int exstatus;$/;"	v
ext_env	commands/make.cpp	/^char **ext_env;$/;"	v
ext_fl	commands/tar.cpp	/^BOOL show_fl, creat_fl, ext_fl;$/;"	v
extension	commands/cc.cpp	/^int static int extension(char *fn) {$/;"	f	file:
extensions	docs/sphinx/conf.py	/^extensions = [$/;"	v
extent	fs/extent.hpp	/^struct extent {$/;"	s
extents_	include/minix/fs/inode.hpp	/^    std::unique_ptr<ExtentTable> extents_;$/;"	m	class:minix::fs::InodeType::Inode
extern	boot.S	/^extern kmain$/;"	l
extra	commands/dd.cpp	/^static void extra(void) {$/;"	f	file:
extract	commands/ar.cpp	/^static void extract(MEMBER *member) {$/;"	f	file:
extract	commands/dosread.cpp	/^static void extract(DIRECTORY *entry) {$/;"	f	file:
extract	tools/bootblok1.cpp	/^    static void extract(const std::string &output_path = "bootblok",$/;"	f	class:minix::bootloader::BootSectorExtractor
f	commands/make.cpp	/^struct m_preq *f;$/;"	v	typeref:struct:m_preq
f	commands/mkfs.cpp	/^eat_file(inode, f) int inode, f;$/;"	v
f	commands/mkfs.cpp	/^int f;$/;"	v
f	commands/roff.cpp	/^mesg(f) int f;$/;"	v
f	commands/sh1.cpp	/^void putvlist(f, out) register int f, out;$/;"	v
f	commands/sh3.cpp	/^int (*f)();$/;"	v
f	commands/sh3.cpp	/^void (*f)();$/;"	v
f	commands/sh4.cpp	/^int f;$/;"	v
f	lib/stb.cpp	/^	    register char *f, *t; register int n;$/;"	v
f	tools/mkfs.cpp	/^eat_file(inode, f) int inode, f;$/;"	v
f	tools/mkfs.cpp	/^int f;$/;"	v
f1	commands/make.cpp	/^char *f1, *f2, *f3;$/;"	v
f2	commands/make.cpp	/^char *f1, *f2, *f3;$/;"	v
f3	commands/make.cpp	/^char *f1, *f2, *f3;$/;"	v
f_gid	commands/ls.cpp	/^    unsigned short f_gid;$/;"	m	struct:file	file:
f_uid	commands/ls.cpp	/^    unsigned short f_uid;$/;"	m	struct:file	file:
fail	commands/sh1.cpp	/^void fail() {$/;"	f
failpt	include/sh.hpp	/^jmp_buf *failpt; \/* last failure point *\/$/;"	v
fastpath	kernel/wormhole.cpp	/^namespace fastpath {$/;"	n	file:
fastpath	kernel/wormhole.hpp	/^namespace fastpath {$/;"	n
fat	commands/dosread.cpp	/^unsigned char fat[MAX_FAT_SIZE];$/;"	v
fat_size	commands/dosread.cpp	/^short total_clusters, cluster_size, fat_size, root_entries, data_start, sub_entries;$/;"	v
fault	kernel/wormhole.hpp	/^    std::optional<int> fault;                   \/\/ fault number, if any$/;"	m	struct:fastpath::ThreadTemplate
fclose	lib/fclose.cpp	/^int fclose(FILE *fp) {$/;"	f
fclose_compat	lib/io/src/stdio_compat.cpp	/^int fclose_compat(FILE *fp) {$/;"	f
fd	commands/comm.cpp	/^    int fd;           \/* the file descripter *\/$/;"	m	struct:file	file:
fd	commands/mined1.cpp	/^bad_write(fd) int fd;$/;"	v
fd	commands/mined1.cpp	/^flush_buffer(fd) int fd;$/;"	v
fd	commands/mined1.cpp	/^get_line(fd, buffer) int fd;$/;"	v
fd	commands/mined1.cpp	/^write_char(fd, c) int fd;$/;"	v
fd	commands/mined1.cpp	/^writeline(fd, text) register int fd;$/;"	v
fd	commands/mined2.cpp	/^file_insert(fd, old_pos) int fd;$/;"	v
fd	commands/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
fd	commands/rev.cpp	/^int fd; \/* File descriptor from file currently being read *\/$/;"	v
fd	commands/sh5.cpp	/^register int fd;$/;"	v
fd	commands/sort.cpp	/^    int fd;         \/* Fd of file *\/$/;"	m	struct:MERGE	file:
fd	commands/sort.cpp	/^check_file(fd, file) int fd;$/;"	v
fd	commands/sort.cpp	/^get_file(fd, size) int fd; \/* Fd of file to read *\/$/;"	v
fd	commands/sort.cpp	/^mread(fd, address, bytes) int fd;$/;"	v
fd	commands/sort.cpp	/^mwrite(fd, address, bytes) int fd;$/;"	v
fd	commands/sort.cpp	/^print_table(fd) int fd;$/;"	v
fd	commands/tar.cpp	/^mread(fd, address, bytes) int fd, bytes;$/;"	v
fd	commands/tar.cpp	/^mwrite(fd, address, bytes) int fd, bytes;$/;"	v
fd	commands/tee.cpp	/^int fd[MAXFD];$/;"	v
fd	fs/param.hpp	11;"	d
fd	lib/isatty.cpp	/^int fd;$/;"	v
fd	test/test4.cpp	/^int i, fd;$/;"	v
fd	tools/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
fd2	fs/param.hpp	12;"	d
fdeps	commands/make.cpp	/^struct llist *fdeps, *deprec3;$/;"	v	typeref:struct:llist
feb	commands/cal.cpp	/^    int feb;           \/* Days in February for this month	*\/$/;"	m	struct:__anon29	file:
feof	include/stdio.hpp	63;"	d
ferror	include/stdio.hpp	64;"	d
fetch_name	fs/utility.cpp	/^[[nodiscard]] int fetch_name(const char *path, int len, int flag) {$/;"	f
fflag	commands/rm.cpp	/^int fflag = 0;$/;"	v
fflush	lib/fflush.cpp	/^int fflush(FILE *stream) { return __fflush(stream); }$/;"	f
fgetc	include/stdio.hpp	61;"	d
fgets	lib/fgets.cpp	/^char *fgets(char *str, unsigned n, FILE *file) {$/;"	f
fhowto	commands/make.cpp	/^struct llist *fhowto, *howp3;$/;"	v	typeref:struct:llist
field	commands/sort.cpp	/^FIELD *field;$/;"	v
field	commands/sort.cpp	/^adjust_options(field) register FIELD *field;$/;"	v
field	commands/sort.cpp	/^new_field(field, offset, beg_fl) register FIELD *field; \/* Field to assign *\/$/;"	v
field	commands/sort.cpp	/^register FIELD *field;                    \/* Field description *\/$/;"	v
field	commands/sort.cpp	/^register FIELD *field;$/;"	v
field_cnt	commands/sort.cpp	/^int field_cnt; \/* Nr of field actually assigned *\/$/;"	v
fields	commands/sort.cpp	/^FIELD fields[FIELDS_LIMIT];$/;"	v
fields	commands/uniq.cpp	/^int fields = 0;$/;"	v
fil	commands/make.cpp	/^FILE *fil;$/;"	v
fil_ptr	fs/stadir.cpp	/^struct filp *fil_ptr;       \/* filp pointer, supplied by 'fstat' *\/$/;"	v	typeref:struct:filp
file	commands/comm.cpp	/^struct file {$/;"	s	file:
file	commands/dosread.cpp	/^add_path(file, slash_fl) register char *file;$/;"	v
file	commands/ls.cpp	/^struct file {$/;"	s	file:
file	commands/ls.cpp	/^} file[NFILE + 1];$/;"	v	typeref:struct:file
file	commands/mined1.cpp	/^char *file;$/;"	v
file	commands/mined1.cpp	/^get_file(message, file) char *message, *file;$/;"	v
file	commands/mined1.cpp	/^load_file(file) char *file;$/;"	v
file	commands/mined2.cpp	/^FLAG file;$/;"	v
file	commands/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
file	commands/sort.cpp	/^char *file;$/;"	v
file	commands/tar.cpp	/^add_file(file) register char *file;$/;"	v
file	commands/tar.cpp	/^copy(file, from, to, bytes) char *file;$/;"	v
file	commands/tar.cpp	/^extract(file) register char *file;$/;"	v
file	commands/tar.cpp	/^is_dir(file) register char *file;$/;"	v
file	commands/tar.cpp	/^make_header(file, st) char *file;$/;"	v
file	commands/tar.cpp	/^register char *file;$/;"	v
file	tools/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
file_	tools/build.cpp	/^    std::fstream file_;             \/\/\/< File stream for read\/write access$/;"	m	class:minix::builder::ProgramType::ImageFile	file:
file_1	commands/cmp.cpp	/^char *file_1, *file_2;$/;"	v
file_2	commands/cmp.cpp	/^char *file_1, *file_2;$/;"	v
file_cnt	commands/sort.cpp	/^files_merge(file_cnt) register int file_cnt; \/* Nr_of_files to merge *\/$/;"	v
file_cnt	commands/sort.cpp	/^int file_cnt; \/* Nr of files that are being merged *\/$/;"	v
file_cnt	commands/sort.cpp	/^int file_cnt;$/;"	v
file_name	commands/mined1.cpp	/^char file_name[LINE_LEN];    \/* Name of file in use *\/$/;"	v
file_pos	include/minix/fs/const.hpp	/^enum class file_pos : std::int32_t {};$/;"	c	namespace:minix::fs
file_pos64	include/minix/fs/const.hpp	/^enum class file_pos64 : std::int64_t {};$/;"	c	namespace:minix::fs
file_to_stream_map	lib/io/src/stdio_compat.cpp	/^static std::unordered_map<FILE *, Stream *> file_to_stream_map;$/;"	m	namespace:minix::io::compat	file:
fileno	include/stdio.hpp	65;"	d
files	commands/comm.cpp	/^} files[2];$/;"	v	typeref:struct:file
files	commands/dd.cpp	/^unsigned files = 1;$/;"	v
fill	commands/dosread.cpp	/^static short fill(char *buffer) {$/;"	f	file:
fill_date	commands/dosread.cpp	/^static void fill_date(DIRECTORY *entry) {$/;"	f	file:
fill_file	commands/ls.cpp	/^static void fill_file(char *prefix, char *postfix, int statflag) {$/;"	f	file:
fillline	commands/roff.cpp	/^fillline() {$/;"	f
filp	fs/file.hpp	/^EXTERN struct filp {$/;"	s
filp	fs/file.hpp	/^} filp[NR_FILPS];$/;"	v	typeref:struct:filp
filp_count	fs/file.hpp	/^    int filp_count;         \/* how many file descriptors share this slot? *\/$/;"	m	struct:filp
filp_ino	fs/file.hpp	/^    struct inode *filp_ino; \/* pointer to the inode *\/$/;"	m	struct:filp	typeref:struct:filp::inode
filp_mode	fs/file.hpp	/^    mask_bits filp_mode;    \/* RW bits, telling how file is opened *\/$/;"	m	struct:filp
filp_pos	fs/file.hpp	/^    file_pos filp_pos;      \/* file position (file_pos is int32_t) *\/$/;"	m	struct:filp
find_differences	tools/fsck.cpp	/^    [[nodiscard]] std::vector<BitNumber> find_differences(const Bitmap &other) const {$/;"	f	class:minix::fsck::ZoneLevel::Bitmap
find_entry	commands/dosread.cpp	77;"	d	file:
find_filp	fs/filedes.cpp	/^PUBLIC struct filp *find_filp(struct inode *rip, int bits) {$/;"	f
find_in_cache	tools/diskio.cpp	/^DiskInterface::find_in_cache(SectorAddress sector) const {$/;"	f	class:diskio::DiskInterface
find_kr_cpp_files	tools/generate_kr_summary.py	/^def find_kr_cpp_files(root: str = ".") -> List[str]:$/;"	f
find_sources	tools/arch_scan.py	/^def find_sources(root: str) -> List[str]:$/;"	f
fl_address	kernel/floppy.cpp	/^    std::size_t fl_address;       \/* user virtual address (was vir_bytes) *\/$/;"	m	struct:floppy	file:
fl_calibration	kernel/floppy.cpp	/^    char fl_calibration;          \/* CALIBRATED or UNCALIBRATED *\/$/;"	m	struct:floppy	file:
fl_count	kernel/floppy.cpp	/^    std::size_t fl_count;         \/* byte count (was int) *\/$/;"	m	struct:floppy	file:
fl_curcyl	kernel/floppy.cpp	/^    int fl_curcyl;                \/* current cylinder *\/$/;"	m	struct:floppy	file:
fl_cylinder	kernel/floppy.cpp	/^    int fl_cylinder;              \/* cylinder number addressed *\/$/;"	m	struct:floppy	file:
fl_density	kernel/floppy.cpp	/^    char fl_density;              \/* 0 = 360K\/360K; 1 = 360K\/1.2M; 2= 1.2M\/1.2M *\/$/;"	m	struct:floppy	file:
fl_drive	kernel/floppy.cpp	/^    int fl_drive;                 \/* drive number addressed *\/$/;"	m	struct:floppy	file:
fl_head	kernel/floppy.cpp	/^    int fl_head;                  \/* head number addressed *\/$/;"	m	struct:floppy	file:
fl_opcode	kernel/floppy.cpp	/^    int fl_opcode;                \/* DISK_READ or DISK_WRITE *\/$/;"	m	struct:floppy	file:
fl_procnr	kernel/floppy.cpp	/^    int fl_procnr;                \/* which proc wanted this operation? *\/$/;"	m	struct:floppy	file:
fl_results	kernel/floppy.cpp	/^    char fl_results[MAX_RESULTS]; \/* the controller can give lots of output *\/$/;"	m	struct:floppy	file:
fl_sector	kernel/floppy.cpp	/^    int fl_sector;                \/* sector addressed *\/$/;"	m	struct:floppy	file:
flag	commands/dd.cpp	/^int flag = 0;$/;"	v
flag	commands/sh1.cpp	/^char *flag = flags - 'a';$/;"	v
flag	include/sh.hpp	/^char *flag;$/;"	v
flagp	lib/regexp.cpp	/^int *flagp;$/;"	v
flags	commands/ls.cpp	/^long flags;$/;"	v
flags	commands/sh1.cpp	/^char flags['z' - 'a' + 1];$/;"	v
flags	include/paging.hpp	/^    unsigned long flags;$/;"	m	struct:pt_entry
flags	include/vm.hpp	/^    VmFlags flags;     \/\/\/< Protection flags.$/;"	m	struct:VmFlags::vm_area
floppy	kernel/floppy.cpp	/^PRIVATE struct floppy {           \/* main drive struct, one entry per drive *\/$/;"	s	file:
floppy	kernel/floppy.cpp	/^} floppy[NR_DRIVES];$/;"	v	typeref:struct:floppy
flush	commands/ar.cpp	/^inline void flush() { print(NIL_PTR); }$/;"	f
flush	commands/cat.cpp	/^static void flush(void) {$/;"	f	file:
flush	commands/dosread.cpp	87;"	d	file:
flush	commands/lpr.cpp	/^static void flush() {$/;"	f	file:
flush	commands/mined.hpp	194;"	d
flush	commands/mkfs.cpp	/^flush() { return; }$/;"	f
flush	commands/mkfs.cpp	/^flush() {$/;"	f
flush	commands/tar.cpp	62;"	d	file:
flush	fs/putc.cpp	/^PRIVATE flush() {$/;"	f
flush	include/mined.hpp	187;"	d
flush	include/minix/io/stream.hpp	/^    virtual std::error_code flush() { return {}; }$/;"	f	class:minix::io::Stream
flush	tools/build.cpp	/^    void flush() {$/;"	f	class:minix::builder::ProgramType::ImageFile
flush	tools/mkfs.cpp	/^flush() { return; }$/;"	f
flush	tools/mkfs.cpp	/^flush() {$/;"	f
flush_buffer	tools/build.cpp	/^    void flush_buffer() {$/;"	f	class:minix::builder::ProgramType::ImageFile	file:
flush_cache	tools/diskio.cpp	/^void DiskInterface::flush_cache() {$/;"	f	class:diskio::DiskInterface
flushflag	commands/roff.cpp	/^writeline(adflag, flushflag) int adflag, flushflag;$/;"	v
fmt	commands/dosread.cpp	/^char *fmt;$/;"	v
fmt	commands/mined1.cpp	/^build_string(buf, fmt, args) register char *buf, *fmt;$/;"	v
fmt	commands/tar.cpp	/^register char *fmt;$/;"	v
fn	commands/sh3.cpp	/^    int (*fn)();$/;"	m	struct:builtin	file:
fn	commands/sh5.cpp	/^int (*fn)();$/;"	v
fn	commands/uniq.cpp	/^char *fn, *mode;$/;"	v
fold_case	commands/sort.cpp	/^    BOOL fold_case;$/;"	m	struct:FIELD	file:
fopen	lib/fopen.cpp	/^FILE *fopen(const char *name, const char *mode) {$/;"	f
fopen_compat	lib/io/src/stdio_compat.cpp	/^FILE *fopen_compat(const char *path, const char *mode) {$/;"	f
forbidden	fs/protect.cpp	/^PUBLIC std::expected<void, std::error_code> forbidden(struct inode *rip, uint16_t access_desired,$/;"	f
forgeahead	commands/make.cpp	/^int forgeahead = FALSE;$/;"	v
fork	lib/fork.cpp	/^pid_t fork() { \/\/ Changed return type from int to pid_t$/;"	f
format	commands/pr.cpp	/^static void format(FILE *filep) {$/;"	f	file:
format	lib/sprintf.cpp	/^char *buf, *format;$/;"	v
forward_scroll	commands/mined2.cpp	/^forward_scroll() {$/;"	f
fout	commands/c86/make.bat	/^:fout$/;"	l
fout	fs/c86/make.bat	/^:fout$/;"	l
fout	kernel/make.bat	/^:fout$/;"	l
fout	mm/c86/make.bat	/^:fout$/;"	l
fout	tools/c86/_fsck.bat	/^:fout$/;"	l
fout	tools/c86/_mkfs.bat	/^:fout$/;"	l
fout10	fs/c86/make.bat	/^:fout10$/;"	l
fout10	kernel/make.bat	/^:fout10$/;"	l
fout10	mm/c86/make.bat	/^:fout10$/;"	l
fout11	fs/c86/make.bat	/^:fout11$/;"	l
fout11	kernel/make.bat	/^:fout11$/;"	l
fout12	fs/c86/make.bat	/^:fout12$/;"	l
fout13	fs/c86/make.bat	/^:fout13$/;"	l
fout14	fs/c86/make.bat	/^:fout14$/;"	l
fout15	fs/c86/make.bat	/^:fout15$/;"	l
fout16	fs/c86/make.bat	/^:fout16$/;"	l
fout17	fs/c86/make.bat	/^:fout17$/;"	l
fout18	fs/c86/make.bat	/^:fout18$/;"	l
fout19	fs/c86/make.bat	/^:fout19$/;"	l
fout2	fs/c86/make.bat	/^:fout2$/;"	l
fout2	kernel/make.bat	/^:fout2$/;"	l
fout2	mm/c86/make.bat	/^:fout2$/;"	l
fout20	fs/c86/make.bat	/^:fout20$/;"	l
fout3	fs/c86/make.bat	/^:fout3$/;"	l
fout3	kernel/make.bat	/^:fout3$/;"	l
fout3	mm/c86/make.bat	/^:fout3$/;"	l
fout4	fs/c86/make.bat	/^:fout4$/;"	l
fout4	kernel/make.bat	/^:fout4$/;"	l
fout4	mm/c86/make.bat	/^:fout4$/;"	l
fout5	fs/c86/make.bat	/^:fout5$/;"	l
fout5	kernel/make.bat	/^:fout5$/;"	l
fout5	mm/c86/make.bat	/^:fout5$/;"	l
fout6	fs/c86/make.bat	/^:fout6$/;"	l
fout6	kernel/make.bat	/^:fout6$/;"	l
fout6	mm/c86/make.bat	/^:fout6$/;"	l
fout7	fs/c86/make.bat	/^:fout7$/;"	l
fout7	kernel/make.bat	/^:fout7$/;"	l
fout7	mm/c86/make.bat	/^:fout7$/;"	l
fout8	fs/c86/make.bat	/^:fout8$/;"	l
fout8	kernel/make.bat	/^:fout8$/;"	l
fout8	mm/c86/make.bat	/^:fout8$/;"	l
fout9	fs/c86/make.bat	/^:fout9$/;"	l
fout9	kernel/make.bat	/^:fout9$/;"	l
fout9	mm/c86/make.bat	/^:fout9$/;"	l
fp	fs/glo.hpp	/^EXTERN struct fproc *fp;           \/* pointer to caller's fproc struct *\/$/;"	v	typeref:struct:fproc
fp_buffer	fs/fproc.hpp	/^    char *fp_buffer;              \/* place to save buffer if rd\/wr can't finish *\/$/;"	m	struct:fproc
fp_effgid	fs/fproc.hpp	/^    gid fp_effgid;                \/* effective group id *\/$/;"	m	struct:fproc
fp_effuid	fs/fproc.hpp	/^    uid fp_effuid;                \/* effective user id *\/$/;"	m	struct:fproc
fp_fd	fs/fproc.hpp	/^    int fp_fd;                    \/* place to save fd if rd\/wr can't finish *\/$/;"	m	struct:fproc
fp_filp	fs/fproc.hpp	/^    struct filp *fp_filp[NR_FDS]; \/* the file descriptor table *\/$/;"	m	struct:fproc	typeref:struct:fproc::filp
fp_nbytes	fs/fproc.hpp	/^    int fp_nbytes;                \/* place to save bytes if rd\/wr can't finish *\/$/;"	m	struct:fproc
fp_realgid	fs/fproc.hpp	/^    gid fp_realgid;               \/* real group id *\/$/;"	m	struct:fproc
fp_realuid	fs/fproc.hpp	/^    uid fp_realuid;               \/* real user id *\/$/;"	m	struct:fproc
fp_revived	fs/fproc.hpp	/^    char fp_revived;              \/* set to indicate process being revived *\/$/;"	m	struct:fproc
fp_rootdir	fs/fproc.hpp	/^    struct inode *fp_rootdir;     \/* pointer to current root dir (see chroot) *\/$/;"	m	struct:fproc	typeref:struct:fproc::inode
fp_suspended	fs/fproc.hpp	/^    char fp_suspended;            \/* set to indicate process hanging *\/$/;"	m	struct:fproc
fp_task	fs/fproc.hpp	/^    char fp_task;                 \/* which task is proc suspended on *\/$/;"	m	struct:fproc
fp_umask	fs/fproc.hpp	/^    mask_bits fp_umask;           \/* mask set by umask system call *\/$/;"	m	struct:fproc
fp_workdir	fs/fproc.hpp	/^    struct inode *fp_workdir;     \/* pointer to working directory's inode *\/$/;"	m	struct:fproc	typeref:struct:fproc::inode
fprintf	lib/fprintf.cpp	/^int fprintf(FILE *file, const char *fmt, ...) {$/;"	f
fprintf_compat	lib/io/src/stdio_compat.cpp	/^int fprintf_compat(FILE *fp, const char *format, ...) {$/;"	f
fproc	fs/fproc.hpp	/^EXTERN struct fproc {$/;"	s
fproc	fs/fproc.hpp	/^} fproc[NR_PROCS];$/;"	v	typeref:struct:fproc
fputc	include/stdio.hpp	62;"	d
fputs	lib/fputs.cpp	/^int fputs(const char *s, FILE *file) {$/;"	f
fqmul	crypto/kyber_impl/ntt.c	/^static int16_t fqmul(int16_t a, int16_t b) {$/;"	f	file:
frame_payload	kernel/net_driver.cpp	/^[[nodiscard]] static std::vector<std::byte> frame_payload(std::span<const std::byte> data) {$/;"	f	namespace:net::__anon16
fread	lib/fread.cpp	/^size_t fread(void *ptr, size_t size, size_t count, FILE *file) {$/;"	f
fread_compat	lib/io/src/stdio_compat.cpp	/^size_t fread_compat(void *ptr, size_t size, size_t nmemb, FILE *fp) {$/;"	f
free	lib/malloc.cpp	/^void free(char *p) { *(vir_bytes *)(p - sizeof(char *)) &= ~BUSY; }$/;"	f
free_blocks	commands/dosread.cpp	/^static void free_blocks(void) {$/;"	f	file:
free_inode	fs/inode.cpp	/^free_inode(uint16_t dev,$/;"	f
free_list	commands/mined1.cpp	/^char *free_list;$/;"	v
freopen	lib/freopen.cpp	/^FILE *freopen(const char *name, const char *mode, FILE *stream) {$/;"	f
from	commands/mined1.cpp	/^register char *from;$/;"	v
from	commands/mined2.cpp	/^bcopy(from, to, bytes) register char *from, *to;$/;"	v
from	commands/mkfs.cpp	/^copy(from, to, count) char *from, *to;$/;"	v
from	commands/sh5.cpp	/^register char *ato, *from;$/;"	v
from	commands/tar.cpp	/^int from, to;$/;"	v
from	tools/mkfs.cpp	/^copy(from, to, count) char *from, *to;$/;"	v
front	fs/buf.hpp	/^EXTERN struct buf* front; \/\/\/< LRU (least recently used) buffer.$/;"	v	typeref:struct:buf
frule	commands/make.cpp	/^char *frule;$/;"	v
fs	include/minix/fs/buffer.hpp	/^namespace minix::fs {$/;"	n	class:minix
fs	include/minix/fs/const.hpp	/^namespace minix::fs {$/;"	n	class:minix
fs	include/minix/fs/inode.hpp	/^namespace minix::fs {$/;"	n	class:minix
fs	tools/bootblok1.cpp	/^namespace fs {$/;"	n	file:
fs_call	fs/glo.hpp	/^EXTERN int fs_call;              \/* system call number *\/$/;"	v
fs_init	fs/main.cpp	/^static void fs_init() {$/;"	f	file:
fs_tty	fs/fproc.hpp	/^    dev_nr fs_tty;                \/* major\/minor of controlling tty *\/$/;"	m	struct:fproc
fscanf	lib/scanf.cpp	/^int fscanf(FILE *fp, const char *format, ...) {$/;"	f
fsck	tools/fsck.cpp	/^namespace minix::fsck {$/;"	n	class:minix	file:
fseek	lib/fseek.cpp	/^int fseek(FILE *iop, long offset, int where) {$/;"	f
fstack	fs/glo.hpp	/^EXTERN char fstack[FS_STACK_BYTES]; \/* the File System's stack. *\/$/;"	v
fstat	lib/fstat.cpp	/^int fstat(int fd, char *buffer) {$/;"	f
fstatus	commands/mined.hpp	234;"	d
fstatus	include/mined.hpp	227;"	d
ftell	lib/ftell.cpp	/^long ftell(FILE *iop) {$/;"	f
func	commands/sh4.cpp	/^int (*func)();$/;"	v
func	mm/param.hpp	11;"	d
func	test/test1.cpp	/^func() {$/;"	f
func1	test/test5.cpp	/^func1() {$/;"	f
func10	test/test5.cpp	/^func10() {$/;"	f
func11	test/test5.cpp	/^func11() { e(38); }$/;"	f
func8	test/test5.cpp	/^func8() {}$/;"	f
funcalrm	test/test5.cpp	/^funcalrm() { alarms++; }$/;"	f
fword	commands/make.cpp	/^char *fword, *restline, line[INMAX], backup[INMAX];$/;"	v
fwrite	lib/fwrite.cpp	/^size_t fwrite(const void *ptr, size_t size, size_t count, FILE *file) {$/;"	f
fwrite_compat	lib/io/src/stdio_compat.cpp	/^size_t fwrite_compat(const void *ptr, size_t size, size_t nmemb, FILE *fp) {$/;"	f
g_callback	kernel/net_driver.cpp	/^static RecvCallback g_callback;$/;"	m	namespace:net::__anon16	file:
g_graph	kernel/lattice_ipc.cpp	/^Graph g_graph; \/\/\/< Singleton IPC graph$/;"	m	namespace:lattice	file:
g_ipc_cv	kernel/lattice_ipc.cpp	/^static std::condition_variable g_ipc_cv;$/;"	m	namespace:lattice	file:
g_ipc_mutex	kernel/lattice_ipc.cpp	/^static std::mutex g_ipc_mutex;$/;"	m	namespace:lattice	file:
g_mutex	kernel/net_driver.cpp	/^static std::mutex g_mutex;$/;"	m	namespace:net::__anon16	file:
g_queue	kernel/net_driver.cpp	/^static std::deque<Packet> g_queue;$/;"	m	namespace:net::__anon16	file:
g_remotes	kernel/net_driver.cpp	/^static std::unordered_map<node_t, Remote> g_remotes;$/;"	m	namespace:net::__anon16	file:
g_remotes_mutex	kernel/net_driver.cpp	/^static std::mutex g_remotes_mutex;$/;"	m	namespace:net::__anon16	file:
g_tcp_listen	kernel/net_driver.cpp	/^static int g_tcp_listen = -1;$/;"	m	namespace:net::__anon16	file:
g_tcp_thread	kernel/net_driver.cpp	/^static std::jthread g_udp_thread, g_tcp_thread;$/;"	m	namespace:net::__anon16	file:
g_udp_sock	kernel/net_driver.cpp	/^static int g_udp_sock = -1;$/;"	m	namespace:net::__anon16	file:
g_udp_thread	kernel/net_driver.cpp	/^static std::jthread g_udp_thread, g_tcp_thread;$/;"	m	namespace:net::__anon16	file:
gap	kernel/floppy.cpp	/^PRIVATE int gap[NT] = {0x2A, 0x2A, 0x23, 0x1B};                       \/* gap size *\/$/;"	v
garbage	commands/sh1.cpp	/^void garbage() {$/;"	f
garbage	test/test9.cpp	/^garbage() {$/;"	f
gct	test/test1.cpp	/^int glov, gct;$/;"	v
gdone	commands/make.cpp	/^int sending, def_ready, gdone, rule_send, rule_ready;$/;"	v
gen_a	crypto/kyber_impl/indcpa.c	144;"	d	file:
gen_at	crypto/kyber_impl/indcpa.c	145;"	d	file:
gen_matrix	crypto/kyber_impl/indcpa.c	/^void gen_matrix(polyvec *a, const uint8_t seed[KYBER_SYMBYTES], int transposed)$/;"	f
gen_matrix	crypto/kyber_impl/indcpa.h	8;"	d
generate_report	tools/migration_dashboard.py	/^def generate_report():$/;"	f
get	commands/ar.cpp	/^static void get(int argc, char *argv[]) {$/;"	f	file:
get_all_zones	tools/fsck.cpp	/^    [[nodiscard]] std::vector<zone_nr> get_all_zones(diskio::DiskInterface &disk,$/;"	f	class:minix::fsck::ZoneLevel::Inode
get_base	lib/getutil.cpp	/^phys_clicks get_base() { return 0; }$/;"	f
get_byte	tools/build.cpp	/^    [[nodiscard]] std::uint8_t get_byte(ByteOffset offset) {$/;"	f	class:minix::builder::ProgramType::ImageFile
get_byte	tools/build.cpp	/^    [[nodiscard]] std::uint8_t get_byte(std::size_t offset) const {$/;"	f	class:minix::builder::ProgramType::SectorBuffer
get_char	commands/dosread.cpp	/^static int get_char(void) {$/;"	f	file:
get_current_path	tools/fsck.cpp	/^    [[nodiscard]] std::string get_current_path() const {$/;"	f	class:minix::fsck::ZoneLevel::PathTracker
get_fd	fs/filedes.cpp	/^PUBLIC int get_fd(uint16_t bits, int *k, struct filp **fpt) {$/;"	f
get_filp	fs/filedes.cpp	/^PUBLIC struct filp *get_filp(int fild) {$/;"	f
get_header	commands/tar.cpp	/^BOOL get_header() {$/;"	f
get_inode	fs/inode.cpp	/^PUBLIC struct inode *get_inode(uint16_t dev,$/;"	f
get_inode_address	tools/fsck.cpp	/^    [[nodiscard]] std::uint64_t get_inode_address(inode_nr ino) const {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
get_input	tools/fsck.cpp	/^    template <typename T> [[nodiscard]] std::optional<T> get_input(std::string_view prompt) {$/;"	f	class:minix::fsck::ZoneLevel::UserInterface
get_member	commands/ar.cpp	/^static MEMBER *get_member(void) {$/;"	f	file:
get_mr	kernel/wormhole.hpp	/^    std::optional<uint64_t> get_mr(size_t index) const {$/;"	f	struct:fastpath::ThreadTemplate
get_name	fs/path.cpp	/^static char *get_name(char *old_name, char string[NAME_SIZE]) {$/;"	f	file:
get_o1	common/math/sedenion.cpp	/^Octonion Sedenion::get_o1() const {$/;"	f	class:Common::Math::Sedenion
get_o2	common/math/sedenion.cpp	/^Octonion Sedenion::get_o2() const {$/;"	f	class:Common::Math::Sedenion
get_q1	common/math/octonion.cpp	/^Quaternion Octonion::get_q1() const {$/;"	f	class:Common::Math::Octonion
get_q2	common/math/octonion.cpp	/^Quaternion Octonion::get_q2() const {$/;"	f	class:Common::Math::Octonion
get_sector_count	tools/diskio.hpp	/^    [[nodiscard]] std::uint64_t get_sector_count() const {$/;"	f	class:DiskInterface
get_shift	commands/mined.hpp	239;"	d
get_shift	include/mined.hpp	232;"	d
get_size	lib/getutil.cpp	/^phys_clicks get_size() { return reinterpret_cast<phys_clicks>(&endbss); }$/;"	f
get_size	tools/diskio.cpp	/^std::uint64_t DiskInterface::get_size() const {$/;"	f	class:diskio::DiskInterface
get_stream	lib/io/src/stdio_compat.cpp	/^Stream *get_stream(FILE *file) {$/;"	f	namespace:minix::io::compat
get_string	commands/mined.hpp	228;"	d
get_string	include/mined.hpp	221;"	d
get_term	commands/mined1.cpp	/^get_term() {$/;"	f
get_tot_mem	lib/getutil.cpp	/^phys_clicks get_tot_mem() { return 0; }$/;"	f
get_work	fs/main.cpp	/^static void get_work() {$/;"	f	file:
get_zone	tools/fsck.cpp	/^    [[nodiscard]] zone_nr get_zone(std::size_t index) const {$/;"	f	class:minix::fsck::ZoneLevel::Inode
get_zone_address	tools/fsck.cpp	/^    [[nodiscard]] std::uint64_t get_zone_address(zone_nr zone) const {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
getbuf	commands/comm.cpp	/^static int getbuf(struct file *file) {$/;"	f	file:
getbuf	commands/gres.cpp	/^char *static char *getbuf(regexp *exp, char *repstr) {$/;"	f	file:
getc	include/stdio.hpp	/^inline int getc(FILE *iop) {$/;"	f
getc	lib/getc.cpp	/^int getc(FILE *iop)$/;"	f
getchar	commands/mined.hpp	14;"	d
getchar	commands/mined1.cpp	/^getchar() {$/;"	f
getchar	include/mined.hpp	14;"	d
getchar	include/stdio.hpp	52;"	d
getegid	lib/getegid.cpp	/^gid getegid() {$/;"	f
getenv	lib/getenv.cpp	/^char *getenv(const char *name) {$/;"	f
geteuid	lib/geteuid.cpp	/^uid geteuid() {$/;"	f
getgid	lib/getgid.cpp	/^gid getgid() {$/;"	f
getgrent	lib/getgrent.cpp	/^struct group *getgrent() {$/;"	f
getgrgid	lib/getgrent.cpp	/^struct group *getgrgid(int gid) {$/;"	f
getgrnam	lib/getgrent.cpp	/^struct group *getgrnam(char *name) {$/;"	f
gethere	commands/sh5.cpp	/^gethere() {$/;"	f
getline	commands/grep.cpp	/^static char *getline(char *buf, int size) {$/;"	f	file:
getline	commands/ls.cpp	/^static void getline(char *buf) {$/;"	f	file:
getline	lib/getgrent.cpp	/^static int getline() {$/;"	f	file:
getline	lib/getpwent.cpp	/^static int getline(void) {$/;"	f	file:
getnxt	commands/make.cpp	/^getnxt() {$/;"	f
getpass	lib/getpass.cpp	/^char *getpass(const char *prompt) {$/;"	f
getpid	lib/getpid.cpp	/^int getpid() { return callm1(MM, GETPID, 0, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
getpwdch	commands/ls.cpp	/^static char getpwdch(void) {$/;"	f	file:
getpwent	lib/getpwent.cpp	/^struct passwd *getpwent(void) {$/;"	f
getpwnam	lib/getpwent.cpp	/^struct passwd *getpwnam(const char *name) {$/;"	f
getpwuid	lib/getpwent.cpp	/^struct passwd *getpwuid(int uid) {$/;"	f
gets	lib/gets.cpp	/^char *gets(char *str) {$/;"	f
getuid	lib/getuid.cpp	/^uid getuid() {$/;"	f
getuidgid	commands/ls.cpp	/^static char *getuidgid(int usrid) {$/;"	f	file:
gflag	commands/gres.cpp	/^int gflag = 0; \/* != 0 => only do first substitution on line *\/$/;"	v
gflg	include/sh.hpp	/^char gflg;$/;"	v
gid	include/grp.hpp	/^    int gid;      \/\/ Numerical group identifier$/;"	m	struct:group
gid	include/minix/fs/const.hpp	/^enum class gid : std::uint8_t {};$/;"	c	namespace:minix::fs
global	boot.S	/^global _start$/;"	l
globv	commands/sh4.cpp	/^int globv;$/;"	v
glov	test/test1.cpp	/^int glov, gct;$/;"	v
group	fs/param.hpp	14;"	d
group	include/grp.hpp	/^struct group {$/;"	s
grow	lib/malloc.cpp	/^static int grow(unsigned len) {$/;"	f	file:
grows_down	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool grows_down = false;           \/\/ stack-like growth$/;"	m	struct:psd::vm::semantic_traits
grows_down	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool grows_down = false;$/;"	m	struct:psd::vm::semantic_traits
grows_down	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool grows_down = true;$/;"	m	struct:psd::vm::semantic_traits
grp	lib/getgrent.cpp	/^static struct group grp;$/;"	v	typeref:struct:group	file:
grpid	commands/mkfs.cpp	/^int mode, usrid, grpid;$/;"	v
grpid	mm/param.hpp	12;"	d
grpid	tools/mkfs.cpp	/^int mode, usrid, grpid;$/;"	v
gwarning	commands/mkfs.cpp	/^char gwarning[] = {65, 46, 83, 46, 84, 97, 110, 101, 110, 98, 97, 117, 109, 10};$/;"	v
gwarning	tools/mkfs.cpp	/^char gwarning[] = {65, 46, 83, 46, 84, 97, 110, 101, 110, 98, 97, 117, 109, 10};$/;"	v
h	commands/make.cpp	/^struct llist *d, *h;    \/* pointers to depends, howto *\/$/;"	v	typeref:struct:
h	fs/minix/Makefile	/^                       h =..\/ h l =..\/ lib$/;"	m
h	mm/Makefile	/^                                   -I$(INC) h =..\/ h l =..\/ lib$/;"	m
h	mm/minix/Makefile	/^                   -I$(INC) h =..\/ h l =..\/ lib$/;"	m
h_dosub	commands/sh5.cpp	/^    int h_dosub;$/;"	m	struct:here	file:
h_iop	commands/sh5.cpp	/^    struct ioword *h_iop;$/;"	m	struct:here	typeref:struct:here::ioword	file:
h_next	commands/sh5.cpp	/^    struct here *h_next;$/;"	m	struct:here	typeref:struct:here::here	file:
h_tag	commands/sh5.cpp	/^    char *h_tag;$/;"	m	struct:here	file:
hainit	commands/libpack.cpp	/^hainit() {$/;"	f
handle_	include/minix/fs/buffer.hpp	/^    BufferHandle handle_;$/;"	m	class:minix::fs::BufferGuard
handle_crash	kernel/service.cpp	/^bool ServiceManager::handle_crash(xinim::pid_t pid) {$/;"	f	class:svc::ServiceManager
handling	fs/cache.cpp	/^✅ All buffer cache primitives have now been elevated into a modern C++23 implementation, complete with RAII semantics (`BufferGuard`), strong `enum class` usage for block types, rigorous error handling, and clear semantic modularization.$/;"	v	typeref:class:error
hard	test/test9.cpp	/^hard() {$/;"	f
has_path	kernel/service.cpp	/^bool ServiceManager::has_path(xinim::pid_t start, xinim::pid_t target,$/;"	f	class:svc::ServiceManager
has_path	kernel/wait_graph.cpp	/^bool WaitForGraph::has_path(xinim::pid_t from, xinim::pid_t to,$/;"	f	class:lattice::WaitForGraph
has_value_	tools/bootblok1.cpp	/^    bool has_value_;$/;"	m	class:optional	file:
hash	commands/libpack.cpp	/^struct node *hash[MAX]; \/* hash table *\/$/;"	v	typeref:struct:node
hash_g	crypto/kyber_impl/symmetric.h	27;"	d
hash_h	crypto/kyber_impl/symmetric.h	26;"	d
hdr_block	commands/tar.cpp	/^    char hdr_block[HEADER_SIZE];$/;"	m	union:HEADER	file:
hdr_size	tools/c86/dos2out.cpp	/^	unsigned int	hdr_size;	\/* header-size in *16b *\/$/;"	m	struct:d_fmt_hdr	file:
head	commands/make.cpp	/^    struct llist *head;$/;"	v	typeref:struct:llist
head	commands/make.cpp	/^char *head, *nam;$/;"	v
head	commands/make.cpp	/^struct llist *head;$/;"	v	typeref:struct:llist
head	commands/make.cpp	/^struct rulerec *head;$/;"	v	typeref:struct:rulerec
head_line	commands/mined1.cpp	/^reset(head_line, screen_y) LINE *head_line;$/;"	v
header	commands/mined1.cpp	/^LINE *header;             \/* Head of line list *\/$/;"	v
header	commands/pr.cpp	/^char *header;$/;"	v
header	commands/tar.cpp	/^HEADER header;$/;"	v
header_end	boot.S	/^header_end:$/;"	l
header_start	boot.S	/^header_start:$/;"	l
heading	commands/size.cpp	/^int heading; \/* set when heading printed *\/$/;"	v
here	commands/sh5.cpp	/^struct here {$/;"	s	file:
herelist	commands/sh5.cpp	/^} *herelist;$/;"	v	typeref:struct:here
hex	tools/r.cpp	/^static void hex(short x) { \/* Print x in hex *\/$/;"	f	file:
hexdump	tools/bootblok1.cpp	/^    [[nodiscard]] std::string hexdump() const {$/;"	f	class:minix::bootloader::BootSector
hexin	tools/r.cpp	/^static long hexin(void) {$/;"	f	file:
hflag	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
hflag	commands/roff.cpp	/^int sflag, hflag, startpage, stoppage;$/;"	v
highest_address	pmm.cpp	/^static uintptr_t highest_address = 0;$/;"	v	file:
holdp	commands/roff.cpp	/^char holdword[MAXLENGTH], *holdp;$/;"	v
holdword	commands/roff.cpp	/^char holdword[MAXLENGTH], *holdp;$/;"	v
hole_list	mm/alloc.cpp	/^static std::list<Hole> hole_list;$/;"	v	file:
homedir	include/sh.hpp	/^struct var *homedir; \/* home directory *\/$/;"	v	typeref:struct:var
hour	commands/date.cpp	/^    int year, month, day, hour, min, sec;$/;"	m	struct:__anon25	file:
how	commands/cal.cpp	/^char *how = {"Usage: cal [month] year\\n"};$/;"	v
howp3	commands/make.cpp	/^struct llist *fhowto, *howp3;$/;"	v	typeref:struct:
howto	commands/make.cpp	/^    struct llist *howto;$/;"	m	struct:defnrec	typeref:struct:defnrec::llist	file:
html_static_path	docs/sphinx/conf.py	/^html_static_path = ["_static"]  # Directory for custom static files$/;"	v
html_theme	docs/sphinx/conf.py	/^html_theme = "sphinx_rtd_theme"  # Use Read the Docs theme$/;"	v
hw	include/xinim/core_types.hpp	/^namespace hw {$/;"	n	namespace:xinim
hyper	kernel/quaternion_spinlock.hpp	/^namespace hyper {$/;"	n
hyper	kernel/sedenion.hpp	/^namespace hyper {$/;"	n
i	commands/roff.cpp	/^int *i, *s, sdef;$/;"	v
i	commands/roff.cpp	/^nread(i) int *i;$/;"	v
i	commands/sh2.cpp	/^    int i;$/;"	m	union:__anon26	file:
i	commands/sh4.cpp	/^glob2(i, j) char *i, *j;$/;"	v
i	commands/sh4.cpp	/^glob3(i, j, k) char *i, *j, *k;$/;"	v
i	test/test1.cpp	/^child(i) int i;$/;"	v
i	test/test4.cpp	/^int i, fd;$/;"	v
i_count	fs/inode.hpp	/^    int16_t i_count; \/* # times inode used; 0 means slot is free (was short int) *\/$/;"	m	struct:inode
i_dev	fs/inode.hpp	/^    dev_nr i_dev;    \/* which device is the inode on (dev_nr is uint16_t) *\/$/;"	m	struct:inode
i_dirt	fs/inode.hpp	/^    char i_dirt;     \/* CLEAN or DIRTY *\/$/;"	m	struct:inode
i_extent_count	fs/inode.hpp	/^    uint16_t i_extent_count;      \/* number of extents (was unsigned short) *\/$/;"	m	struct:inode
i_extents	fs/inode.hpp	/^    extent *i_extents;            \/* extent table for extent-based files *\/$/;"	m	struct:inode
i_gid	fs/inode.hpp	/^    gid i_gid;                    \/* group number (gid is uint8_t) *\/$/;"	m	struct:inode
i_gid	fs/type.hpp	/^    gid i_gid;                    \/* group number *\/$/;"	m	struct:d_inode
i_gid	tools/fsck.cpp	/^    std::uint8_t i_gid;$/;"	m	struct:minix::fsck::ZoneLevel::d_inode	file:
i_mode	fs/inode.hpp	/^    mask_bits i_mode;             \/* file type, protection, etc. (mask_bits is uint16_t) *\/$/;"	m	struct:inode
i_mode	fs/type.hpp	/^    mask_bits i_mode;             \/* file type, protection, etc. *\/$/;"	m	struct:d_inode
i_mode	tools/fsck.cpp	/^    std::uint16_t i_mode;$/;"	m	struct:minix::fsck::ZoneLevel::d_inode	file:
i_modtime	fs/inode.hpp	/^    real_time i_modtime;          \/* when was file data last changed (real_time is int64_t) *\/$/;"	m	struct:inode
i_modtime	fs/type.hpp	/^    real_time i_modtime;          \/* when was file data last changed *\/$/;"	m	struct:d_inode
i_modtime	tools/fsck.cpp	/^    std::uint32_t i_modtime;$/;"	m	struct:minix::fsck::ZoneLevel::d_inode	file:
i_mount	fs/inode.hpp	/^    char i_mount;    \/* this bit is set if file mounted on *\/$/;"	m	struct:inode
i_nlinks	fs/inode.hpp	/^    links i_nlinks;               \/* how many links to this file (links is uint8_t) *\/$/;"	m	struct:inode
i_nlinks	fs/type.hpp	/^    links i_nlinks;               \/* how many links to this file *\/$/;"	m	struct:d_inode
i_nlinks	tools/fsck.cpp	/^    std::uint8_t i_nlinks;$/;"	m	struct:minix::fsck::ZoneLevel::d_inode	file:
i_num	fs/inode.hpp	/^    inode_nr i_num;  \/* inode number on its (minor) device (inode_nr is uint16_t) *\/$/;"	m	struct:inode
i_pipe	fs/inode.hpp	/^    char i_pipe;     \/* set to I_PIPE if pipe *\/$/;"	m	struct:inode
i_seek	fs/inode.hpp	/^    char i_seek;     \/* set on LSEEK, cleared on READ\/WRITE *\/$/;"	m	struct:inode
i_size	fs/inode.hpp	/^    file_pos i_size;              \/* current file size in bytes (file_pos is int32_t) *\/$/;"	m	struct:inode
i_size	fs/type.hpp	/^    file_pos i_size;              \/* current file size in bytes *\/$/;"	m	struct:d_inode
i_size	tools/fsck.cpp	/^    std::uint32_t i_size;$/;"	m	struct:minix::fsck::ZoneLevel::d_inode	file:
i_size64	fs/inode.hpp	/^    file_pos64 i_size64;          \/* 64-bit file size (file_pos64 is int64_t) *\/$/;"	m	struct:inode
i_size64	fs/type.hpp	/^    file_pos64 i_size64;          \/* 64-bit file size *\/$/;"	m	struct:d_inode
i_uid	fs/inode.hpp	/^    uid i_uid;                    \/* user id of the file's owner (uid is uint16_t) *\/$/;"	m	struct:inode
i_uid	fs/type.hpp	/^    uid i_uid;                    \/* user id of the file's owner *\/$/;"	m	struct:d_inode
i_uid	tools/fsck.cpp	/^    std::uint16_t i_uid;$/;"	m	struct:minix::fsck::ZoneLevel::d_inode	file:
i_zone	fs/inode.hpp	/^    zone_nr i_zone[NR_ZONE_NUMS]; \/* zone numbers for direct, ind, and dbl ind *\/$/;"	m	struct:inode
i_zone	fs/type.hpp	/^    zone_nr i_zone[NR_ZONE_NUMS]; \/* block nums for direct, ind, and dbl ind *\/$/;"	m	struct:d_inode
i_zone	tools/fsck.cpp	/^    std::array<zone_nr, 9> i_zone;$/;"	m	struct:minix::fsck::ZoneLevel::d_inode	file:
ibc	commands/dd.cpp	/^int ifd, ofd, ibc;$/;"	v
ibs	commands/dd.cpp	/^unsigned ibs = DEFAULT;$/;"	v
ibuf	commands/dd.cpp	/^char *ibuf, *obuf, *op;$/;"	v
idt	kernel/idt64.cpp	/^static struct idt_entry idt[256];$/;"	v	typeref:struct:idt_entry	file:
idt_desc	kernel/idt64.cpp	/^static struct idt_ptr idt_desc;$/;"	v	typeref:struct:idt_ptr	file:
idt_entry	kernel/idt64.cpp	/^struct idt_entry {$/;"	s	file:
idt_ptr	kernel/idt64.cpp	/^struct idt_ptr {$/;"	s	file:
ifd	commands/dd.cpp	/^int ifd, ofd, ibc;$/;"	v
ifile	commands/cc.cpp	/^USTRING ifile, kfile, sfile, mfile, ofile;$/;"	v
ifilename	commands/dd.cpp	/^char *ifilename = NULL;$/;"	v
iflag	commands/rm.cpp	/^int iflag = 0;$/;"	v
ifs	include/sh.hpp	/^struct var *ifs;     \/* field separators *\/$/;"	v	typeref:struct:var
iip	fs/stadir.cpp	/^struct inode **iip; \/* pointer to the inode pointer for the dir *\/$/;"	v	typeref:struct:inode
image_	tools/build.cpp	/^    std::unique_ptr<ImageFile> image_; \/\/\/< Output image file manager$/;"	m	class:minix::builder::ProgramType::BootImageBuilder	file:
implementation	fs/cache.cpp	/^✅ All buffer cache primitives have now been elevated into a modern C++23 implementation, complete with RAII semantics (`BufferGuard`), strong `enum class` usage for block types, rigorous error handling, and clear semantic modularization.$/;"	v
in_buf	commands/lpr.cpp	/^char in_buf[BLOCK], out_buf[BLOCK];$/;"	v
in_core	commands/sort.cpp	/^BOOL in_core = TRUE; \/* Set if input cannot all be sorted in core *\/$/;"	v
in_count	commands/lpr.cpp	/^int cur_in, in_count, out_count, column;$/;"	v
in_index	commands/tr.cpp	/^short in_index, out_index;$/;"	v
inb	console.cpp	/^static inline unsigned char inb(unsigned short port) {$/;"	f	file:
inbox_	kernel/lattice_ipc.hpp	/^    std::unordered_map<xinim::pid_t, message> inbox_;  \/\/!< ready messages$/;"	m	class:lattice::Graph
inbuf	commands/mined1.cpp	/^char *inbuf;$/;"	v
inbuf	commands/mined1.cpp	/^input(inbuf, clearfl) char *inbuf;$/;"	v
inbuf	tools/c86/dos2out.cpp	/^unsigned char inbuf[PH_SECTSIZE];$/;"	v
inbuf2	tools/c86/dos2out.cpp	/^unsigned char inbuf2[PH_SECTSIZE];$/;"	v
indcpa_dec	crypto/kyber_impl/indcpa.c	/^void indcpa_dec(uint8_t m[KYBER_INDCPA_MSGBYTES],$/;"	f
indcpa_dec	crypto/kyber_impl/indcpa.h	22;"	d
indcpa_enc	crypto/kyber_impl/indcpa.c	/^void indcpa_enc(uint8_t c[KYBER_INDCPA_BYTES],$/;"	f
indcpa_enc	crypto/kyber_impl/indcpa.h	16;"	d
indcpa_keypair_derand	crypto/kyber_impl/indcpa.c	/^void indcpa_keypair_derand(uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES],$/;"	f
indcpa_keypair_derand	crypto/kyber_impl/indcpa.h	11;"	d
index	commands/shar.cpp	/^int index = 0;$/;"	v
index	lib/index.cpp	/^char *index(char *s, int c) {$/;"	f
infile	commands/split.cpp	/^int infile;$/;"	v
info	commands/cal.cpp	/^} info;$/;"	v	typeref:struct:__anon29	file:
init	commands/cc.cpp	88;"	d	file:
init	commands/make.cpp	/^static void init(int argc, char *argv[]) {$/;"	f	file:
init	kernel/net_driver.cpp	/^void init(const Config &cfg) {$/;"	f	namespace:net
init_alloc	commands/mined1.cpp	/^init_alloc() {$/;"	f
init_extended_inode	fs/compat.cpp	/^PUBLIC void init_extended_inode(struct inode *ip) {$/;"	f
initialize	commands/mined1.cpp	/^initialize() {$/;"	f
initialize_free_bits	tools/fsck.cpp	/^    void initialize_free_bits(BitNumber start_bit) {$/;"	f	class:minix::fsck::ZoneLevel::Bitmap
initialized	kernel/floppy.cpp	/^PRIVATE int initialized;  \/* set to 1 after first successful transfer *\/$/;"	v
initstack	test/test1.cpp	/^char initstack[2048];$/;"	v
inode	commands/mkfs.cpp	/^eat_file(inode, f) int inode, f;$/;"	v
inode	commands/mkfs.cpp	/^rootdir(inode) int inode;$/;"	v
inode	fs/inode.hpp	/^EXTERN struct inode {$/;"	s
inode	fs/inode.hpp	/^} inode[NR_INODES];$/;"	v	typeref:struct:inode
inode	tools/mkfs.cpp	/^eat_file(inode, f) int inode, f;$/;"	v
inode	tools/mkfs.cpp	/^rootdir(inode) int inode;$/;"	v
inode_	include/minix/fs/inode.hpp	/^    class Inode *inode_;$/;"	m	class:minix::fs::InodeType::InodeHandle	typeref:class:minix::fs::InodeType::InodeHandle::Inode
inode_	tools/fsck.cpp	/^    d_inode inode_;$/;"	m	class:minix::fsck::ZoneLevel::Inode	file:
inode_bitmap_	tools/fsck.cpp	/^    Bitmap inode_bitmap_;$/;"	m	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
inode_link_counts_	tools/fsck.cpp	/^    std::vector<std::uint16_t> inode_link_counts_;$/;"	m	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
inode_nr	include/minix/fs/const.hpp	/^enum class inode_nr : std::uint32_t {};$/;"	c	namespace:minix::fs
inode_number	tools/fsck.cpp	/^        inode_nr inode_number;$/;"	m	struct:minix::fsck::ZoneLevel::DirectoryEntry::Entry	file:
inode_number	tools/fsck.cpp	/^        inode_nr inode_number;$/;"	m	struct:minix::fsck::ZoneLevel::PathTracker::PathNode	file:
inode_offset	commands/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
inode_offset	tools/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
inode_type_to_string	tools/fsck.cpp	/^    [[nodiscard]] std::string inode_type_to_string(InodeType type) const {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
inodes	commands/mkfs.cpp	/^super(zones, inodes) int zones, inodes;$/;"	v
inodes	tools/mkfs.cpp	/^super(zones, inodes) int zones, inodes;$/;"	v
inparse	commands/sh1.cpp	/^int inparse;$/;"	v
input	commands/libpack.cpp	/^char input[BUFSIZ + 2];$/;"	v
input	commands/libupack.cpp	/^char input[IBUFSIZE + 1];$/;"	v
input	commands/shar.cpp	/^char input[IO_SIZE];$/;"	v
input	commands/tr.cpp	/^unsigned char output[BUFFER_SIZE], input[BUFFER_SIZE];$/;"	v
input_fd	commands/mined1.cpp	/^int input_fd = 0;            \/* Fd for command input *\/$/;"	v
input_files	tools/build.cpp	/^            std::vector<std::string> input_files; \/\/\/< Paths for input components$/;"	m	struct:minix::builder::ProgramType::BootImageBuilder::ArgumentParser::Arguments	file:
int_mess	kernel/glo.hpp	/^EXTERN message int_mess;       \/* interrupt routines build message here *\/$/;"	v
int_stack	kernel/idt64.cpp	/^static u8_t int_stack[4096];$/;"	v	file:
interleave	kernel/floppy.cpp	/^PRIVATE char interleave[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};$/;"	v
interrupt	kernel/proc.cpp	/^PUBLIC void interrupt(int task, message *m_ptr) {$/;"	f
intr	commands/sh1.cpp	/^int intr;$/;"	v
intr	include/sh.hpp	/^int intr;   \/* interrupt pending *\/$/;"	v
inum	commands/ls.cpp	/^    short inum;$/;"	m	struct:dir	file:
inumber	commands/ls.cpp	/^    unsigned short inumber;$/;"	m	struct:file	file:
invec	commands/tr.cpp	/^BOOL invec[ASCII + 1], outvec[ASCII + 1];$/;"	v
inverse	common/math/octonion.cpp	/^Octonion Octonion::inverse() const {$/;"	f	class:Common::Math::Octonion
inverse	common/math/quaternion.cpp	/^Quaternion Quaternion::inverse() const {$/;"	f	class:Common::Math::Quaternion
inverse	common/math/sedenion.cpp	/^Sedenion Sedenion::inverse() const {$/;"	f	class:Common::Math::Sedenion
invntt	crypto/kyber_impl/ntt.c	/^void invntt(int16_t r[256]) {$/;"	f
invntt	crypto/kyber_impl/ntt.h	13;"	d
inword	commands/sh1.cpp	/^int inword = 1;$/;"	v
inword	include/sh.hpp	/^int inword; \/* defer traps and interrupts *\/$/;"	v
io	include/minix/io/file_operations.hpp	/^namespace minix::io {$/;"	n	class:minix
io	include/minix/io/file_stream.hpp	/^namespace minix::io {$/;"	n	class:minix
io	include/minix/io/memory_stream.hpp	/^namespace minix::io {$/;"	n	class:minix
io	include/minix/io/standard_streams.hpp	/^namespace minix::io {$/;"	n	class:minix
io	include/minix/io/stream.hpp	/^namespace minix::io {$/;"	n	class:minix
io	include/sh.hpp	/^struct io {$/;"	s
io	lib/io/src/file_operations.cpp	/^namespace minix::io {$/;"	n	class:minix	file:
io	lib/io/src/file_stream.cpp	/^namespace minix::io {$/;"	n	class:minix	file:
io	lib/io/src/memory_stream.cpp	/^namespace minix::io {$/;"	n	class:minix	file:
io	lib/io/src/standard_streams.cpp	/^namespace minix::io {$/;"	n	class:minix	file:
io_buffer	commands/tar.cpp	/^char io_buffer[BLOCK_SIZE];$/;"	v
io_flag	include/sh.hpp	/^    short io_flag; \/* action (below) *\/$/;"	m	struct:ioword
io_here	include/sh.hpp	/^        struct block *io_here; \/* here structure pointer *\/$/;"	m	union:ioword::__anon20	typeref:struct:ioword::__anon20::block
io_map_base	kernel/idt64.cpp	/^    u16_t io_map_base;$/;"	m	struct:tss64	file:
io_name	include/sh.hpp	/^        char *io_name;         \/* file name *\/$/;"	m	union:ioword::__anon20
io_un	include/sh.hpp	/^    } io_un;$/;"	m	struct:ioword	typeref:union:ioword::__anon20
io_unit	include/sh.hpp	/^    short io_unit; \/* unit affected *\/$/;"	m	struct:ioword
ioact	include/sh.hpp	/^    struct ioword **ioact; \/* IO actions (eg, < > >>) *\/$/;"	m	struct:op	typeref:struct:op::ioword
ioarg	include/sh.hpp	/^struct ioarg {$/;"	s
iobase	include/sh.hpp	/^    struct io *iobase;$/;"	m	struct:env	typeref:struct:env::io
ioctl	lib/ioctl.cpp	/^int ioctl($/;"	f
iofd	include/sh.hpp	/^    int iofd;$/;"	m	struct:env
ioflags	fs/param.hpp	13;"	d
iofn	include/sh.hpp	/^    int (*iofn)();$/;"	m	struct:io
iolist	include/sh.hpp	/^struct wdblock *iolist;$/;"	v	typeref:struct:wdblock
iop	commands/sh3.cpp	/^iosetup(iop, pipein, pipeout) register struct ioword *iop;$/;"	v	typeref:struct:ioword
iop	commands/sh5.cpp	/^struct io *iop;$/;"	v	typeref:struct:io
iop	commands/sh5.cpp	/^struct ioword *iop;$/;"	v	typeref:struct:ioword
iop	include/sh.hpp	/^    struct io *iop;$/;"	m	struct:env	typeref:struct:env::io
iop	lib/putc.cpp	/^FILE *iop;$/;"	v
iop	lib/setbuf.cpp	/^setbuf(iop, buffer) FILE *iop;$/;"	v
iop	lib/ungetc.cpp	/^FILE *iop;$/;"	v
iostack	include/sh.hpp	/^struct io iostack[NPUSH];$/;"	v	typeref:struct:io
iounit	commands/sh2.cpp	/^static int iounit = IODEFAULT;$/;"	v	file:
ioword	include/sh.hpp	/^struct ioword {$/;"	s
ip	commands/sh5.cpp	/^struct io *ip;$/;"	v	typeref:struct:io
ip	fs/pipe.cpp	/^register struct inode *ip; \/* inode of pipe *\/$/;"	v	typeref:struct:inode
ip	fs/super.cpp	/^struct inode *ip; \/* pointer to inode whose superblock needed *\/$/;"	v	typeref:struct:inode
ip_reg	tools/c86/dos2out.cpp	/^	unsigned int	ip_reg;		\/* ip value (program entry-point) *\/$/;"	m	struct:d_fmt_hdr	file:
is	commands/dd.cpp	/^static Boolean is(char *pc) {$/;"	f	file:
is_busy	commands/mined1.cpp	1142;"	d	file:
is_crashing_file	tools/run_clang_tidy.sh	/^is_crashing_file() {$/;"	f
is_dir	commands/dosread.cpp	82;"	d	file:
is_error_code_enum	include/minix/fs_error.hpp	/^    struct is_error_code_enum<ErrorCode> : true_type {};$/;"	s	namespace:std
is_executable	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool is_executable = false;        \/\/ region may contain code$/;"	m	struct:psd::vm::semantic_traits
is_executable	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool is_executable = false;$/;"	m	struct:psd::vm::semantic_traits
is_executable	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool is_executable = true;$/;"	m	struct:psd::vm::semantic_traits
is_set	tools/fsck.cpp	/^    [[nodiscard]] bool is_set(BitNumber bit) const {$/;"	f	class:minix::fsck::ZoneLevel::Bitmap
is_shareable	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool is_shareable = false;         \/\/ region can be shared$/;"	m	struct:psd::vm::semantic_traits
is_shareable	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool is_shareable = false;$/;"	m	struct:psd::vm::semantic_traits
is_shareable	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool is_shareable = true;$/;"	m	struct:psd::vm::semantic_traits
is_tab	commands/mined.hpp	200;"	d
is_tab	include/mined.hpp	193;"	d
is_unit	common/math/octonion.cpp	/^bool Octonion::is_unit(double tolerance) const {$/;"	f	class:Common::Math::Octonion
is_unit	common/math/quaternion.cpp	/^bool Quaternion::is_unit(double tolerance) const {$/;"	f	class:Common::Math::Quaternion
is_unit	common/math/sedenion.cpp	/^bool Sedenion::is_unit(double tolerance) const {$/;"	f	class:Common::Math::Sedenion
is_zero_copy_capable	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool is_zero_copy_capable = false; \/\/ zero-copy allowed$/;"	m	struct:psd::vm::semantic_traits
is_zero_copy_capable	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool is_zero_copy_capable = false;$/;"	m	struct:psd::vm::semantic_traits
is_zero_copy_capable	include/psd/vm/semantic_memory.hpp	/^    static constexpr bool is_zero_copy_capable = true;$/;"	m	struct:psd::vm::semantic_traits
is_zero_divisor_candidate	common/math/sedenion.cpp	/^bool Sedenion::is_zero_divisor_candidate() const {$/;"	f	class:Common::Math::Sedenion
isbreak	include/sh.hpp	/^int isbreak;$/;"	v
isdigit	commands/date.cpp	/^static int isdigit(char c) {$/;"	f	file:
isfloppy	commands/cp.cpp	/^int isfloppy; \/* set to 1 for cp x \/dev\/fd? *\/$/;"	v
isnull	commands/make.cpp	132;"	d	file:
isr_clock	kernel/mpx64.cpp	/^void isr_clock(void) {$/;"	f
isr_default	kernel/mpx64.cpp	/^void isr_default(void) {$/;"	f
isr_keyboard	kernel/mpx64.cpp	/^void isr_keyboard(void) {$/;"	f
isrequest	commands/roff.cpp	/^int isrequest = 0;$/;"	v
ist	kernel/idt64.cpp	/^    u8_t ist;$/;"	m	struct:idt_entry	file:
ist1	kernel/idt64.cpp	/^    u64_t ist1;$/;"	m	struct:tss64	file:
ist2	kernel/idt64.cpp	/^    u64_t ist2;$/;"	m	struct:tss64	file:
ist3	kernel/idt64.cpp	/^    u64_t ist3;$/;"	m	struct:tss64	file:
ist4	kernel/idt64.cpp	/^    u64_t ist4;$/;"	m	struct:tss64	file:
ist5	kernel/idt64.cpp	/^    u64_t ist5;$/;"	m	struct:tss64	file:
ist6	kernel/idt64.cpp	/^    u64_t ist6;$/;"	m	struct:tss64	file:
ist7	kernel/idt64.cpp	/^    u64_t ist7;$/;"	m	struct:tss64	file:
j	commands/sh4.cpp	/^glob2(i, j) char *i, *j;$/;"	v
j	commands/sh4.cpp	/^glob3(i, j, k) char *i, *j, *k;$/;"	v
joined	commands/ar.cpp	/^    long joined;$/;"	m	union:swabber	file:
k	commands/od.cpp	/^int k;$/;"	v
k	commands/od.cpp	/^wdump(words, k, radix) int words[8], k, radix;$/;"	v
k	commands/roff.cpp	/^int *k;$/;"	v
k	commands/roff.cpp	/^int k;$/;"	v
k	commands/sh4.cpp	/^glob3(i, j, k) char *i, *j, *k;$/;"	v
k	commands/stty.cpp	/^int k;$/;"	v
k	lib/perror.cpp	/^int k = 0;$/;"	v
k	test/test1.cpp	/^child1(k) int k;$/;"	v
kBigNum	commands/dd.cpp	/^constexpr long kBigNum = 2147483647;$/;"	v
kBlockSize	include/minix/fs/const.hpp	/^    static constexpr std::size_t kBlockSize = BlockSize;$/;"	m	struct:minix::fs::FsConstants
kBufSize	commands/sum.cpp	/^constexpr int kBufSize = 512;$/;"	v
kDay	commands/pr.cpp	/^constexpr long kDay = 24L * kHour;$/;"	v
kDefaultLength	commands/pr.cpp	/^constexpr int kDefaultLength = 66;$/;"	v
kDefaultWidth	commands/pr.cpp	/^constexpr int kDefaultWidth = 72;$/;"	v
kDirEntrySize	include/minix/fs/const.hpp	/^    static constexpr std::size_t kDirEntrySize = sizeof(struct dir_struct);$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
kFS	include/lib.hpp	/^inline constexpr int kFS = FS;$/;"	v
kFsStackBytes	include/minix/fs/const.hpp	/^    static constexpr std::size_t kFsStackBytes = 512;$/;"	m	struct:minix::fs::FsConstants
kHashSize	include/minix/fs/buffer.hpp	/^    static constexpr std::size_t kHashSize = DefaultFsConstants::kNrBufHash;$/;"	m	class:minix::fs::BufferPool
kHighestZone	h/type.hpp	/^inline constexpr zone_nr kHighestZone = 0177777;$/;"	v
kHour	commands/pr.cpp	/^constexpr long kHour = 60L * kMinute;$/;"	v
kInodeSize	include/minix/fs/const.hpp	/^    static constexpr std::size_t kInodeSize = sizeof(struct d_inode);$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
kInodesPerBlock	include/minix/fs/const.hpp	/^    static constexpr std::size_t kInodesPerBlock = kBlockSize \/ kInodeSize;$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
kIntsPerBlock	include/minix/fs/const.hpp	/^    static constexpr std::size_t kIntsPerBlock = kBlockSize \/ sizeof(std::int32_t);$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
kLeapYear	commands/pr.cpp	/^constexpr long kLeapYear = 366L * kDay;$/;"	v
kMM	include/lib.hpp	/^inline constexpr int kMM = MM;$/;"	v
kMaxBlockNr	h/type.hpp	/^inline constexpr block_nr kMaxBlockNr = 0177777;$/;"	v
kMaxDigits	lib/doprintf.cpp	/^inline constexpr int kMaxDigits = 12;$/;"	v
kMaxInodeNr	h/type.hpp	/^inline constexpr inode_nr kMaxInodeNr = 0177777; \/* highest inode number *\/$/;"	v
kMaxPLong	h/const.hpp	/^inline constexpr std::int32_t kMaxPLong = 2147483647; \/\/ maximum positive signed 32-bit long$/;"	v
kMessSize	h/type.hpp	/^inline constexpr std::size_t kMessSize = sizeof(message);$/;"	v
kMinute	commands/pr.cpp	/^constexpr long kMinute = 60L;$/;"	v
kNameSize	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNameSize = 14;$/;"	m	struct:minix::fs::FsConstants
kNilMess	h/type.hpp	/^inline constexpr message *kNilMess = nullptr;$/;"	v
kNrBufHash	fs/const.hpp	/^inline constexpr int kNrBufHash = 32;              \/\/ C++23 constant$/;"	v
kNrBufHash	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrBufHash = 32;$/;"	m	struct:minix::fs::FsConstants
kNrBufs	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrBufs = 20;$/;"	m	struct:minix::fs::FsConstants
kNrDirEntries	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrDirEntries = kBlockSize \/ kDirEntrySize;$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
kNrDzoneNum	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrDzoneNum = kNrZoneNums - 2;$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
kNrFds	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrFds = 20;$/;"	m	struct:minix::fs::FsConstants
kNrFilps	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrFilps = 64;$/;"	m	struct:minix::fs::FsConstants
kNrIndirects	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrIndirects = kBlockSize \/ kZoneNumSize;$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
kNrInodes	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrInodes = 32;$/;"	m	struct:minix::fs::FsConstants
kNrSupers	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrSupers = 5;$/;"	m	struct:minix::fs::FsConstants
kNrZoneNums	include/minix/fs/const.hpp	/^    static constexpr std::size_t kNrZoneNums = 9;$/;"	m	struct:minix::fs::FsConstants
kOneShot	include/minix/fs/const.hpp	/^inline constexpr std::uint8_t kOneShot = 0200;$/;"	m	namespace:minix::fs::FsConstants::IoMode::DirOp::BlockType::BlockFlags
kPipeSize	include/minix/fs/const.hpp	/^    static constexpr std::size_t kPipeSize = kNrDzoneNum * kBlockSize;$/;"	m	class:minix::fs::FsConstants::IoMode::DirOp::BufferState
kPoolSize	include/minix/fs/buffer.hpp	/^    static constexpr std::size_t kPoolSize = DefaultFsConstants::kNrBufs;$/;"	m	class:minix::fs::BufferPool
kSuperMagic	include/minix/fs/const.hpp	/^    static constexpr std::uint16_t kSuperMagic = 0x137F;$/;"	m	struct:minix::fs::FsConstants
kTableSize	include/minix/fs/inode.hpp	/^    static constexpr std::size_t kTableSize = DefaultFsConstants::kNrInodes;$/;"	m	class:minix::fs::InodeType::InodeTable
kWriteImmed	include/minix/fs/const.hpp	/^inline constexpr std::uint8_t kWriteImmed = 0100;$/;"	m	namespace:minix::fs::FsConstants::IoMode::DirOp::BlockType::BlockFlags
kYear	commands/pr.cpp	/^constexpr long kYear = 365L * kDay;$/;"	v
kZoneNumSize	include/minix/fs/const.hpp	/^    static constexpr std::size_t kZoneNumSize = sizeof(zone_nr);$/;"	m	struct:minix::fs::FsConstants
k_stack	kernel/glo.hpp	/^EXTERN char k_stack[K_STACK_BYTES]; \/* The kernel stack. *\/$/;"	v
keccak_absorb	crypto/kyber_impl/fips202.c	/^static unsigned int keccak_absorb(uint64_t s[25],$/;"	f	file:
keccak_absorb_once	crypto/kyber_impl/fips202.c	/^static void keccak_absorb_once(uint64_t s[25],$/;"	f	file:
keccak_finalize	crypto/kyber_impl/fips202.c	/^static void keccak_finalize(uint64_t s[25], unsigned int pos, unsigned int r, uint8_t p)$/;"	f	file:
keccak_init	crypto/kyber_impl/fips202.c	/^static void keccak_init(uint64_t s[25])$/;"	f	file:
keccak_squeeze	crypto/kyber_impl/fips202.c	/^static unsigned int keccak_squeeze(uint8_t *out,$/;"	f	file:
keccak_squeezeblocks	crypto/kyber_impl/fips202.c	/^static void keccak_squeezeblocks(uint8_t *out,$/;"	f	file:
keccak_state	crypto/kyber_impl/fips202.h	/^} keccak_state;$/;"	t	typeref:struct:__anon23
kernel_page_directory	vmm.cpp	/^static pde_t* kernel_page_directory = NULL;$/;"	v	file:
kernel_page_directory_phys	vmm.cpp	/^static uintptr_t kernel_page_directory_phys = 0;$/;"	v	file:
kernel_pml4	kernel/paging.cpp	/^static struct pml4 kernel_pml4; \/\/ PRIVATE -> static$/;"	v	typeref:struct:pml4	file:
kernel_tss	kernel/idt64.cpp	/^static struct tss64 kernel_tss;$/;"	v	typeref:struct:tss64	file:
key	commands/sh3.cpp	/^int key;$/;"	v
key_map	commands/mined1.cpp	/^int (*key_map[128])() = {\/* map ASCII characters to functions *\/$/;"	v
key_map	commands/mined1.cpp	/^int (*key_map[256])() = {\/* map ASCII characters to functions *\/$/;"	v
keybd_mess	kernel/tty.cpp	/^PUBLIC message keybd_mess; \/* message used for console input chars *\/$/;"	v
keyboard	kernel/tty.cpp	/^PUBLIC keyboard() {$/;"	f
keypair	crypto/kyber.cpp	/^KeyPair keypair() {$/;"	f	namespace:pq::kyber
kfile	commands/cc.cpp	/^USTRING ifile, kfile, sfile, mfile, ofile;$/;"	v
kill	lib/kill.cpp	/^int kill(int proc, int sig) { return callm1(MM, KILL, proc, sig, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
kill_sig	mm/param.hpp	13;"	d
kk	test/test2.cpp	/^int kk = 0;$/;"	v
kmain	kernel.cpp	/^extern "C" void kmain(unsigned long multiboot_magic, unsigned long multiboot_addr) {$/;"	f
knowhow	commands/make.cpp	/^int knowhow = FALSE;$/;"	v
kyber	crypto/kyber.cpp	/^namespace pq::kyber {$/;"	n	class:pq	file:
kyber	crypto/kyber.hpp	/^namespace pq::kyber {$/;"	n	class:pq
kyber_shake128_absorb	crypto/kyber_impl/symmetric-shake.c	/^void kyber_shake128_absorb(keccak_state *state,$/;"	f
kyber_shake128_absorb	crypto/kyber_impl/symmetric.h	12;"	d
kyber_shake256_prf	crypto/kyber_impl/symmetric-shake.c	/^void kyber_shake256_prf(uint8_t *out, size_t outlen, const uint8_t key[KYBER_SYMBYTES], uint8_t nonce)$/;"	f
kyber_shake256_prf	crypto/kyber_impl/symmetric.h	18;"	d
kyber_shake256_rkprf	crypto/kyber_impl/symmetric-shake.c	/^void kyber_shake256_rkprf(uint8_t out[KYBER_SSBYTES], const uint8_t key[KYBER_SYMBYTES], const uint8_t input[KYBER_CIPHERTEXTBYTES])$/;"	f
kyber_shake256_rkprf	crypto/kyber_impl/symmetric.h	21;"	d
l	commands/Makefile	/^l=..\/lib$/;"	m
l	commands/od.cpp	/^addrout(l) long l;$/;"	v
l	test/minix/Makefile	/^l=..\/lib$/;"	m
l	tools/minix/Makefile	/^l=..\/lib$/;"	m
label	commands/dosread.cpp	79;"	d	file:
last_access	tools/diskio.hpp	/^        std::chrono::steady_clock::time_point last_access;$/;"	m	struct:DiskInterface::CacheEntry
last_dir	fs/path.cpp	/^struct inode *last_dir(char *path, char string[NAME_SIZE]) {$/;"	f
last_exp	commands/mined2.cpp	/^int *last_exp;$/;"	v
last_index	commands/pwd.cpp	/^static char *last_index(char *string, char ch) {$/;"	f	file:
last_line	commands/sort.cpp	/^last_line() {$/;"	f
last_page_size	tools/c86/dos2out.cpp	/^	unsigned int	last_page_size; \/* size of last page *\/$/;"	m	struct:d_fmt_hdr	file:
last_y	commands/mined1.cpp	/^int last_y;               \/* Last y of screen. Usually SCREENMAX *\/$/;"	v
lastname	commands/ls.cpp	/^char lastname[10];$/;"	v
lastp	commands/mkfs.cpp	/^char zero[BLOCK_SIZE], *lastp;$/;"	v
lastp	tools/mkfs.cpp	/^char zero[BLOCK_SIZE], *lastp;$/;"	v
lastpid	commands/sh3.cpp	/^register int lastpid;$/;"	v
lastuid	commands/ls.cpp	/^int lastuid = -1;$/;"	v
lattice	kernel/fano_octonion.hpp	/^namespace lattice {$/;"	n
lattice	kernel/lattice_ipc.cpp	/^namespace lattice {$/;"	n	file:
lattice	kernel/lattice_ipc.hpp	/^namespace lattice {$/;"	n
lattice	kernel/octonion.hpp	/^namespace lattice {$/;"	n
lattice	kernel/octonion_math.hpp	/^namespace lattice {$/;"	n
lattice	kernel/wait_graph.cpp	/^namespace lattice {$/;"	n	file:
lattice	kernel/wait_graph.hpp	/^namespace lattice {$/;"	n
lattice_connect	kernel/lattice_ipc.cpp	/^int lattice_connect(xinim::pid_t src, xinim::pid_t dst, net::node_t node_id) {$/;"	f	namespace:lattice
lattice_listen	kernel/lattice_ipc.cpp	/^void lattice_listen(xinim::pid_t pid) { g_graph.set_listening(pid, true); }$/;"	f	namespace:lattice
lattice_recv	kernel/lattice_ipc.cpp	/^int lattice_recv(xinim::pid_t pid, message *out, IpcFlags flags) {$/;"	f	namespace:lattice
lattice_send	kernel/lattice_ipc.cpp	/^int lattice_send(xinim::pid_t src, xinim::pid_t dst, const message &msg, IpcFlags flags) {$/;"	f	namespace:lattice
lcount	commands/wc.cpp	/^long lcount; \/* Count of lines *\/$/;"	v
lct	commands/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
lct	tools/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
ldfmt	commands/mkfs.cpp	/^char *ldfmt = "%6ld";$/;"	v
ldfmt	tools/mkfs.cpp	/^char *ldfmt = "%6ld";$/;"	v
ldmode	commands/mkfs.cpp	/^char *ldmode = "%06o";$/;"	v
ldmode	tools/mkfs.cpp	/^char *ldmode = "%06o";$/;"	v
ldsign	tools/c86/dos2out.cpp	/^	unsigned int 	ldsign;		\/* linker signature, 5A4Dh *\/$/;"	m	struct:d_fmt_hdr	file:
leave	commands/dosread.cpp	/^static void leave(short nr) {$/;"	f	file:
leave	commands/sh1.cpp	/^void leave() {$/;"	f
leave_fl	commands/dosread.cpp	/^BOOL leave_fl;$/;"	v
left	include/sh.hpp	/^    struct op *left;$/;"	m	struct:op	typeref:struct:op::op
legacy	include/minix/fs/const.hpp	/^namespace legacy {$/;"	n	class:minix::fs::FsConstants::IoMode::DirOp
legal	commands/mined2.cpp	/^legal() {$/;"	f
len	commands/make.cpp	/^int len;$/;"	v
len	commands/mined2.cpp	/^int len;$/;"	v
len	fs/stadir.cpp	/^int len;            \/* length of the directory name string *\/$/;"	v
len	kernel/floppy.cpp	/^PRIVATE char len[] = {-1, 0, 1, -1, 2, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 4};$/;"	v
len	mm/alloc.cpp	/^    uint64_t len;  \/\/\/< Length of the hole in clicks.$/;"	m	struct:Hole	file:
len	multiboot.h	/^    uint64_t len;$/;"	m	struct:multiboot_mmap_entry
length	commands/mined1.cpp	/^int length;$/;"	v
length	commands/pr.cpp	/^short length = kDefaultLength;$/;"	v
level1	test/test9.cpp	/^level1() {$/;"	f
level2	test/test9.cpp	/^level2() {$/;"	f
lext	commands/make.cpp	/^add_s_suff(lext) char *lext;$/;"	v
lflag	commands/cmp.cpp	/^unshort lflag, sflag;$/;"	v
lflag	commands/wc.cpp	/^int lflag; \/* Count lines *\/$/;"	v
library	commands/cc.cpp	89;"	d	file:
lim	commands/sh4.cpp	/^glob1(base, lim) char *base, *lim;$/;"	v
limit	kernel/idt64.cpp	/^    u16_t limit;$/;"	m	struct:idt_ptr	file:
limit_file	commands/sort.cpp	/^merge(start_file, limit_file) int start_file, limit_file;$/;"	v
lin	commands/make.cpp	/^add_suff(lin) char *lin;$/;"	v
line	commands/make.cpp	/^char *fword, *restline, line[INMAX], backup[INMAX];$/;"	v
line	commands/mined1.cpp	/^LINE *line;$/;"	v
line	commands/mined1.cpp	/^count_chars(line) LINE *line;$/;"	v
line	commands/mined1.cpp	/^find_x(line, address) LINE *line;$/;"	v
line	commands/mined1.cpp	/^put_line(line, offset, clear_line) LINE *line; \/* Line to print *\/$/;"	v
line	commands/mined1.cpp	/^register LINE *line;$/;"	v
line	commands/mined2.cpp	/^LINE *line;$/;"	v
line	commands/mined2.cpp	/^insert(line, location, string) register LINE *line;$/;"	v
line	commands/mined2.cpp	/^register LINE *line;$/;"	v
line	commands/mkfs.cpp	/^char line[LINE_LEN];$/;"	v
line	commands/sort.cpp	/^    char *line;     \/* Contains line currently used *\/$/;"	m	struct:MERGE	file:
line	commands/sort.cpp	/^length(line) register char *line;$/;"	v
line	commands/sort.cpp	/^put_line(line) register char *line;$/;"	v
line	include/sh.hpp	/^char line[LINELIM];$/;"	v
line	tools/mkfs.cpp	/^char line[LINE_LEN];$/;"	v
line_no	commands/roff.cpp	/^int line_no = 9999;$/;"	v
line_number	commands/mined1.cpp	/^line_number() {$/;"	f
line_print	commands/mined.hpp	/^inline void line_print(LINE *line) { put_line(line, 0, TRUE); }$/;"	f	class:ReturnCode
line_print	include/mined.hpp	/^inline void line_print(struct Line *line) { put_line(line, 0, TRUE); }$/;"	f	class:ReturnCode
line_table	commands/sort.cpp	/^char **line_table;   \/* Pointer to the internal line table *\/$/;"	v
linebuf	commands/ls.cpp	/^char linebuf[BLOCK_SIZE]; \/* for reading passwd file *\/$/;"	v
linecont	commands/make.cpp	/^char linecont = '+';    \/* default line continuation character *\/$/;"	v
linecont	commands/make.cpp	/^char linecont = '\\\\'; \/* default line continuation character *\/$/;"	v
linelimit	commands/ls.cpp	/^int linelimit;$/;"	v
linenext	commands/ls.cpp	/^int linenext;$/;"	v
linenr	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
linenr	tools/init.cpp	/^startup(linenr) int linenr;$/;"	v
linep	include/sh.hpp	/^    char *linep;$/;"	m	struct:env
lines	commands/comm.cpp	/^char lines[2][LINMAX];$/;"	v
lines	commands/mined1.cpp	/^int lines;$/;"	v
lines	commands/tail.cpp	/^int lines, chars;$/;"	v
lines_saved	commands/mined2.cpp	/^int lines_saved; \/* Nr of lines in buffer *\/$/;"	v
link	commands/ls.cpp	/^    short link;$/;"	m	struct:file	file:
link	lib/link.cpp	/^int link(const char *name, const char *name2) {$/;"	f
link	tools/c86/_build.bat	/^:link$/;"	l
link	tools/c86/_dos2out.bat	/^:link$/;"	l
link	tools/c86/_fsck.bat	/^:link$/;"	l
link	tools/c86/_init.bat	/^:link$/;"	l
link	tools/c86/_mkfs.bat	/^:link$/;"	l
linkerf	commands/make.cpp	/^int linkerf = TRUE;$/;"	v
links	include/minix/fs/const.hpp	/^enum class links : std::uint8_t {};$/;"	c	namespace:minix::fs
list	commands/mined2.cpp	/^in_list(list, c, list_length, opcode) register int *list;$/;"	v
list_dir	commands/dosread.cpp	78;"	d	file:
list_directory	tools/ascii_tree.py	/^def list_directory($/;"	f
list_length	commands/mined2.cpp	/^register int list_length;$/;"	v
listening_	kernel/lattice_ipc.hpp	/^    std::unordered_map<xinim::pid_t, bool> listening_; \/\/!< listen state per pid$/;"	m	class:lattice::Graph
litoa	commands/ar.cpp	/^static void litoa(int pad, long number) {$/;"	f	file:
llist	commands/make.cpp	/^struct llist {$/;"	s	file:
load	kernel/service.cpp	/^void ServiceManager::load(std::string_view path) {$/;"	f	class:svc::ServiceManager
load24_littleendian	crypto/kyber_impl/cbd.c	/^static uint32_t load24_littleendian(const uint8_t x[3])$/;"	f	file:
load32_littleendian	crypto/kyber_impl/cbd.c	/^static uint32_t load32_littleendian(const uint8_t x[4])$/;"	f	file:
load64	crypto/kyber_impl/fips202.c	/^static uint64_t load64(const uint8_t x[8]) {$/;"	f	file:
load_from_disk	tools/fsck.cpp	/^    void load_from_disk(diskio::DiskInterface &disk) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
load_from_disk	tools/fsck.cpp	/^    void load_from_disk(diskio::DiskInterface &disk, const SuperBlock &sb) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
load_from_disk	tools/fsck.cpp	/^    void load_from_disk(diskio::DiskInterface &disk, diskio::SectorAddress start_block,$/;"	f	class:minix::fsck::ZoneLevel::Bitmap
load_from_inode	tools/fsck.cpp	/^    void load_from_inode(diskio::DiskInterface &disk, const SuperBlock &sb,$/;"	f	class:minix::fsck::ZoneLevel::DirectoryEntry
load_ram	fs/main.cpp	/^static void load_ram() {$/;"	f	file:
load_seg	mm/exec.cpp	/^PRIVATE void load_seg(int fd, int seg, std::size_t seg_bytes)$/;"	f
load_super	fs/main.cpp	/^static void load_super() {$/;"	f	file:
loading	commands/mined1.cpp	/^FLAG loading;                \/* Set if we are loading a file. *\/$/;"	v
location	commands/mined2.cpp	/^char *location, *string;$/;"	v
lock	kernel/quaternion_spinlock.hpp	/^    QuaternionSpinlock &lock; \/\/\/< Referenced spinlock$/;"	m	class:hyper::QuaternionLockGuard
lockvar	kernel/klib64.cpp	/^static u64_t lockvar;$/;"	v	file:
lockvar	kernel/klib88.cpp	/^PUBLIC unsigned lockvar = 0;$/;"	v
lost_ticks	kernel/glo.hpp	/^    lost_ticks; \/* incremented when clock int can't send mess, (real_time -> xinim::time_t) *\/$/;"	v
lpr_int	kernel/mpx64.cpp	/^void lpr_int(void) {$/;"	f
ls_fd	fs/param.hpp	16;"	d
lseek	lib/lseek.cpp	/^long lseek(int fd, long offset, int whence) {$/;"	f
ltotal	commands/wc.cpp	/^long ltotal; \/* Total count of lines *\/$/;"	v
m	commands/make.cpp	/^TIME m;                 \/* time of modification *\/$/;"	v
m	commands/tar.cpp	/^    struct m {$/;"	s	union:HEADER	file:
m	fs/glo.hpp	/^EXTERN message m;                \/* the input message itself *\/$/;"	v
m	kernel/system.cpp	/^PRIVATE message m;                      \/\/ Global message buffer, used by some functions here$/;"	v
m	tools/c86/_fsck.bat	/^:m$/;"	l
m1	fs/glo.hpp	/^EXTERN message m1;               \/* the output message used for reply *\/$/;"	v
m1_i1	h/type.hpp	/^    constexpr const int &m1_i1() const { return m_u.m_m1.m1i1; }$/;"	f	struct:message
m1_i1	h/type.hpp	/^    constexpr int &m1_i1() { return m_u.m_m1.m1i1; }$/;"	f	struct:message
m1_i2	h/type.hpp	/^    constexpr const int &m1_i2() const { return m_u.m_m1.m1i2; }$/;"	f	struct:message
m1_i2	h/type.hpp	/^    constexpr int &m1_i2() { return m_u.m_m1.m1i2; }$/;"	f	struct:message
m1_i3	h/type.hpp	/^    constexpr const int &m1_i3() const { return m_u.m_m1.m1i3; }$/;"	f	struct:message
m1_i3	h/type.hpp	/^    constexpr int &m1_i3() { return m_u.m_m1.m1i3; }$/;"	f	struct:message
m1_p1	h/type.hpp	/^    constexpr char *&m1_p1() { return m_u.m_m1.m1p1; }$/;"	f	struct:message
m1_p1	h/type.hpp	/^    constexpr char *const &m1_p1() const { return m_u.m_m1.m1p1; }$/;"	f	struct:message
m1_p2	h/type.hpp	/^    constexpr char *&m1_p2() { return m_u.m_m1.m1p2; }$/;"	f	struct:message
m1_p2	h/type.hpp	/^    constexpr char *const &m1_p2() const { return m_u.m_m1.m1p2; }$/;"	f	struct:message
m1_p3	h/type.hpp	/^    constexpr char *&m1_p3() { return m_u.m_m1.m1p3; }$/;"	f	struct:message
m1_p3	h/type.hpp	/^    constexpr char *const &m1_p3() const { return m_u.m_m1.m1p3; }$/;"	f	struct:message
m1i1	h/type.hpp	/^    int m1i1, m1i2, m1i3;$/;"	m	struct:mess_1
m1i2	h/type.hpp	/^    int m1i1, m1i2, m1i3;$/;"	m	struct:mess_1
m1i3	h/type.hpp	/^    int m1i1, m1i2, m1i3;$/;"	m	struct:mess_1
m1p1	h/type.hpp	/^    char *m1p1, *m1p2, *m1p3;$/;"	m	struct:mess_1
m1p2	h/type.hpp	/^    char *m1p1, *m1p2, *m1p3;$/;"	m	struct:mess_1
m1p3	h/type.hpp	/^    char *m1p1, *m1p2, *m1p3;$/;"	m	struct:mess_1
m24	kernel/tty.cpp	/^PRIVATE char m24[] = {0,    033,  '!',  '"',  '#',  '$',  '%',  '&',  047,  '(',  ')',  '_',  '=',$/;"	v
m2_i1	h/type.hpp	/^    constexpr const int &m2_i1() const { return m_u.m_m2.m2i1; }$/;"	f	struct:message
m2_i1	h/type.hpp	/^    constexpr int &m2_i1() { return m_u.m_m2.m2i1; }$/;"	f	struct:message
m2_i2	h/type.hpp	/^    constexpr const int &m2_i2() const { return m_u.m_m2.m2i2; }$/;"	f	struct:message
m2_i2	h/type.hpp	/^    constexpr int &m2_i2() { return m_u.m_m2.m2i2; }$/;"	f	struct:message
m2_i3	h/type.hpp	/^    constexpr const int &m2_i3() const { return m_u.m_m2.m2i3; }$/;"	f	struct:message
m2_i3	h/type.hpp	/^    constexpr int &m2_i3() { return m_u.m_m2.m2i3; }$/;"	f	struct:message
m2_l1	h/type.hpp	/^    constexpr const int64_t &m2_l1() const { return m_u.m_m2.m2l1; }$/;"	f	struct:message
m2_l1	h/type.hpp	/^    constexpr int64_t &m2_l1() { return m_u.m_m2.m2l1; }$/;"	f	struct:message
m2_l2	h/type.hpp	/^    constexpr const int64_t &m2_l2() const { return m_u.m_m2.m2l2; }$/;"	f	struct:message
m2_l2	h/type.hpp	/^    constexpr int64_t &m2_l2() { return m_u.m_m2.m2l2; }$/;"	f	struct:message
m2_p1	h/type.hpp	/^    constexpr char *&m2_p1() { return m_u.m_m2.m2p1; }$/;"	f	struct:message
m2_p1	h/type.hpp	/^    constexpr char *const &m2_p1() const { return m_u.m_m2.m2p1; }$/;"	f	struct:message
m2i1	h/type.hpp	/^    int m2i1, m2i2, m2i3;$/;"	m	struct:mess_2
m2i2	h/type.hpp	/^    int m2i1, m2i2, m2i3;$/;"	m	struct:mess_2
m2i3	h/type.hpp	/^    int m2i1, m2i2, m2i3;$/;"	m	struct:mess_2
m2l1	h/type.hpp	/^    int64_t m2l1, m2l2;$/;"	m	struct:mess_2
m2l2	h/type.hpp	/^    int64_t m2l1, m2l2;$/;"	m	struct:mess_2
m2p1	h/type.hpp	/^    char *m2p1;$/;"	m	struct:mess_2
m3_ca1	h/type.hpp	/^    constexpr char *m3_ca1() { return m_u.m_m3.m3ca1; }$/;"	f	struct:message
m3_ca1	h/type.hpp	/^    constexpr const char *m3_ca1() const { return m_u.m_m3.m3ca1; }$/;"	f	struct:message
m3_i1	h/type.hpp	/^    constexpr const int &m3_i1() const { return m_u.m_m3.m3i1; }$/;"	f	struct:message
m3_i1	h/type.hpp	/^    constexpr int &m3_i1() { return m_u.m_m3.m3i1; }$/;"	f	struct:message
m3_i2	h/type.hpp	/^    constexpr const int &m3_i2() const { return m_u.m_m3.m3i2; }$/;"	f	struct:message
m3_i2	h/type.hpp	/^    constexpr int &m3_i2() { return m_u.m_m3.m3i2; }$/;"	f	struct:message
m3_p1	h/type.hpp	/^    constexpr char *&m3_p1() { return m_u.m_m3.m3p1; }$/;"	f	struct:message
m3_p1	h/type.hpp	/^    constexpr char *const &m3_p1() const { return m_u.m_m3.m3p1; }$/;"	f	struct:message
m3ca1	h/type.hpp	/^    char m3ca1[M3_STRING];$/;"	m	struct:mess_3
m3i1	h/type.hpp	/^    int m3i1, m3i2;$/;"	m	struct:mess_3
m3i2	h/type.hpp	/^    int m3i1, m3i2;$/;"	m	struct:mess_3
m3p1	h/type.hpp	/^    char *m3p1;$/;"	m	struct:mess_3
m4_l1	h/type.hpp	/^    constexpr const int64_t &m4_l1() const { return m_u.m_m4.m4l1; }$/;"	f	struct:message
m4_l1	h/type.hpp	/^    constexpr int64_t &m4_l1() { return m_u.m_m4.m4l1; }$/;"	f	struct:message
m4_l2	h/type.hpp	/^    constexpr const int64_t &m4_l2() const { return m_u.m_m4.m4l2; }$/;"	f	struct:message
m4_l2	h/type.hpp	/^    constexpr int64_t &m4_l2() { return m_u.m_m4.m4l2; }$/;"	f	struct:message
m4_l3	h/type.hpp	/^    constexpr const int64_t &m4_l3() const { return m_u.m_m4.m4l3; }$/;"	f	struct:message
m4_l3	h/type.hpp	/^    constexpr int64_t &m4_l3() { return m_u.m_m4.m4l3; }$/;"	f	struct:message
m4_l4	h/type.hpp	/^    constexpr const int64_t &m4_l4() const { return m_u.m_m4.m4l4; }$/;"	f	struct:message
m4_l4	h/type.hpp	/^    constexpr int64_t &m4_l4() { return m_u.m_m4.m4l4; }$/;"	f	struct:message
m4l1	h/type.hpp	/^    int64_t m4l1, m4l2, m4l3, m4l4;$/;"	m	struct:mess_4
m4l2	h/type.hpp	/^    int64_t m4l1, m4l2, m4l3, m4l4;$/;"	m	struct:mess_4
m4l3	h/type.hpp	/^    int64_t m4l1, m4l2, m4l3, m4l4;$/;"	m	struct:mess_4
m4l4	h/type.hpp	/^    int64_t m4l1, m4l2, m4l3, m4l4;$/;"	m	struct:mess_4
m5_c1	h/type.hpp	/^    constexpr char &m5_c1() { return m_u.m_m5.m5c1; }$/;"	f	struct:message
m5_c1	h/type.hpp	/^    constexpr const char &m5_c1() const { return m_u.m_m5.m5c1; }$/;"	f	struct:message
m5_c2	h/type.hpp	/^    constexpr char &m5_c2() { return m_u.m_m5.m5c2; }$/;"	f	struct:message
m5_c2	h/type.hpp	/^    constexpr const char &m5_c2() const { return m_u.m_m5.m5c2; }$/;"	f	struct:message
m5_i1	h/type.hpp	/^    constexpr const int &m5_i1() const { return m_u.m_m5.m5i1; }$/;"	f	struct:message
m5_i1	h/type.hpp	/^    constexpr int &m5_i1() { return m_u.m_m5.m5i1; }$/;"	f	struct:message
m5_i2	h/type.hpp	/^    constexpr const int &m5_i2() const { return m_u.m_m5.m5i2; }$/;"	f	struct:message
m5_i2	h/type.hpp	/^    constexpr int &m5_i2() { return m_u.m_m5.m5i2; }$/;"	f	struct:message
m5_l1	h/type.hpp	/^    constexpr const int64_t &m5_l1() const { return m_u.m_m5.m5l1; }$/;"	f	struct:message
m5_l1	h/type.hpp	/^    constexpr int64_t &m5_l1() { return m_u.m_m5.m5l1; }$/;"	f	struct:message
m5_l2	h/type.hpp	/^    constexpr const int64_t &m5_l2() const { return m_u.m_m5.m5l2; }$/;"	f	struct:message
m5_l2	h/type.hpp	/^    constexpr int64_t &m5_l2() { return m_u.m_m5.m5l2; }$/;"	f	struct:message
m5_l3	h/type.hpp	/^    constexpr const int64_t &m5_l3() const { return m_u.m_m5.m5l3; }$/;"	f	struct:message
m5_l3	h/type.hpp	/^    constexpr int64_t &m5_l3() { return m_u.m_m5.m5l3; }$/;"	f	struct:message
m5c1	h/type.hpp	/^    char m5c1, m5c2;$/;"	m	struct:mess_5
m5c2	h/type.hpp	/^    char m5c1, m5c2;$/;"	m	struct:mess_5
m5i1	h/type.hpp	/^    int m5i1, m5i2;$/;"	m	struct:mess_5
m5i2	h/type.hpp	/^    int m5i1, m5i2;$/;"	m	struct:mess_5
m5l1	h/type.hpp	/^    int64_t m5l1, m5l2, m5l3;$/;"	m	struct:mess_5
m5l2	h/type.hpp	/^    int64_t m5l1, m5l2, m5l3;$/;"	m	struct:mess_5
m5l3	h/type.hpp	/^    int64_t m5l1, m5l2, m5l3;$/;"	m	struct:mess_5
m6_f1	h/type.hpp	/^    constexpr int (*&m6_f1())() { return m_u.m_m6.m6f1; }             \/\/ Modern C-style: int(*)()$/;"	f	struct:message
m6_f1	h/type.hpp	/^    constexpr int (*const &m6_f1() const)() { return m_u.m_m6.m6f1; } \/\/ Modern C-style: int(*)()$/;"	f	struct:message
m6_i1	h/type.hpp	/^    constexpr const int &m6_i1() const { return m_u.m_m6.m6i1; }$/;"	f	struct:message
m6_i1	h/type.hpp	/^    constexpr int &m6_i1() { return m_u.m_m6.m6i1; }$/;"	f	struct:message
m6_i2	h/type.hpp	/^    constexpr const int &m6_i2() const { return m_u.m_m6.m6i2; }$/;"	f	struct:message
m6_i2	h/type.hpp	/^    constexpr int &m6_i2() { return m_u.m_m6.m6i2; }$/;"	f	struct:message
m6_i3	h/type.hpp	/^    constexpr const int &m6_i3() const { return m_u.m_m6.m6i3; }$/;"	f	struct:message
m6_i3	h/type.hpp	/^    constexpr int &m6_i3() { return m_u.m_m6.m6i3; }$/;"	f	struct:message
m6_l1	h/type.hpp	/^    constexpr const int64_t &m6_l1() const { return m_u.m_m6.m6l1; }$/;"	f	struct:message
m6_l1	h/type.hpp	/^    constexpr int64_t &m6_l1() { return m_u.m_m6.m6l1; }$/;"	f	struct:message
m6f1	h/type.hpp	/^    int (*m6f1)();$/;"	m	struct:mess_6
m6i1	h/type.hpp	/^    int m6i1, m6i2, m6i3;$/;"	m	struct:mess_6
m6i2	h/type.hpp	/^    int m6i1, m6i2, m6i3;$/;"	m	struct:mess_6
m6i3	h/type.hpp	/^    int m6i1, m6i2, m6i3;$/;"	m	struct:mess_6
m6l1	h/type.hpp	/^    int64_t m6l1;$/;"	m	struct:mess_6
m_checksum	commands/tar.cpp	/^        char m_checksum[8];$/;"	m	struct:HEADER::m	file:
m_dep	commands/make.cpp	/^    char m_dep[6];$/;"	m	struct:m_preq	file:
m_gid	commands/ar.cpp	/^    char m_gid;$/;"	m	struct:MEMBER	file:
m_gid	commands/tar.cpp	/^        char m_gid[8];$/;"	m	struct:HEADER::m	file:
m_link	commands/tar.cpp	/^        char m_link[NAME_SIZE];$/;"	m	struct:HEADER::m	file:
m_linked	commands/tar.cpp	/^        char m_linked;$/;"	m	struct:HEADER::m	file:
m_m1	h/type.hpp	/^        mess_1 m_m1;$/;"	m	union:message::__anon5
m_m2	h/type.hpp	/^        mess_2 m_m2;$/;"	m	union:message::__anon5
m_m3	h/type.hpp	/^        mess_3 m_m3;$/;"	m	union:message::__anon5
m_m4	h/type.hpp	/^        mess_4 m_m4;$/;"	m	union:message::__anon5
m_m5	h/type.hpp	/^        mess_5 m_m5;$/;"	m	union:message::__anon5
m_m6	h/type.hpp	/^        mess_6 m_m6;$/;"	m	union:message::__anon5
m_mode	commands/ar.cpp	/^    short m_mode;$/;"	m	struct:MEMBER	file:
m_mode	commands/tar.cpp	/^        char m_mode[8];$/;"	m	struct:HEADER::m	file:
m_name	commands/ar.cpp	/^    char m_name[14];$/;"	m	struct:MEMBER	file:
m_name	commands/make.cpp	/^    char m_name[INMAXSH];$/;"	m	struct:m_preq	file:
m_name	commands/tar.cpp	/^        char m_name[NAME_SIZE];$/;"	m	struct:HEADER::m	file:
m_preq	commands/make.cpp	/^struct m_preq {$/;"	s	file:
m_ptr	fs/device.cpp	/^message *m_ptr; \/* message pointer *\/$/;"	v
m_ptr	kernel/printer.cpp	/^message *m_ptr; \/* pointer to the newly arrived message *\/$/;"	v
m_sig	mm/signal.cpp	/^static message m_sig; \/\/ PRIVATE -> static$/;"	v	file:
m_size	commands/tar.cpp	/^        char m_size[12];$/;"	m	struct:HEADER::m	file:
m_size_1	commands/ar.cpp	/^    short m_size_1;$/;"	m	struct:MEMBER	file:
m_size_2	commands/ar.cpp	/^    short m_size_2;$/;"	m	struct:MEMBER	file:
m_source	h/type.hpp	/^    int m_source; \/* who sent the message *\/$/;"	m	struct:message
m_targ	commands/make.cpp	/^    char m_targ[6];$/;"	m	struct:m_preq	file:
m_time	commands/tar.cpp	/^        char m_time[12];$/;"	m	struct:HEADER::m	file:
m_time_1	commands/ar.cpp	/^    short m_time_1;$/;"	m	struct:MEMBER	file:
m_time_2	commands/ar.cpp	/^    short m_time_2;$/;"	m	struct:MEMBER	file:
m_type	h/type.hpp	/^    int m_type;   \/* what kind of message is it *\/$/;"	m	struct:message
m_u	h/type.hpp	/^    } m_u;$/;"	m	struct:message	typeref:union:message::__anon5
m_uid	commands/ar.cpp	/^    char m_uid;$/;"	m	struct:MEMBER	file:
m_uid	commands/tar.cpp	/^        char m_uid[8];$/;"	m	struct:HEADER::m	file:
maccheck	commands/make.cpp	/^static int maccheck(char *sptr) \/* if this string has a '=', then add it as a macro *\/$/;"	f	file:
maclist	commands/make.cpp	/^struct macrec *maclist = NULL;$/;"	v	typeref:struct:macrec
macrec	commands/make.cpp	/^struct macrec {$/;"	s	file:
macro	commands/roff.cpp	/^} macro[MAXMAC];$/;"	v	typeref:struct:macrotype
macrotype	commands/roff.cpp	/^struct macrotype {$/;"	s	file:
madesomething	commands/make.cpp	/^int madesomething = FALSE;$/;"	v
main	commands/ar.cpp	/^int main(int argc, char* argv[]) {$/;"	f	file:
main	commands/basename.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/cal.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/cat.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/cc.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/chmem.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/chmod.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/chown.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/clr.cpp	/^int main(void) {$/;"	f
main	commands/cmp.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/comm.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/cp.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/date.cpp	/^int main(int argc, char **argv) {$/;"	f
main	commands/dd.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/df.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/dosread.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/echo.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/getlf.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/grep.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/gres.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/head.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/kill.cpp	/^int main(int argc, char **argv) {$/;"	f
main	commands/libpack.cpp	/^int main() {$/;"	f
main	commands/libupack.cpp	/^int main() {$/;"	f
main	commands/ln.cpp	/^int main(int argc, char **argv) {$/;"	f
main	commands/login.cpp	/^int main() {$/;"	f
main	commands/lpr.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/ls.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/make.cpp	/^int main(int argc, char *argv[], char *envp[]) {$/;"	f
main	commands/mkdir.cpp	/^int main(int argc, char **argv) {$/;"	f
main	commands/mkfs.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/mknod.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/mount.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/mv.cpp	/^int main(int argc, char **argv) {$/;"	f
main	commands/od.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/passwd.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/pr.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/pwd.cpp	/^int main(void)$/;"	f
main	commands/rev.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/rm.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/rmdir.cpp	/^int main(int argc, char **argv) {$/;"	f
main	commands/roff.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/sh1.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/shar.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/size.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/sleep.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/sort.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/split.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/stty.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/su.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/sum.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/svcctl.cpp	/^int main(int argc, char **argv) { return svcctl::run({argv, static_cast<size_t>(argc)}); }$/;"	f
main	commands/sync.cpp	/^int main() {$/;"	f
main	commands/tail.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/tar.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/tee.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/time.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/touch.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/tr.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/umount.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/uniq.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/update.cpp	/^int main() {$/;"	f
main	commands/wc.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	commands/x.cpp	/^int main() {$/;"	f
main	fs/main.cpp	/^int main() {$/;"	f
main	test/t10a.cpp	/^int main() {$/;"	f
main	test/t11a.cpp	/^int main(int argc, char *argv[], char *envp[]) {$/;"	f
main	test/t11b.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	test/t15a.cpp	/^int main() { return 0; }$/;"	f
main	test/t16a.cpp	/^int main(int argc, char *argv[], char *envp[]) {$/;"	f
main	test/t16b.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	test/test0.cpp	/^int main(void) {$/;"	f
main	test/test1.cpp	/^main() {$/;"	f
main	test/test10.cpp	/^main() {$/;"	f
main	test/test11.cpp	/^main() {$/;"	f
main	test/test12.cpp	/^int main(void) {$/;"	f
main	test/test2.cpp	/^main() {$/;"	f
main	test/test3.cpp	/^main() {$/;"	f
main	test/test4.cpp	/^main() {$/;"	f
main	test/test5.cpp	/^main() {$/;"	f
main	test/test6.cpp	/^main() {$/;"	f
main	test/test7.cpp	/^main() {$/;"	f
main	test/test8.cpp	/^main() {$/;"	f
main	test/test9.cpp	/^main() {$/;"	f
main	tests/crypto/test_constant_time_equal.cpp	/^int main() {$/;"	f
main	tests/crypto/test_kyber.cpp	/^int main() {$/;"	f
main	tests/crypto/test_shared_secret_failure.cpp	/^int main() {$/;"	f
main	tests/test_fastpath.cpp	/^int main() {$/;"	f
main	tests/test_fastpath_cache_performance.cpp	/^int main() {$/;"	f
main	tests/test_fastpath_fallback.cpp	/^int main() {$/;"	f
main	tests/test_fastpath_preconditions.cpp	/^int main() {$/;"	f
main	tests/test_hypercomplex.cpp	/^int main() {$/;"	f
main	tests/test_lattice.cpp	/^int main() {$/;"	f
main	tests/test_lattice_blocking.cpp	/^int main() {$/;"	f
main	tests/test_lattice_ipc.cpp	/^int main() {$/;"	f
main	tests/test_lattice_ipv6.cpp	/^int main() {$/;"	f
main	tests/test_lattice_network.cpp	/^int main() {$/;"	f
main	tests/test_lattice_network_encrypted.cpp	/^int main() {$/;"	f
main	tests/test_lattice_send_error.cpp	/^int main() {$/;"	f
main	tests/test_lattice_send_recv.cpp	/^int main() {$/;"	f
main	tests/test_lib.cpp	/^int main(void) {$/;"	f
main	tests/test_memory_stream.cpp	/^int main() {$/;"	f
main	tests/test_net_driver.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_concurrency.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_drop_newest.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_id.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_ipv6.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_loopback.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_overflow.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_persistent_id.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_reconnect.cpp	/^int main() { return parent_proc(); }$/;"	f
main	tests/test_net_driver_socket_failure.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_tcp.cpp	/^int main() {$/;"	f
main	tests/test_net_driver_unpriv_id.cpp	/^int main() {$/;"	f
main	tests/test_net_two_node.cpp	/^int main() {$/;"	f
main	tests/test_poll_network.cpp	/^int main() {$/;"	f
main	tests/test_scheduler.cpp	/^int main() {$/;"	f
main	tests/test_scheduler_deadlock.cpp	/^int main() {$/;"	f
main	tests/test_scheduler_edge.cpp	/^int main() {$/;"	f
main	tests/test_semantic_region.cpp	/^int main() {$/;"	f
main	tests/test_service_contract.cpp	/^int main() {$/;"	f
main	tests/test_service_manager_dag.cpp	/^int main() {$/;"	f
main	tests/test_service_manager_updates.cpp	/^int main() {$/;"	f
main	tests/test_service_serialization.cpp	/^int main() {$/;"	f
main	tests/test_stream_foundation.cpp	/^int main() {$/;"	f
main	tests/test_streams.cpp	/^int main() {$/;"	f
main	tests/test_svcctl.cpp	/^int main() {$/;"	f
main	tests/test_syscall.cpp	/^int main(void) {$/;"	f
main	tests/test_wait_graph.cpp	/^int main() {$/;"	f
main	tools/arch_scan.py	/^def main(root: str = ".") -> None:$/;"	f
main	tools/ascii_tree.py	/^def main() -> None:$/;"	f
main	tools/find_knr.py	/^def main() -> None:$/;"	f
main	tools/fsck.cpp	/^int main(int argc, char *argv[]) {$/;"	f	namespace:minix::fsck
main	tools/generate_kr_summary.py	/^def main() -> None:$/;"	f
main	tools/getcore.cpp	/^main()$/;"	f
main	tools/init.cpp	/^main() {$/;"	f
main	tools/mkfs.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	tools/modernize_kr_file.py	/^def main():$/;"	f
main	tools/r.cpp	/^int main(int argc, char *argv[]) {$/;"	f
major	fs/device.cpp	/^PRIVATE major, minor, task;$/;"	v
make_error_code	include/minix/fs_error.hpp	/^inline std::error_code make_error_code(ErrorCode e) {$/;"	f
make_file	commands/dosread.cpp	/^static void make_file(DIRECTORY *dir_ptr, int entries, char *name) {$/;"	f	file:
make_name	commands/dosread.cpp	/^static char *make_name(DIRECTORY *dir_ptr, short dir_fl) {$/;"	f	file:
makedir	commands/mkdir.cpp	/^static void makedir(char *dirname) {$/;"	f	file:
makef	commands/make.cpp	/^struct llist *makef = NULL;$/;"	v	typeref:struct:llist
malloc	lib/malloc.cpp	/^char *malloc(unsigned size) {$/;"	f
map	commands/tr.cpp	/^static void map(unsigned char *string1, unsigned char *string2) {$/;"	f	file:
map_bits	fs/super.cpp	/^bit_nr map_bits;       \/* how many bits are there in the bit map? *\/$/;"	v
map_mutex	lib/io/src/stdio_compat.cpp	/^static std::mutex map_mutex;$/;"	m	namespace:minix::io::compat	file:
map_ptr	fs/super.cpp	/^struct buf *map_ptr[]; \/* pointer to array of bit block pointers *\/$/;"	v	typeref:struct:buf
mark	commands/dosread.cpp	/^long mark;$/;"	v
mark	commands/sh2.cpp	/^int type, mark;$/;"	v
mark_line	commands/mined2.cpp	/^LINE *mark_line; \/* For marking position. *\/$/;"	v
mark_text	commands/mined2.cpp	/^char *mark_text;$/;"	v
mask_bits	include/minix/fs/const.hpp	/^enum class mask_bits : std::uint16_t {};$/;"	c	namespace:minix::fs
match	commands/cp.cpp	/^static int match(char *s1, char *s2, int n) {$/;"	f	file:
match	commands/grep.cpp	/^static void match(char *name, regexp *exp) {$/;"	f	file:
match_line	commands/mined2.cpp	/^find_y(match_line) LINE *match_line;$/;"	v
max	commands/make.cpp	122;"	d	file:
max_ecc	kernel/wini.cpp	/^    int max_ecc;    \/* Maximum ECC burst length *\/$/;"	m	struct:param	file:
max_ecc	kernel/xt_wini.cpp	/^    int max_ecc;    \/* Maximum ECC burst length *\/$/;"	m	struct:param	file:
max_free	tools/c86/dos2out.cpp	/^	unsigned int	max_free;	\/* max free mem ever needed (FFFFh) *\/$/;"	m	struct:d_fmt_hdr	file:
max_major	fs/table.cpp	/^int max_major = sizeof(dmap) \/ sizeof(struct dmap);$/;"	v
max_value	include/minix/fs/const.hpp	/^template <typename T> constexpr T max_value() {$/;"	f	class:minix::fs::FsConstants::IoMode::DirOp::BlockType
mc	kernel/clock.cpp	/^PRIVATE message mc;                       \/* message buffer for both input and output *\/$/;"	v
mem	commands/ar.cpp	/^    } mem;$/;"	m	union:swabber	typeref:struct:swabber::sw	file:
mem_1	commands/ar.cpp	/^        short mem_1;$/;"	m	struct:swabber::sw	file:
mem_2	commands/ar.cpp	/^        short mem_2;$/;"	m	struct:swabber::sw	file:
mem_len	h/type.hpp	/^    vir_clicks mem_len;   \/* length *\/$/;"	m	struct:mem_map
mem_lower	multiboot.h	/^    uint32_t mem_lower; \/\/ Amount of lower memory in kilobytes$/;"	m	struct:multiboot_tag_basic_meminfo
mem_map	h/type.hpp	/^struct mem_map {$/;"	s
mem_phys	h/type.hpp	/^    phys_clicks mem_phys; \/* physical address *\/$/;"	m	struct:mem_map
mem_size	commands/ar.cpp	/^long mem_time, mem_size;$/;"	v
mem_time	commands/ar.cpp	/^long mem_time, mem_size;$/;"	v
mem_top	commands/sort.cpp	/^char *mem_top;       \/* Mem_top points to lowest pos of memory. *\/$/;"	v
mem_upper	multiboot.h	/^    uint32_t mem_upper; \/\/ Amount of upper memory in kilobytes$/;"	m	struct:multiboot_tag_basic_meminfo
mem_vir	h/type.hpp	/^    vir_clicks mem_vir;   \/* virtual address *\/$/;"	m	struct:mem_map
member	commands/tar.cpp	/^    } member;$/;"	m	union:HEADER	typeref:struct:HEADER::m	file:
memory_map_tag	kernel.cpp	/^static struct multiboot_tag_mmap* memory_map_tag = NULL;$/;"	v	typeref:struct:multiboot_tag_mmap	file:
merg	commands/sort.cpp	/^read_line(merg) register MERGE *merg;$/;"	v
merg	commands/sort.cpp	/^register MERGE *merg;$/;"	v
merg	commands/sort.cpp	/^uniq_lines(merg) register MERGE *merg;$/;"	v
merge_f	commands/sort.cpp	/^MERGE merge_f[OPEN_FILES]; \/* Merge structs *\/$/;"	v
mess	fs/pipe.cpp	/^PRIVATE message mess;$/;"	v
mess	kernel/floppy.cpp	/^PRIVATE message mess; \/* message buffer for in and out *\/$/;"	v
mess	kernel/memory.cpp	/^static message mess;$/;"	v	file:
mess_1	h/type.hpp	/^struct mess_1 {$/;"	s
mess_2	h/type.hpp	/^struct mess_2 {$/;"	s
mess_3	h/type.hpp	/^struct mess_3 {$/;"	s
mess_4	h/type.hpp	/^struct mess_4 {$/;"	s
mess_5	h/type.hpp	/^struct mess_5 {$/;"	s
mess_6	h/type.hpp	/^struct mess_6 {$/;"	s
mess_ptr	fs/device.cpp	/^message *mess_ptr; \/* pointer to message for task *\/$/;"	v
message	commands/mined1.cpp	/^file_status(message, count, file, lines, writefl, changed) char *message;$/;"	v
message	commands/mined1.cpp	/^get_file(message, file) char *message, *file;$/;"	v
message	commands/mined1.cpp	/^get_number(message, result) char *message;$/;"	v
message	commands/mined1.cpp	/^panic(message) register char *message;$/;"	v
message	commands/mined2.cpp	/^change(message, file) char *message; \/* Message to prompt for expression *\/$/;"	v
message	commands/mined2.cpp	/^char *message;$/;"	v
message	commands/mined2.cpp	/^search(message, method) char *message;$/;"	v
message	commands/sort.cpp	/^register char *message, *arg;$/;"	v
message	h/type.hpp	/^struct message {$/;"	s
method	commands/mined2.cpp	/^FLAG method;$/;"	v
method	commands/mined2.cpp	/^register FLAG method;$/;"	v
mexpand	commands/make.cpp	/^    char *name, *mexpand;$/;"	m	struct:macrec	file:
mfile	commands/cc.cpp	/^USTRING ifile, kfile, sfile, mfile, ofile;$/;"	v
mfilnam	commands/roff.cpp	/^char *mktemp(), *mfilnam = "\/tmp\/rtmXXXXXX";$/;"	v
middle	commands/sh4.cpp	/^char *middle, *end;$/;"	v
min	commands/date.cpp	/^    int year, month, day, hour, min, sec;$/;"	m	struct:__anon25	file:
min	commands/make.cpp	123;"	d	file:
min_free	tools/c86/dos2out.cpp	/^	unsigned int	min_free;	\/* min free mem required after prog *\/$/;"	m	struct:d_fmt_hdr	file:
mini_rec	kernel/proc.cpp	/^static int mini_rec(int caller, int src, message *m_ptr) {$/;"	f	file:
mini_send	kernel/proc.cpp	/^PUBLIC int mini_send(int caller, int dest, message *m_ptr) {$/;"	f
minix_fs_category	include/minix/fs_error.hpp	/^inline const std::error_category& minix_fs_category() {$/;"	f
minor	fs/device.cpp	/^PRIVATE major, minor, task;$/;"	v
mk_mode	fs/param.hpp	17;"	d
mkfiles	test/test10.cpp	/^mkfiles() {$/;"	f
mknod	lib/mknod.cpp	/^int mknod(const char *name, int mode, int addr) {$/;"	f
mkpathlist	commands/make.cpp	/^static void mkpathlist(void) {$/;"	f	file:
mkstr	commands/cc.cpp	/^char *static char *mkstr(char *dst, char *arg) {$/;"	f	file:
mktempname	commands/cc.cpp	/^static void mktempname(char nm[]) {$/;"	f	file:
mlen	commands/dd.cpp	/^char mlen[] = {64, 45, 82, 45, 83, 96, 109, 100, 109, 97, 96, 116, 108, 9};$/;"	v
mname	commands/make.cpp	/^add_macro(mname, expan) char *mname, *expan;$/;"	v
mname	commands/roff.cpp	/^    char mname[3];$/;"	m	struct:macrotype	file:
mo	commands/ar.cpp	/^int mo[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};$/;"	v
mo	commands/ls.cpp	/^int mo[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};$/;"	v
mo	commands/pr.cpp	/^int mo[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};$/;"	v
mod	fs/device.cpp	/^int mod;    \/* how to open it *\/$/;"	v
mode	commands/dosread.cpp	/^modes(mode) register unsigned char mode;$/;"	v
mode	commands/ls.cpp	/^    unsigned short mode;$/;"	m	struct:file	file:
mode	commands/mined2.cpp	/^scratch_file(mode) FLAG mode; \/* Can be READ or WRITE permission *\/$/;"	v
mode	commands/mkfs.cpp	/^int mode, usrid, grpid;$/;"	v
mode	commands/uniq.cpp	/^char *fn, *mode;$/;"	v
mode	fs/param.hpp	18;"	d
mode	tools/mkfs.cpp	/^int mode, usrid, grpid;$/;"	v
mode_	tools/fsck.cpp	/^    FsckMode mode_;$/;"	m	class:minix::fsck::ZoneLevel::UserInterface	file:
mode_fmt	commands/mkfs.cpp	/^char *mode_fmt = "%6o";$/;"	v
mode_fmt	tools/mkfs.cpp	/^char *mode_fmt = "%6o";$/;"	v
mode_map	fs/open.cpp	/^PRIVATE char mode_map[] = {R_BIT, W_BIT, R_BIT | W_BIT, 0};$/;"	v
modernize_file	tools/modernize_kr_file.py	/^def modernize_file(path: Path, dry_run: bool, no_backup: bool) -> None:$/;"	f
modified	commands/make.cpp	/^    TIME modified;$/;"	m	struct:defnrec	file:
modified	commands/mined1.cpp	/^FLAG modified = FALSE;       \/* Set when file is modified *\/$/;"	v
modtime	commands/ls.cpp	/^    long modtime;$/;"	m	struct:file	file:
moff	commands/roff.cpp	/^    long int moff;$/;"	m	struct:macrotype	file:
mon_len	commands/dosread.cpp	/^short mon_len[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};$/;"	v
moname	commands/ar.cpp	/^char *moname[] = {" Jan ", " Feb ", " Mar ", " Apr ", " May ", " Jun ",$/;"	v
moname	commands/ls.cpp	/^char *moname[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",$/;"	v
moname	commands/pr.cpp	/^char *moname[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",$/;"	v
montgomery_reduce	crypto/kyber_impl/reduce.c	/^int16_t montgomery_reduce(int32_t a)$/;"	f
montgomery_reduce	crypto/kyber_impl/reduce.h	10;"	d
month	commands/date.cpp	/^    int year, month, day, hour, min, sec;$/;"	m	struct:__anon25	file:
month	commands/dosread.cpp	/^char *month[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",$/;"	v
monthname	commands/cal.cpp	/^constexpr std::array<std::string_view, 13> monthname = {$/;"	v
months	commands/date.cpp	/^std::array<std::string_view, 12> months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",$/;"	v
motor_goal	kernel/floppy.cpp	/^PRIVATE int motor_goal;   \/* desired motor status is in 4 high bits *\/$/;"	v
motor_status	kernel/floppy.cpp	/^PRIVATE int motor_status; \/* current motor status is in 4 high bits *\/$/;"	v
mount	lib/mount.cpp	/^int mount(const char *special, const char *name, int rwflag) {$/;"	f
move	commands/mv.cpp	/^static void move(char *old, char *new) {$/;"	f	file:
move_address	commands/mined.hpp	221;"	d
move_address	include/mined.hpp	214;"	d
move_to	commands/mined.hpp	216;"	d
move_to	include/mined.hpp	209;"	d
mp_catch	mm/mproc.hpp	/^    unshort mp_catch;  \/**< Non-zero to catch the signal. *\/$/;"	m	struct:mproc
mp_effgid	mm/mproc.hpp	/^    gid mp_effgid;  \/**< Process effective group id. *\/$/;"	m	struct:mproc
mp_effuid	mm/mproc.hpp	/^    uid mp_effuid;  \/**< Process effective user id. *\/$/;"	m	struct:mproc
mp_exitstatus	mm/mproc.hpp	/^    char mp_exitstatus;             \/**< Status code when the process exits. *\/$/;"	m	struct:mproc
mp_flags	mm/mproc.hpp	/^    unsigned mp_flags; \/**< Process flags. *\/$/;"	m	struct:mproc
mp_func	mm/mproc.hpp	/^    int (*mp_func)();  \/**< User function handling all signals. *\/$/;"	m	struct:mproc
mp_ignore	mm/mproc.hpp	/^    unshort mp_ignore; \/**< Non-zero to ignore the signal. *\/$/;"	m	struct:mproc
mp_parent	mm/mproc.hpp	/^    int mp_parent;                  \/**< Index of parent process. *\/$/;"	m	struct:mproc
mp_pid	mm/mproc.hpp	/^    int mp_pid;                     \/**< Process identifier. *\/$/;"	m	struct:mproc
mp_procgrp	mm/mproc.hpp	/^    int mp_procgrp;                 \/**< Process group used for signals. *\/$/;"	m	struct:mproc
mp_realgid	mm/mproc.hpp	/^    gid mp_realgid; \/**< Process real group id. *\/$/;"	m	struct:mproc
mp_realuid	mm/mproc.hpp	/^    uid mp_realuid; \/**< Process real user id. *\/$/;"	m	struct:mproc
mp_seg	mm/mproc.hpp	/^    struct mem_map mp_seg[NR_SEGS]; \/**< Segment descriptors for text, data and stack. *\/$/;"	m	struct:mproc	typeref:struct:mproc::mem_map
mp_sigstatus	mm/mproc.hpp	/^    char mp_sigstatus;              \/**< Signal number that caused termination. *\/$/;"	m	struct:mproc
mp_token	mm/mproc.hpp	/^    std::uint64_t mp_token;         \/**< Capability token for privileged actions. *\/$/;"	m	struct:mproc
mproc	mm/mproc.hpp	/^EXTERN struct mproc {$/;"	s
mproc	mm/mproc.hpp	/^} mproc[NR_PROCS];$/;"	v	typeref:struct:mproc
mtr_setup	kernel/floppy.cpp	/^PRIVATE int mtr_setup[NT] = {HZ \/ 4, HZ \/ 4, 3 * HZ \/ 4, 3 * HZ \/ 4}; \/* in ticks *\/$/;"	v
multiboot_info_physical_addr	kernel.cpp	/^static uintptr_t multiboot_info_physical_addr = 0;$/;"	v	file:
multiboot_mmap_entry	multiboot.h	/^struct multiboot_mmap_entry {$/;"	s
multiboot_tag	multiboot.h	/^struct multiboot_tag {$/;"	s
multiboot_tag_align	multiboot.h	80;"	d
multiboot_tag_basic_meminfo	multiboot.h	/^struct multiboot_tag_basic_meminfo {$/;"	s
multiboot_tag_elf_sections	multiboot.h	/^struct multiboot_tag_elf_sections {$/;"	s
multiboot_tag_mmap	multiboot.h	/^struct multiboot_tag_mmap {$/;"	s
multiboot_tag_string	kernel.cpp	/^struct multiboot_tag_string {$/;"	s	file:
multiline	include/sh.hpp	/^int multiline;      \/* \\n changed to ; *\/$/;"	v
mv_install	commands/make.cpp	/^static int mv_install(char *from, char *to, int back) {$/;"	f	file:
mwrite	commands/ar.cpp	/^static void mwrite(int fd, char *address, int bytes) {$/;"	f	file:
my_strcpy	commands/make.cpp	/^static char *my_strcpy(char *dest, char *src) {$/;"	f	file:
my_strlen	commands/make.cpp	/^static int my_strlen(char *src) {$/;"	f	file:
mystop_err	commands/make.cpp	/^mystop_err() {$/;"	f
mysystem	commands/make.cpp	/^static int mysystem(char *cmd) \/* use the SHELL to execute a command line, print warnings *\/$/;"	f	file:
mysystem	commands/make.cpp	/^static int mysystem(char *cmd) {$/;"	f	file:
n	commands/make.cpp	/^    char *n;            \/* name *\/$/;"	v
n	commands/make.cpp	/^get_ext(n, ex) char *ex, *n;$/;"	v
n	commands/mkfs.cpp	/^add_zone(n, z, bytes, cur_time) int n, z;$/;"	v
n	commands/mkfs.cpp	/^get_block(n, buf) int n;$/;"	v
n	commands/mkfs.cpp	/^incr_link(n) int n;$/;"	v
n	commands/mkfs.cpp	/^incr_size(n, count) int n;$/;"	v
n	commands/mkfs.cpp	/^int n;$/;"	v
n	commands/mkfs.cpp	/^put_block(n, buf) int n;$/;"	v
n	commands/roff.cpp	/^done(n) int n;$/;"	v
n	commands/sh1.cpp	/^int n;$/;"	v
n	commands/sh1.cpp	/^register char *n;$/;"	v
n	commands/sh2.cpp	/^rlookup(n) register char *n;$/;"	v
n	lib/itoa.cpp	/^int n;$/;"	v
n	lib/stb.cpp	/^	    register char *f, *t; register int n;$/;"	v
n	lib/strncat.cpp	/^int n;$/;"	v
n	lib/strncmp.cpp	/^int n;$/;"	v
n	lib/strncpy.cpp	/^int n;$/;"	v
n	test/test1.cpp	/^e(n) int n;$/;"	v
n	test/test10.cpp	/^spawn(n) int n;$/;"	v
n	test/test11.cpp	/^e(n) int n;$/;"	v
n	test/test3.cpp	/^e(n) int n;$/;"	v
n	test/test5.cpp	/^e(n) int n;$/;"	v
n	test/test6.cpp	/^e(n) int n;$/;"	v
n	test/test7.cpp	/^e(n) int n;$/;"	v
n	test/test8.cpp	/^e(n) int n;$/;"	v
n	tools/mkfs.cpp	/^add_zone(n, z, bytes, cur_time) int n, z;$/;"	v
n	tools/mkfs.cpp	/^get_block(n, buf) int n;$/;"	v
n	tools/mkfs.cpp	/^incr_link(n) int n;$/;"	v
n	tools/mkfs.cpp	/^incr_size(n, count) int n;$/;"	v
n	tools/mkfs.cpp	/^int n;$/;"	v
n	tools/mkfs.cpp	/^put_block(n, buf) int n;$/;"	v
n1	commands/sh1.cpp	/^register char *n1, *n2;$/;"	v
n2	commands/sh1.cpp	/^register char *n1, *n2;$/;"	v
n_macros	commands/roff.cpp	/^int n_macros;$/;"	v
n_outwords	commands/roff.cpp	/^int n_outwords;$/;"	v
n_ta	commands/roff.cpp	/^int n_ta = 20; \/* #TAB STOPS *\/$/;"	v
nam	commands/make.cpp	/^char *head, *nam;$/;"	v
name	commands/comm.cpp	/^    char *name;       \/* the file's name *\/$/;"	m	struct:file	file:
name	commands/dosread.cpp	/^char *name;$/;"	v
name	commands/ls.cpp	/^    char *name;$/;"	m	struct:file	file:
name	commands/make.cpp	/^    char *name, *mexpand;$/;"	m	struct:macrec	file:
name	commands/make.cpp	/^    char *name;$/;"	m	struct:defnrec	file:
name	commands/make.cpp	/^    char *name;$/;"	m	struct:llist	file:
name	commands/mkfs.cpp	/^char *name;$/;"	v
name	commands/sh1.cpp	/^char *val, *name;$/;"	v
name	commands/tar.cpp	/^add_path(name) register char *name;$/;"	v
name	commands/time.cpp	/^char *name;$/;"	v
name	fs/param.hpp	19;"	d
name	include/grp.hpp	/^    char *name;   \/\/ Name of the group$/;"	m	struct:group
name	include/sh.hpp	/^    char *name;$/;"	m	struct:var
name	test/test10.cpp	/^char *name[] = {"t10a", "t10b", "t10c", "t10d", "t10e", "t10f", "t10g", "t10h", "t10i", "t10j"};$/;"	v
name	test/test10.cpp	/^cr_file(name, size) char *name;$/;"	v
name	tools/build.cpp	/^    std::string name;           \/\/\/< Human-readable program name for debugging$/;"	m	struct:minix::builder::ProgramType::ProgramInfo	file:
name	tools/fsck.cpp	/^        std::string name;$/;"	m	struct:minix::fsck::ZoneLevel::DirectoryEntry::Entry	file:
name	tools/fsck.cpp	/^        std::string name;$/;"	m	struct:minix::fsck::ZoneLevel::PathTracker::PathNode	file:
name	tools/init.cpp	/^char name[] = {"\/dev\/tty?"}; \/* terminal names *\/$/;"	v
name	tools/mkfs.cpp	/^char *name;$/;"	v
name1	fs/param.hpp	20;"	d
name1_length	fs/param.hpp	23;"	d
name2	fs/param.hpp	21;"	d
name2_length	fs/param.hpp	24;"	d
name_length	fs/param.hpp	22;"	d
name_ptr	fs/stadir.cpp	/^char *name_ptr;     \/* pointer to the directory name to change to *\/$/;"	v
namelen	mm/param.hpp	14;"	d
nayme	kernel/dmp.cpp	/^char *nayme[] = {"PRINTR", "TTY   ", "WINCHE", "FLOPPY", "RAMDSK", "CLOCK ",$/;"	v
nb	commands/sh5.cpp	/^register int nb;$/;"	v
nblocks	commands/ls.cpp	/^static int nblocks(long size) {$/;"	f	file:
nbuff	kernel/dmp.cpp	/^char nbuff[NSIZE + 1]; \/\/ Should be NSIZE+1 for null terminator if string$/;"	v
nbytes	commands/sh1.cpp	/^unsigned nbytes;$/;"	v
nbytes	fs/param.hpp	25;"	d
need_reset	kernel/floppy.cpp	/^PRIVATE int need_reset;   \/* set to 1 when controller must be reset *\/$/;"	v
nel	commands/sort.cpp	/^sort_table(nel) register int nel;$/;"	v
nerrors	test/test9.cpp	/^int nerrors;$/;"	v
net	kernel/net_driver.cpp	/^namespace net {$/;"	n	file:
new_address	commands/mined1.cpp	/^char *new_address;$/;"	v
new_block	fs/write.cpp	/^PUBLIC struct buf *new_block(struct inode *rip, int32_t position) {$/;"	f
new_entry	commands/dosread.cpp	80;"	d	file:
new_mem	mm/exec.cpp	/^PRIVATE int new_mem(std::size_t text_bytes, std::size_t data_bytes, std::size_t bss_bytes,$/;"	f
new_node	fs/open.cpp	/^static struct inode *new_node(char *path, uint16_t bits, uint16_t z0) {$/;"	f	file:
new_x	commands/mined1.cpp	/^move(new_x, new_address, new_y) register int new_x;$/;"	v
new_y	commands/mined1.cpp	/^int new_y;$/;"	v
newargs	commands/time.cpp	/^char *newargs[MAX_ISTACK_BYTES >> 2] = {"\/bin\/sh"}; \/* 256 args *\/$/;"	v
newenv	commands/sh1.cpp	/^newenv(f) {$/;"	f
newfile	commands/split.cpp	/^static int newfile() {$/;"	f	file:
newpage	commands/roff.cpp	/^newpage() {$/;"	f
newtp	commands/sh2.cpp	/^static struct op *newtp() {$/;"	f	file:
next	commands/cat.cpp	/^char *next = buffer.data();           \/* next free byte in buffer *\/$/;"	v
next	commands/comm.cpp	/^    char *next;       \/* the next character to read *\/$/;"	m	struct:file	file:
next	commands/libpack.cpp	/^    struct node *next;$/;"	m	struct:node	typeref:struct:node::node	file:
next	commands/make.cpp	/^    struct llist *next;$/;"	m	struct:llist	typeref:struct:llist::llist	file:
next	commands/mined.hpp	/^    struct Line *next;$/;"	m	struct:ReturnCode::Line	typeref:struct:ReturnCode::Line::Line
next	commands/od.cpp	/^int next;$/;"	v
next	commands/sh1.cpp	/^    struct region *next;$/;"	m	struct:region	typeref:struct:region::region	file:
next	commands/sh1.cpp	/^next(f) { PUSHIO(afile, f, nextchar); }$/;"	f
next	include/mined.hpp	/^    struct Line *next;$/;"	m	struct:ReturnCode::Line	typeref:struct:ReturnCode::Line::Line
next	include/sh.hpp	/^    struct var *next;$/;"	m	struct:var	typeref:struct:var::var
next	lib/itoa.cpp	/^static int next;$/;"	v	file:
next_alarm	kernel/clock.cpp	/^static int64_t next_alarm;                \/\/ real_time -> int64_t$/;"	v	file:
next_contract_id_	kernel/service.hpp	/^    static std::atomic_uint64_t next_contract_id_;             \/\/\/< Counter for contract IDs$/;"	m	class:svc::ServiceManager
next_inode	commands/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
next_inode	tools/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
next_kernel_va	kernel/paging.cpp	/^static uint64_t next_kernel_va;   \/\/ PRIVATE -> static$/;"	v	file:
next_pid	mm/forkexit.cpp	/^PRIVATE next_pid = INIT_PROC_NR + 1; \/* next pid to be assigned *\/$/;"	v
next_rand	mm/vm.cpp	/^static unsigned long next_rand() {$/;"	f	file:
next_user_va	mm/paging.cpp	/^static virt_addr64 next_user_va;$/;"	v	file:
next_zone	commands/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
next_zone	tools/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
nextb	test/test4.cpp	/^int nextb;$/;"	v
nextchar	commands/rev.cpp	/^static int nextchar(void) \/* Does a sort of buffered I\/O *\/$/;"	f	file:
nextdefn	commands/make.cpp	/^    struct defnrec *nextdefn;$/;"	m	struct:defnrec	typeref:struct:defnrec::defnrec	file:
nextlev	include/sh.hpp	/^    struct brkcon *nextlev;$/;"	m	struct:brkcon	typeref:struct:brkcon::brkcon
nextmac	commands/make.cpp	/^    struct macrec *nextmac;$/;"	m	struct:macrec	typeref:struct:macrec::macrec	file:
nextrule	commands/make.cpp	/^    struct rulerec *nextrule;$/;"	m	struct:rulerec	typeref:struct:rulerec::rulerec	file:
nf	commands/sort.cpp	/^int nf;$/;"	v
nflag	commands/grep.cpp	/^int nflag = 0;   \/* number the lines printed *\/$/;"	v
nifull	commands/dd.cpp	/^unsigned nifull, nipartial, nofull, nopartial;$/;"	v
nipartial	commands/dd.cpp	/^unsigned nifull, nipartial, nofull, nopartial;$/;"	v
nix	commands/roff.cpp	/^nix() {}$/;"	f
nl	commands/sh4.cpp	/^static struct wdblock *cl, *nl;$/;"	v	typeref:struct:	file:
nlcount	include/sh.hpp	/^    char nlcount; \/* for `'s *\/$/;"	m	struct:io
nlines	commands/mined1.cpp	/^int nlines;               \/* Number of lines in file *\/$/;"	v
nlseen	commands/sh2.cpp	/^static int nlseen;$/;"	v	file:
no_creat	commands/touch.cpp	/^int no_creat = 0;$/;"	v
no_file	commands/make.cpp	/^int no_file = TRUE;$/;"	v
no_header	commands/pr.cpp	/^Bool no_header;$/;"	v
node	commands/libpack.cpp	/^struct node {$/;"	s	file:
node	commands/libpack.cpp	/^} node[MAX];$/;"	v	typeref:struct:node
node_id_file	kernel/net_driver.cpp	/^[[nodiscard]] static std::filesystem::path node_id_file() {$/;"	f	namespace:net::__anon16
noexcept	h/com.hpp	/^inline int (*&func(message &m) noexcept)() { return m.m6_f1(); }$/;"	f
noexcept	h/com.hpp	/^inline int (*&func_to_call(message &m) noexcept)() { return m.m6_f1(); }$/;"	f
noexcept	include/minix/fs/buffer.hpp	/^    void add_to_hash(Buffer *buffer) noexcept;$/;"	m	class:minix::fs::BufferPool
noexcept	include/minix/fs/buffer.hpp	/^    void invalidate_device(dev_nr device) noexcept;$/;"	m	class:minix::fs::BufferPool
noexcept	include/minix/fs/buffer.hpp	/^    void move_to_front(Buffer *buffer) noexcept;$/;"	m	class:minix::fs::BufferPool
noexcept	include/minix/fs/buffer.hpp	/^    void move_to_rear(Buffer *buffer) noexcept;$/;"	m	class:minix::fs::BufferPool
noexcept	include/minix/fs/buffer.hpp	/^    void put_buffer(Buffer *buffer, BlockType type) noexcept;$/;"	m	class:minix::fs::BufferPool
noexcept	include/minix/fs/buffer.hpp	/^    void remove_from_hash(Buffer *buffer) noexcept;$/;"	m	class:minix::fs::BufferPool
noexcept	include/minix/fs/buffer.hpp	/^    void remove_from_lru(Buffer *buffer) noexcept;$/;"	m	class:minix::fs::BufferPool
noexcept	include/minix/fs/inode.hpp	/^    void release_inode(Inode *inode) noexcept;$/;"	m	class:minix::fs::InodeType::InodeTable
noexcept	include/vm.hpp	/^int vm_fork(int parent, int child) noexcept;$/;"	m	class:VmFlags
noexcept	include/vm.hpp	/^void *vm_alloc(u64_t bytes, VmFlags flags) noexcept;$/;"	m	class:VmFlags
noexcept	include/vm.hpp	/^void *vm_mmap(int proc, void *addr, u64_t length, VmFlags flags) noexcept;$/;"	m	class:VmFlags
noexcept	include/vm.hpp	/^void vm_handle_fault(int proc, virt_addr64 addr) noexcept;$/;"	m	class:VmFlags
noexcept	include/vm.hpp	/^void vm_init() noexcept;$/;"	m	class:VmFlags
noexcept	kernel/lattice_ipc.hpp	/^    Channel *find(xinim::pid_t src, xinim::pid_t dst, net::node_t node_id = ANY_NODE) noexcept;$/;"	m	class:lattice::Graph
noexcept	kernel/lattice_ipc.hpp	/^    [[nodiscard]] bool is_listening(xinim::pid_t pid) const noexcept;$/;"	m	class:lattice::Graph
noexcept	kernel/lattice_ipc.hpp	/^    void set_listening(xinim::pid_t pid, bool flag) noexcept;$/;"	m	class:lattice::Graph
noexcept	kernel/pqcrypto.hpp	/^[[nodiscard]] KeyPair generate_keypair() noexcept;$/;"	m	namespace:pqcrypto
noexcept	kernel/pqcrypto.hpp	/^compute_shared_secret(const KeyPair &local, const KeyPair &peer) noexcept;$/;"	m	namespace:pqcrypto
noexcept	kernel/quaternion_spinlock.hpp	/^    QuaternionSpinlock() noexcept = default;$/;"	m	class:hyper::QuaternionSpinlock
noexcept	kernel/quaternion_spinlock.hpp	/^    constexpr Quaternion(float sw, float sx, float sy, float sz) noexcept$/;"	m	struct:hyper::Quaternion
noexcept	kernel/schedule.hpp	/^    [[nodiscard]] bool is_blocked(xinim::pid_t pid) const noexcept;$/;"	m	class:sched::Scheduler
noexcept	kernel/schedule.hpp	/^    [[nodiscard]] xinim::pid_t pick() const noexcept;$/;"	m	class:sched::Scheduler
noexcept	kernel/sedenion.hpp	/^    explicit constexpr Sedenion(std::array<float, 16> c) noexcept : comp(c) {}$/;"	m	struct:hyper::Sedenion
noexcept	kernel/service.hpp	/^    [[nodiscard]] bool is_running(xinim::pid_t pid) const noexcept;$/;"	m	class:svc::ServiceManager
noexcept	kernel/wait_graph.hpp	/^    void clear(xinim::pid_t pid) noexcept;$/;"	m	class:lattice::WaitForGraph
noexcept	kernel/wait_graph.hpp	/^    void remove_edge(xinim::pid_t src, xinim::pid_t dst) noexcept;$/;"	m	class:lattice::WaitForGraph
noexcept	kernel/wormhole.hpp	/^[[nodiscard]] const MessageRegion *select_cache(const State &state) noexcept;$/;"	m	namespace:fastpath
noexcept	kernel/wormhole.hpp	/^bool execute_fastpath(State &state, FastpathStats *stats = nullptr) noexcept;$/;"	m	namespace:fastpath
noexcept	kernel/wormhole.hpp	/^bool message_region_valid(const MessageRegion &region, size_t msg_len) noexcept;$/;"	m	namespace:fastpath
noexcept	kernel/wormhole.hpp	/^void context_switch(State &state) noexcept;$/;"	m	namespace:fastpath::detail
noexcept	kernel/wormhole.hpp	/^void copy_mrs(State &state, FastpathStats *stats) noexcept;$/;"	m	namespace:fastpath::detail
noexcept	kernel/wormhole.hpp	/^void dequeue_receiver(State &state) noexcept;$/;"	m	namespace:fastpath::detail
noexcept	kernel/wormhole.hpp	/^void establish_reply(State &state) noexcept;$/;"	m	namespace:fastpath::detail
noexcept	kernel/wormhole.hpp	/^void reset_fastpath_queues() noexcept;$/;"	m	namespace:fastpath
noexcept	kernel/wormhole.hpp	/^void set_message_region(State &state, const MessageRegion &region) noexcept;$/;"	m	namespace:fastpath
noexcept	kernel/wormhole.hpp	/^void transfer_badge(State &state) noexcept;$/;"	m	namespace:fastpath::detail
noexcept	kernel/wormhole.hpp	/^void update_thread_state(State &state) noexcept;$/;"	m	namespace:fastpath::detail
noexcept	mm/utility.cpp	/^    FileDescriptor(FileDescriptor &&other) noexcept : fd(other.fd) { other.fd = -1; }$/;"	m	struct:__anon4::FileDescriptor	file:
noexcept	tools/diskio.hpp	/^    DiskInterface &operator=(DiskInterface &&) noexcept;$/;"	m	class:DiskInterface
noexcept	tools/diskio.hpp	/^    DiskInterface(DiskInterface &&) noexcept;$/;"	m	class:DiskInterface
noexcept	tools/diskio.hpp	/^    [[nodiscard]] bool is_accessible() const noexcept;$/;"	m	class:DiskInterface
noexcept	tools/diskio.hpp	/^    explicit constexpr SectorAddress(std::uint64_t addr) noexcept : value(addr) {}$/;"	m	struct:diskio::SectorAddress
noexcept	tools/diskio.hpp	/^    void close_device() noexcept;$/;"	m	class:DiskInterface
noexec	commands/cc.cpp	/^int noexec = 0;$/;"	v
nofork	test/test4.cpp	/^nofork() {$/;"	f
nofull	commands/dd.cpp	/^unsigned nifull, nipartial, nofull, nopartial;$/;"	v
nopartial	commands/dd.cpp	/^unsigned nifull, nipartial, nofull, nopartial;$/;"	v
noperprintf	include/stdio.hpp	78;"	d
norm	common/math/octonion.cpp	/^double Octonion::norm() const {$/;"	f	class:Common::Math::Octonion
norm	common/math/quaternion.cpp	/^double Quaternion::norm() const {$/;"	f	class:Common::Math::Quaternion
norm	common/math/sedenion.cpp	/^double Sedenion::norm() const {$/;"	f	class:Common::Math::Sedenion
normal_video	commands/mined1.cpp	/^char *normal_video = "\\033z\\007";    \/* String for leaving reverse video *\/$/;"	v
normalize	common/math/octonion.cpp	/^Octonion& Octonion::normalize() {$/;"	f	class:Common::Math::Octonion
normalize	common/math/quaternion.cpp	/^Quaternion& Quaternion::normalize() {$/;"	f	class:Common::Math::Quaternion
normalize	common/math/sedenion.cpp	/^Sedenion& Sedenion::normalize() {$/;"	f	class:Common::Math::Sedenion
normalized	common/math/octonion.cpp	/^Octonion Octonion::normalized() const {$/;"	f	class:Common::Math::Octonion
normalized	common/math/quaternion.cpp	/^Quaternion Quaternion::normalized() const {$/;"	f	class:Common::Math::Quaternion
normalized	common/math/sedenion.cpp	/^Sedenion Sedenion::normalized() const {$/;"	f	class:Common::Math::Sedenion
notnull	commands/make.cpp	133;"	d	file:
now	commands/make.cpp	/^TIME now() {$/;"	f
now	commands/make.cpp	97;"	d	file:
nowline	commands/uniq.cpp	/^char *nowline, *prevline, buf1[1024], buf2[1024];$/;"	v
nr	commands/sort.cpp	/^register int nr;$/;"	v
nr_blocks	kernel/floppy.cpp	/^PRIVATE int nr_blocks[NT] = {720, 720, 720, 2400};                    \/* sectors\/diskette*\/$/;"	v
nr_cyl	kernel/wini.cpp	/^    int nr_cyl;     \/* Number of cylinders *\/$/;"	m	struct:param	file:
nr_cyl	kernel/xt_wini.cpp	/^    int nr_cyl;     \/* Number of cylinders *\/$/;"	m	struct:param	file:
nr_drives	kernel/at_wini.cpp	/^PRIVATE int nr_drives;            \/* Number of drives *\/$/;"	v
nr_drives	kernel/wini.cpp	/^PRIVATE int nr_drives;            \/* Number of drives *\/$/;"	v
nr_drives	kernel/xt_wini.cpp	/^PRIVATE int nr_drives;            \/* Number of drives *\/$/;"	v
nr_heads	kernel/wini.cpp	/^    int nr_heads;   \/* Number of heads *\/$/;"	m	struct:param	file:
nr_heads	kernel/xt_wini.cpp	/^    int nr_heads;   \/* Number of heads *\/$/;"	m	struct:param	file:
nr_of_files	commands/sort.cpp	/^int nr_of_files = 0; \/* Nr_of_files to be merged *\/$/;"	v
nr_of_pages	tools/c86/dos2out.cpp	/^	unsigned int	nr_of_pages;	\/* a page is 512 b *\/$/;"	m	struct:d_fmt_hdr	file:
nr_of_relocs	tools/c86/dos2out.cpp	/^	unsigned int	nr_of_relocs;	\/* nr of relocation items *\/$/;"	m	struct:d_fmt_hdr	file:
nr_sectors	kernel/floppy.cpp	/^PRIVATE int nr_sectors[NT] = {9, 9, 9, 15};                           \/* sectors\/track *\/$/;"	v
nrblocks	commands/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
nrblocks	tools/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
nrfiles	commands/ls.cpp	/^int nrfiles;$/;"	v
nrinodes	commands/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
nrinodes	tools/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
ns	commands/dd.cpp	/^int ns;$/;"	v
nseek	commands/dd.cpp	/^unsigned cbs, bs, skip, nseek, count;$/;"	v
ntr	commands/dd.cpp	/^unsigned ntr, obc;$/;"	v
ntt	crypto/kyber_impl/ntt.c	/^void ntt(int16_t r[256]) {$/;"	f
ntt	crypto/kyber_impl/ntt.h	10;"	d
null	commands/dd.cpp	/^static void null(int c) {$/;"	f	file:
null	commands/dosread.cpp	/^char null[MAX_CLUSTER_SIZE], device[] = DRIVE, path[128];$/;"	v
null	commands/ls.cpp	/^char *null = {"."};$/;"	v
null	commands/sh1.cpp	/^char *null = "";$/;"	v
null	include/sh.hpp	/^char *null; \/* null value for variable *\/$/;"	v
null_argv	lib/exec.cpp	/^static char *null_argv[] = {nullptr};$/;"	v	file:
nullopt	tools/bootblok1.cpp	/^    static optional nullopt() { return optional(); }$/;"	f	class:optional
num	commands/dd.cpp	/^static int num(void) {$/;"	f	file:
num	commands/od.cpp	/^outnum(num, radix) int num, radix;$/;"	v
num	multiboot.h	/^    uint32_t num;$/;"	m	struct:multiboot_tag_elf_sections
num3	commands/df.cpp	/^static void num3(int n) {$/;"	f	file:
num_out	commands/dosread.cpp	/^static char *num_out(long number) {$/;"	f	file:
number	commands/mined1.cpp	/^long number;$/;"	v
number	commands/pr.cpp	/^Bool number;$/;"	v
number	commands/tar.cpp	/^register long number;$/;"	v
number_	tools/fsck.cpp	/^    inode_nr number_;$/;"	m	class:minix::fsck::ZoneLevel::Inode	file:
number_to_ascii	include/shared/number_to_ascii.hpp	/^static inline int number_to_ascii(long num, int radix, char *out) {$/;"	f
numeric	commands/sort.cpp	/^    BOOL numeric;$/;"	m	struct:FIELD	file:
numlock	kernel/tty.cpp	/^PRIVATE int shift1, shift2, capslock, numlock;    \/* keep track of shift keys *\/$/;"	v
nx	commands/mined1.cpp	/^set_cursor(nx, ny) int nx, ny;$/;"	v
ny	commands/mined1.cpp	/^set_cursor(nx, ny) int nx, ny;$/;"	v
o	commands/sh2.cpp	/^    struct op *o;$/;"	m	union:__anon26	typeref:struct:__anon26::op	file:
o_FILE	commands/cc.cpp	/^char *o_FILE = "a.out"; \/* default name for executable file *\/$/;"	v
o_ad	commands/roff.cpp	/^int o_ll = 65, o_ad = 1, o_po = 0, o_ls = 1, o_ig = 0, o_fi = 1;$/;"	v
o_bl	commands/roff.cpp	/^int o_pl = 66, o_ro = 0, o_hx = 0, o_bl = 0, o_sp = 0, o_sk = 0;$/;"	v
o_bp	commands/roff.cpp	/^int o_li = 0, o_n1 = 0, o_n2 = 0, o_bp = -1, o_hy = 1;$/;"	v
o_cc	commands/roff.cpp	/^int o_cc = '.';   \/* CONTROL CHARACTER *\/$/;"	v
o_ce	commands/roff.cpp	/^int o_ce = 0, o_m1 = 2, o_m2 = 2, o_m3 = 1, o_m4 = 3, o_ul = 0;$/;"	v
o_fi	commands/roff.cpp	/^int o_ll = 65, o_ad = 1, o_po = 0, o_ls = 1, o_ig = 0, o_fi = 1;$/;"	v
o_flag	commands/cc.cpp	/^int o_flag = 0;$/;"	v
o_hc	commands/roff.cpp	/^int o_hc = -1;    \/* HYPHENATION CHARACTER *\/$/;"	v
o_hx	commands/roff.cpp	/^int o_pl = 66, o_ro = 0, o_hx = 0, o_bl = 0, o_sp = 0, o_sk = 0;$/;"	v
o_hy	commands/roff.cpp	/^int o_li = 0, o_n1 = 0, o_n2 = 0, o_bp = -1, o_hy = 1;$/;"	v
o_ig	commands/roff.cpp	/^int o_ll = 65, o_ad = 1, o_po = 0, o_ls = 1, o_ig = 0, o_fi = 1;$/;"	v
o_in	commands/roff.cpp	/^int o_in = 0;     \/* INDENT SIZE *\/$/;"	v
o_ix	commands/roff.cpp	/^int o_ix = -1;    \/* NEXT INDENT SIZE *\/$/;"	v
o_li	commands/roff.cpp	/^int o_li = 0, o_n1 = 0, o_n2 = 0, o_bp = -1, o_hy = 1;$/;"	v
o_ll	commands/roff.cpp	/^int o_ll = 65, o_ad = 1, o_po = 0, o_ls = 1, o_ig = 0, o_fi = 1;$/;"	v
o_ls	commands/roff.cpp	/^int o_ll = 65, o_ad = 1, o_po = 0, o_ls = 1, o_ig = 0, o_fi = 1;$/;"	v
o_m1	commands/roff.cpp	/^int o_ce = 0, o_m1 = 2, o_m2 = 2, o_m3 = 1, o_m4 = 3, o_ul = 0;$/;"	v
o_m2	commands/roff.cpp	/^int o_ce = 0, o_m1 = 2, o_m2 = 2, o_m3 = 1, o_m4 = 3, o_ul = 0;$/;"	v
o_m3	commands/roff.cpp	/^int o_ce = 0, o_m1 = 2, o_m2 = 2, o_m3 = 1, o_m4 = 3, o_ul = 0;$/;"	v
o_m4	commands/roff.cpp	/^int o_ce = 0, o_m1 = 2, o_m2 = 2, o_m3 = 1, o_m4 = 3, o_ul = 0;$/;"	v
o_n1	commands/roff.cpp	/^int o_li = 0, o_n1 = 0, o_n2 = 0, o_bp = -1, o_hy = 1;$/;"	v
o_n2	commands/roff.cpp	/^int o_li = 0, o_n1 = 0, o_n2 = 0, o_bp = -1, o_hy = 1;$/;"	v
o_ni	commands/roff.cpp	/^int o_ni = 1;  \/* LINE-NUMBER INDENT *\/$/;"	v
o_nn	commands/roff.cpp	/^int o_nn = 0;  \/* #LINES TO SUPPRESS NUMBERING *\/$/;"	v
o_pl	commands/roff.cpp	/^int o_pl = 66, o_ro = 0, o_hx = 0, o_bl = 0, o_sp = 0, o_sk = 0;$/;"	v
o_po	commands/roff.cpp	/^int o_ll = 65, o_ad = 1, o_po = 0, o_ls = 1, o_ig = 0, o_fi = 1;$/;"	v
o_ro	commands/roff.cpp	/^int o_pl = 66, o_ro = 0, o_hx = 0, o_bl = 0, o_sp = 0, o_sk = 0;$/;"	v
o_sk	commands/roff.cpp	/^int o_pl = 66, o_ro = 0, o_hx = 0, o_bl = 0, o_sp = 0, o_sk = 0;$/;"	v
o_sp	commands/roff.cpp	/^int o_pl = 66, o_ro = 0, o_hx = 0, o_bl = 0, o_sp = 0, o_sk = 0;$/;"	v
o_ta	commands/roff.cpp	/^int o_ta[20] = {9,  17, 25,  33,  41,  49,  57,  65,  73,  81,$/;"	v
o_tc	commands/roff.cpp	/^int o_tc = ' ';   \/* TABULATION CHARACTER *\/$/;"	v
o_ti	commands/roff.cpp	/^int o_ti = -1; \/* TEMPORARY INDENT *\/$/;"	v
o_tr	commands/roff.cpp	/^char o_tr[40][2]; \/* OUTPUT TRANSLATION TABLE *\/$/;"	v
o_ul	commands/roff.cpp	/^int o_ce = 0, o_m1 = 2, o_m2 = 2, o_m3 = 1, o_m4 = 3, o_ul = 0;$/;"	v
oatoi	commands/chmod.cpp	/^static int oatoi(const char *arg) {$/;"	f	file:
obc	commands/dd.cpp	/^unsigned ntr, obc;$/;"	v
obj	fs/minix/Makefile	/^                                           obj =$/;"	m
obj	kernel/Makefile	/^                                                                          obj =$/;"	m
obj	kernel/minix/Makefile	/^                                    obj = mpx88.cpp main.s proc.s system.s tty.s clock.s memory$/;"	m
obj	mm/Makefile	/^                                                                obj =$/;"	m
obj	mm/minix/Makefile	/^                                                obj =$/;"	m
obs	commands/dd.cpp	/^unsigned obs = DEFAULT;$/;"	v
obuf	commands/dd.cpp	/^char *ibuf, *obuf, *op;$/;"	v
octal	commands/rm.cpp	/^static void octal(unsigned int num) {$/;"	f	file:
odd	commands/ar.cpp	/^[[nodiscard]] constexpr bool odd(int nr) { return nr & 0x01; }$/;"	f
oenv	include/sh.hpp	/^    struct env *oenv;$/;"	m	struct:env	typeref:struct:env::env
ofd	commands/dd.cpp	/^int ifd, ofd, ibc;$/;"	v
off	commands/od.cpp	/^long off;$/;"	v
off	commands/stty.cpp	/^char *off[] = {"-tabs", "", "", "nl", "-echo"};$/;"	v
offset	commands/mined1.cpp	/^int offset;                                    \/* Offset to start *\/$/;"	v
offset	commands/sort.cpp	/^int *offset;                                            \/* Offset in argv structure *\/$/;"	v
offset	fs/param.hpp	26;"	d
offset	kernel/printer.cpp	/^static int offset; \/* print, i.e., in the user's buffer - offset part from phys addr *\/$/;"	v	file:
offset_high	kernel/idt64.cpp	/^    u32_t offset_high;$/;"	m	struct:idt_entry	file:
offset_low	kernel/idt64.cpp	/^    u16_t offset_low;$/;"	m	struct:idt_entry	file:
offset_mid	kernel/idt64.cpp	/^    u16_t offset_mid;$/;"	m	struct:idt_entry	file:
ofile	commands/cc.cpp	/^USTRING ifile, kfile, sfile, mfile, ofile;$/;"	v
ofilename	commands/dd.cpp	/^char *ofilename = NULL;$/;"	v
oflag	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
ofoot	commands/roff.cpp	/^char ehead[100], efoot[100], ohead[100], ofoot[100];$/;"	v
ohead	commands/roff.cpp	/^char ehead[100], efoot[100], ohead[100], ofoot[100];$/;"	v
ok	tools/c86/_mkfs.bat	/^:ok$/;"	l
old_pos	commands/mined2.cpp	/^FLAG old_pos;$/;"	v
old_x	commands/mined1.cpp	/^int *old_x;$/;"	v
olivetti	kernel/glo.hpp	/^EXTERN bool olivetti; \/* TRUE for Olivetti-style keyboard - Formerly int *\/$/;"	v
on	commands/stty.cpp	/^char *on[] = {"tabs", "cbreak", "raw", "-nl", "echo"};$/;"	v
onecommand	commands/sh1.cpp	/^onecommand() {$/;"	f
onintr	commands/sh1.cpp	/^onintr() {$/;"	f
only_merge	commands/sort.cpp	/^BOOL only_merge = FALSE;$/;"	v
onlydone	commands/sh2.cpp	/^int onlydone;$/;"	v
op	commands/dd.cpp	/^char *ibuf, *obuf, *op;$/;"	v
op	commands/dosread.cpp	/^disk_io(op, seek, address, bytes) register BOOL op;$/;"	v
op	include/sh.hpp	/^struct op {$/;"	s
op	lib/regexp.cpp	/^char *op;$/;"	v
op	lib/regexp.cpp	/^char op;$/;"	v
op	lib/regexp.cpp	/^static void reginsert(op, opnd) char op;$/;"	v
opcode	commands/mined2.cpp	/^int opcode;$/;"	v
open	lib/open.cpp	/^int open(const char *name, int mode) { return callm3(FS, OPEN, mode, const_cast<char *>(name)); }$/;"	f
open_archive	commands/ar.cpp	/^static int open_archive(char *name, int mode) {$/;"	f	file:
open_device	commands/mined1.cpp	/^open_device() {$/;"	f
open_device	tools/diskio.cpp	/^void DiskInterface::open_device() {$/;"	f	class:diskio::DiskInterface
open_outfile	commands/sort.cpp	/^open_outfile() {$/;"	f
open_stream	lib/io/src/file_operations.cpp	/^Result<StreamPtr> open_stream(std::string_view path, OpenMode mode, Permissions perms) {$/;"	f	namespace:minix::io
openmac	commands/roff.cpp	/^openmac() {$/;"	f
operation_	tools/diskio.hpp	/^    std::string operation_;$/;"	m	class:DiskIoError
operator !=	common/math/octonion.cpp	/^bool Octonion::operator!=(const Octonion& other) const {$/;"	f	class:Common::Math::Octonion
operator !=	common/math/quaternion.cpp	/^bool Quaternion::operator!=(const Quaternion& other) const {$/;"	f	class:Common::Math::Quaternion
operator !=	common/math/sedenion.cpp	/^bool Sedenion::operator!=(const Sedenion& other) const {$/;"	f	class:Common::Math::Sedenion
operator &	include/minix/io/file_operations.hpp	/^inline bool operator&(OpenMode a, OpenMode b) {$/;"	f	class:minix::io::OpenMode
operator &	include/vm.hpp	/^inline constexpr VmFlags operator&(VmFlags l, VmFlags r) {$/;"	f	class:VmFlags
operator &=	include/vm.hpp	/^inline VmFlags &operator&=(VmFlags &l, VmFlags r) {$/;"	f	class:VmFlags
operator *	common/math/octonion.cpp	/^Octonion operator*(Octonion lhs, const Octonion& rhs) {$/;"	f	namespace:Common::Math
operator *	common/math/octonion.cpp	/^Octonion operator*(Octonion lhs, double scalar) {$/;"	f	namespace:Common::Math
operator *	common/math/octonion.cpp	/^Octonion operator*(double scalar, Octonion rhs) {$/;"	f	namespace:Common::Math
operator *	common/math/quaternion.cpp	/^Quaternion operator*(Quaternion lhs, const Quaternion& rhs) {$/;"	f	namespace:Common::Math
operator *	common/math/quaternion.cpp	/^Quaternion operator*(Quaternion lhs, double scalar) {$/;"	f	namespace:Common::Math
operator *	common/math/quaternion.cpp	/^Quaternion operator*(double scalar, Quaternion rhs) {$/;"	f	namespace:Common::Math
operator *	common/math/sedenion.cpp	/^Sedenion operator*(Sedenion lhs, const Sedenion& rhs) {$/;"	f	namespace:Common::Math
operator *	common/math/sedenion.cpp	/^Sedenion operator*(Sedenion lhs, double scalar) {$/;"	f	namespace:Common::Math
operator *	common/math/sedenion.cpp	/^Sedenion operator*(double scalar, Sedenion rhs) {$/;"	f	namespace:Common::Math
operator *	tools/bootblok1.cpp	/^    T operator*() const { return value_; }$/;"	f	class:optional
operator *=	common/math/octonion.cpp	/^Octonion& Octonion::operator*=(const Octonion& other) {$/;"	f	class:Common::Math::Octonion
operator *=	common/math/octonion.cpp	/^Octonion& Octonion::operator*=(double scalar) {$/;"	f	class:Common::Math::Octonion
operator *=	common/math/quaternion.cpp	/^Quaternion& Quaternion::operator*=(const Quaternion& other) {$/;"	f	class:Common::Math::Quaternion
operator *=	common/math/quaternion.cpp	/^Quaternion& Quaternion::operator*=(double scalar) {$/;"	f	class:Common::Math::Quaternion
operator *=	common/math/sedenion.cpp	/^Sedenion& Sedenion::operator*=(const Sedenion& other) {$/;"	f	class:Common::Math::Sedenion
operator *=	common/math/sedenion.cpp	/^Sedenion& Sedenion::operator*=(double scalar) {$/;"	f	class:Common::Math::Sedenion
operator +	common/math/octonion.cpp	/^Octonion operator+(Octonion lhs, const Octonion& rhs) {$/;"	f	namespace:Common::Math
operator +	common/math/quaternion.cpp	/^Quaternion operator+(Quaternion lhs, const Quaternion& rhs) {$/;"	f	namespace:Common::Math
operator +	common/math/sedenion.cpp	/^Sedenion operator+(Sedenion lhs, const Sedenion& rhs) {$/;"	f	namespace:Common::Math
operator +=	common/math/octonion.cpp	/^Octonion& Octonion::operator+=(const Octonion& other) {$/;"	f	class:Common::Math::Octonion
operator +=	common/math/quaternion.cpp	/^Quaternion& Quaternion::operator+=(const Quaternion& other) {$/;"	f	class:Common::Math::Quaternion
operator +=	common/math/sedenion.cpp	/^Sedenion& Sedenion::operator+=(const Sedenion& other) {$/;"	f	class:Common::Math::Sedenion
operator -	common/math/octonion.cpp	/^Octonion operator-(Octonion lhs, const Octonion& rhs) {$/;"	f	namespace:Common::Math
operator -	common/math/quaternion.cpp	/^Quaternion operator-(Quaternion lhs, const Quaternion& rhs) {$/;"	f	namespace:Common::Math
operator -	common/math/sedenion.cpp	/^Sedenion operator-(Sedenion lhs, const Sedenion& rhs) {$/;"	f	namespace:Common::Math
operator -=	common/math/octonion.cpp	/^Octonion& Octonion::operator-=(const Octonion& other) {$/;"	f	class:Common::Math::Octonion
operator -=	common/math/quaternion.cpp	/^Quaternion& Quaternion::operator-=(const Quaternion& other) {$/;"	f	class:Common::Math::Quaternion
operator -=	common/math/sedenion.cpp	/^Sedenion& Sedenion::operator-=(const Sedenion& other) {$/;"	f	class:Common::Math::Sedenion
operator /	common/math/octonion.cpp	/^Octonion operator\/(Octonion lhs, double scalar) {$/;"	f	namespace:Common::Math
operator /	common/math/quaternion.cpp	/^Quaternion operator\/(Quaternion lhs, double scalar) {$/;"	f	namespace:Common::Math
operator /	common/math/sedenion.cpp	/^Sedenion operator\/(Sedenion lhs, double scalar) {$/;"	f	namespace:Common::Math
operator /=	common/math/octonion.cpp	/^Octonion& Octonion::operator\/=(double scalar) {$/;"	f	class:Common::Math::Octonion
operator /=	common/math/quaternion.cpp	/^Quaternion& Quaternion::operator\/=(double scalar) {$/;"	f	class:Common::Math::Quaternion
operator /=	common/math/sedenion.cpp	/^Sedenion& Sedenion::operator\/=(double scalar) {$/;"	f	class:Common::Math::Sedenion
operator <<	common/math/octonion.cpp	/^std::ostream& operator<<(std::ostream& os, const Octonion& o) {$/;"	f	namespace:Common::Math
operator <<	common/math/quaternion.cpp	/^std::ostream& operator<<(std::ostream& os, const Quaternion& q) {$/;"	f	namespace:Common::Math
operator <<	common/math/sedenion.cpp	/^std::ostream& operator<<(std::ostream& os, const Sedenion& s) {$/;"	f	namespace:Common::Math
operator ==	common/math/octonion.cpp	/^bool Octonion::operator==(const Octonion& other) const {$/;"	f	class:Common::Math::Octonion
operator ==	common/math/quaternion.cpp	/^bool Quaternion::operator==(const Quaternion& other) const {$/;"	f	class:Common::Math::Quaternion
operator ==	common/math/sedenion.cpp	/^bool Sedenion::operator==(const Sedenion& other) const {$/;"	f	class:Common::Math::Sedenion
operator bool	tools/bootblok1.cpp	/^    explicit operator bool() const { return has_value_; }$/;"	f	class:optional
operator |	include/minix/io/file_operations.hpp	/^inline OpenMode operator|(OpenMode a, OpenMode b) {$/;"	f	class:minix::io::OpenMode
operator |	include/vm.hpp	/^inline constexpr VmFlags operator|(VmFlags l, VmFlags r) {$/;"	f	class:VmFlags
operator |=	include/vm.hpp	/^inline VmFlags &operator|=(VmFlags &l, VmFlags r) {$/;"	f	class:VmFlags
opnd	lib/regexp.cpp	/^char *opnd;$/;"	v
option	commands/stty.cpp	/^static void option(char *opt, char *next) {$/;"	f	file:
optional	include/minix/fs/inode.hpp	/^    [[nodiscard]] auto find_free_slot() -> std::optional<std::size_t>;$/;"	m	class:minix::fs::InodeType::InodeTable::std
optional	tools/bootblok1.cpp	/^    optional() : has_value_(false) {}$/;"	f	class:optional
optional	tools/bootblok1.cpp	/^    optional(T val) : has_value_(true), value_(val) {}$/;"	f	class:optional
optional	tools/bootblok1.cpp	/^template <typename T> class optional {$/;"	c	file:
orig_count	kernel/printer.cpp	/^static std::size_t orig_count; \/* original byte count (was int) *\/$/;"	v	file:
origin	fs/super.cpp	/^bit_nr origin;         \/* number of bit to start searching at *\/$/;"	v
ourtrap	include/sh.hpp	/^char ourtrap[NSIG];$/;"	v
out	commands/sh1.cpp	/^void putvlist(f, out) register int f, out;$/;"	v
out_buf	commands/lpr.cpp	/^char in_buf[BLOCK], out_buf[BLOCK];$/;"	v
out_buffer	commands/sort.cpp	/^char out_buffer[IO_SIZE]; \/* For buffered output *\/$/;"	v
out_count	commands/lpr.cpp	/^int cur_in, in_count, out_count, column;$/;"	v
out_count	commands/mined1.cpp	/^int out_count;               \/* Index in output buffer *\/$/;"	v
out_fd	commands/sort.cpp	/^int out_fd;               \/* Fd to output file (could be STD_OUT) *\/$/;"	v
out_file	commands/split.cpp	/^char out_file[100];$/;"	v
out_header	commands/pr.cpp	/^static void out_header(int page) {$/;"	f	file:
out_index	commands/tr.cpp	/^short in_index, out_index;$/;"	v
outb	console.cpp	/^static inline void outb(unsigned short port, unsigned char val) {$/;"	f	file:
outbuf	tools/c86/dos2out.cpp	/^unsigned char outbuf[PH_SECTSIZE];$/;"	v
output	commands/cal.cpp	/^static void output(int nmonths) \/* Number of months to do *\/$/;"	f	file:
output	commands/libupack.cpp	/^char output[OBUFSIZE + 1];$/;"	v
output	commands/pr.cpp	/^char output[1024];$/;"	v
output	commands/shar.cpp	/^char output[IO_SIZE];$/;"	v
output	commands/tar.cpp	/^char output[BLOCK_SIZE];$/;"	v
output	commands/tr.cpp	/^unsigned char output[BUFFER_SIZE], input[BUFFER_SIZE];$/;"	v
output_file	commands/sort.cpp	/^char *output_file;        \/* Name of output file *\/$/;"	v
output_file	tools/build.cpp	/^            std::string output_file;              \/\/\/< Path for output boot image$/;"	m	struct:minix::builder::ProgramType::BootImageBuilder::ArgumentParser::Arguments	file:
outtree	include/sh.hpp	/^struct op *outtree; \/* result from parser *\/$/;"	v	typeref:struct:op
outvec	commands/tr.cpp	/^BOOL invec[ASCII + 1], outvec[ASCII + 1];$/;"	v
over	commands/dd.cpp	/^static void over(void) {$/;"	f	file:
overlay_num	tools/c86/dos2out.cpp	/^	unsigned int	overlay_num;	\/* overlay number - not used *\/$/;"	m	struct:d_fmt_hdr	file:
override	commands/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
override	include/minix/io/file_stream.hpp	/^    Result<size_t> read(std::byte *buffer, size_t length) override;$/;"	m	class:minix::io::FileStream
override	include/minix/io/file_stream.hpp	/^    Result<size_t> write(const std::byte *buffer, size_t length) override;$/;"	m	class:minix::io::FileStream
override	include/minix/io/file_stream.hpp	/^    std::error_code close() override;$/;"	m	class:minix::io::FileStream
override	include/minix/io/file_stream.hpp	/^    ~FileStream() override = default;$/;"	m	class:minix::io::FileStream
override	include/minix/io/memory_stream.hpp	/^    Result<size_t> read(std::byte *buffer, size_t length) override;$/;"	m	class:minix::io::MemoryStream
override	include/minix/io/memory_stream.hpp	/^    Result<size_t> write(const std::byte *buffer, size_t length) override;$/;"	m	class:minix::io::MemoryStream
override	include/minix/io/memory_stream.hpp	/^    ~MemoryStream() override = default;$/;"	m	class:minix::io::MemoryStream
override	tools/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
owned_	include/minix/fs/buffer.hpp	/^    bool owned_;$/;"	m	class:minix::fs::BufferHandle
owned_	include/minix/fs/inode.hpp	/^    bool owned_;$/;"	m	class:minix::fs::InodeType::InodeHandle
owner	fs/param.hpp	27;"	d
owngrp	commands/ls.cpp	/^static void owngrp(struct file *fp) {$/;"	f	file:
p	commands/make.cpp	/^char *s, *p;$/;"	v
p	commands/make.cpp	/^int p;$/;"	v
p	commands/mined1.cpp	/^free_space(p) char *p;$/;"	v
p	commands/mined1.cpp	/^free_space(p) register char *p;$/;"	v
p	commands/mkfs.cpp	/^char *p;$/;"	v
p	commands/roff.cpp	/^char *p, c;$/;"	v
p	commands/roff.cpp	/^char *p;$/;"	v
p	commands/roff.cpp	/^insrt(p) int p;$/;"	v
p	commands/sh1.cpp	/^register char *p;$/;"	v
p	commands/sh1.cpp	/^register char *s, *p;$/;"	v
p	commands/uniq.cpp	/^static int uniq() char *p;$/;"	v
p	lib/regexp.cpp	/^char *p;$/;"	v
p	lib/regexp.cpp	/^register char *p;$/;"	v
p	lib/regexp.cpp	/^static void regoptail(p, val) char *p;$/;"	v
p	lib/regexp.cpp	/^static void regtail(p, val) char *p;$/;"	v
p	tools/mkfs.cpp	/^char *p;$/;"	v
p1	commands/sh4.cpp	/^char *p1, *p2;$/;"	v
p2	commands/sh4.cpp	/^char *p1, *p2;$/;"	v
p_alarm	kernel/proc.hpp	/^    real_time p_alarm;     \/* time of next alarm in ticks, or 0 (real_time -> xinim::time_t) *\/$/;"	m	struct:proc
p_callerq	kernel/proc.hpp	/^    struct proc *p_callerq;  \/* head of list of procs wishing to send *\/$/;"	m	struct:proc	typeref:struct:proc::proc
p_cpu	kernel/proc.hpp	/^    int p_cpu;                \/* CPU affinity *\/$/;"	m	struct:proc
p_expand	commands/make.cpp	/^static void p_expand(char *src, char *dest, char *compl_preq, char *ood_preq, char *ood_obj) {$/;"	f	file:
p_flags	kernel/proc.hpp	/^    int p_flags;                   \/* P_SLOT_FREE, SENDING, RECEIVING, etc. *\/$/;"	m	struct:proc
p_getfrom	kernel/proc.hpp	/^    int p_getfrom;           \/* from whom does process want to receive? *\/$/;"	m	struct:proc
p_map	kernel/proc.hpp	/^    struct mem_map p_map[NR_SEGS]; \/* memory map *\/$/;"	m	struct:proc	typeref:struct:proc::mem_map
p_messbuf	kernel/proc.hpp	/^    message *p_messbuf;      \/* pointer to message buffer *\/$/;"	m	struct:proc
p_name	commands/ar.cpp	/^static void p_name(char *mem_name) {$/;"	f	file:
p_nextready	kernel/proc.hpp	/^    struct proc *p_nextready; \/* pointer to next ready process *\/$/;"	m	struct:proc	typeref:struct:proc::proc
p_pcpsw	kernel/proc.hpp	/^    struct pc_psw p_pcpsw;         \/* pc and psw as pushed by interrupt *\/$/;"	m	struct:proc	typeref:struct:proc::pc_psw
p_pending	kernel/proc.hpp	/^    int p_pending;            \/* bit map for pending signals 1-16 *\/$/;"	m	struct:proc
p_pid	kernel/proc.hpp	/^    xinim::pid_t p_pid;            \/* process id passed in from MM - Formerly int *\/$/;"	m	struct:proc
p_priority	kernel/proc.hpp	/^    int p_priority;           \/* scheduling priority *\/$/;"	m	struct:proc
p_reg	kernel/proc.hpp	/^    std::uint64_t p_reg[NR_REGS];  \/* process' registers *\/$/;"	m	struct:proc
p_sendlink	kernel/proc.hpp	/^    struct proc *p_sendlink; \/* link to next proc wishing to send *\/$/;"	m	struct:proc	typeref:struct:proc::proc
p_sp	kernel/proc.hpp	/^    xinim::virt_addr_t p_sp;       \/* stack pointer - Formerly u64_t *\/$/;"	m	struct:proc
p_splimit	kernel/proc.hpp	/^    xinim::virt_addr_t p_splimit;  \/* lowest legal stack value - Formerly u64_t *\/$/;"	m	struct:proc
p_token	kernel/proc.hpp	/^    std::uint64_t p_token;         \/**< Capability token for privileged operations. *\/$/;"	m	struct:proc
pack88	commands/libpack.cpp	/^static int pack88(char *inp, char *outp, int count) {$/;"	f	file:
pack_ciphertext	crypto/kyber_impl/indcpa.c	/^static void pack_ciphertext(uint8_t r[KYBER_INDCPA_BYTES], polyvec *b, poly *v)$/;"	f	file:
pack_pk	crypto/kyber_impl/indcpa.c	/^static void pack_pk(uint8_t r[KYBER_INDCPA_PUBLICKEYBYTES],$/;"	f	file:
pack_sk	crypto/kyber_impl/indcpa.c	/^static void pack_sk(uint8_t r[KYBER_INDCPA_SECRETKEYBYTES], polyvec *sk)$/;"	f	file:
packet_hook	tests/test_lattice_ipv6.cpp	/^void packet_hook(const net::Packet &pkt) {$/;"	f	namespace:__anon7
packet_hook	tests/test_lattice_network_encrypted.cpp	/^void packet_hook(const net::Packet &pkt) {$/;"	f	namespace:__anon8
page_bitmap	pmm.cpp	/^static uint32_t* page_bitmap = NULL;$/;"	v	file:
page_dir_ptr	include/paging.hpp	/^struct page_dir_ptr {$/;"	s
page_directory	include/paging.hpp	/^struct page_directory {$/;"	s
page_no	commands/roff.cpp	/^int page_no = -1;$/;"	v
page_table	include/paging.hpp	/^struct page_table {$/;"	s
panic	commands/cc.cpp	/^static void panic(char *str, int argv) {$/;"	f	file:
panicking	fs/utility.cpp	/^static int panicking = 0; \/**< prevents recursive panics during sync *\/$/;"	v	file:
panicstop	commands/make.cpp	/^panicstop() {$/;"	f
par	commands/roff.cpp	/^snset(par) int *par;$/;"	v
param	kernel/wini.cpp	/^PRIVATE struct param {$/;"	s	file:
param	kernel/xt_wini.cpp	/^PRIVATE struct param {$/;"	s	file:
param0	kernel/wini.cpp	/^} param0, param1;$/;"	v	typeref:struct:param
param0	kernel/xt_wini.cpp	/^} param0, param1;$/;"	v	typeref:struct:param
param1	kernel/wini.cpp	/^} param0, param1;$/;"	v	typeref:struct:param
param1	kernel/xt_wini.cpp	/^} param0, param1;$/;"	v	typeref:struct:param
parcum	test/test3.cpp	/^int parsigs, parpid, parcum;$/;"	v
paren	lib/regexp.cpp	/^int paren; \/* Parenthesized? *\/$/;"	v
parent	commands/mkfs.cpp	/^eat_dir(parent) int parent; \/* parent's inode nr *\/$/;"	v
parent	commands/mkfs.cpp	/^enter_dir(parent, name, child) int parent, child; \/* inode nums *\/$/;"	v
parent	commands/sh3.cpp	/^static int parent() {$/;"	f	file:
parent	fs/param.hpp	28;"	d
parent	test/test1.cpp	/^parent() {$/;"	f
parent	tools/fsck.cpp	/^        std::shared_ptr<PathNode> parent;$/;"	m	struct:minix::fsck::ZoneLevel::PathTracker::PathNode	file:
parent	tools/mkfs.cpp	/^eat_dir(parent) int parent; \/* parent's inode nr *\/$/;"	v
parent	tools/mkfs.cpp	/^enter_dir(parent, name, child) int parent, child; \/* inode nums *\/$/;"	v
parent_proc	tests/test_lattice_ipv6.cpp	/^static int parent_proc(pid_t child) {$/;"	f	file:
parent_proc	tests/test_lattice_network.cpp	/^static int parent_proc(pid_t child) {$/;"	f	file:
parent_proc	tests/test_lattice_network_encrypted.cpp	/^static int parent_proc(pid_t child) {$/;"	f	file:
parent_proc	tests/test_net_driver.cpp	/^int parent_proc(pid_t child_pid) {$/;"	f
parent_proc	tests/test_net_driver_drop_newest.cpp	/^int parent_proc(pid_t child) {$/;"	f	namespace:__anon13
parent_proc	tests/test_net_driver_overflow.cpp	/^int parent_proc(pid_t child) {$/;"	f	namespace:__anon6
parent_proc	tests/test_net_driver_reconnect.cpp	/^int parent_proc() {$/;"	f	namespace:__anon12
parent_proc	tests/test_net_driver_tcp.cpp	/^int parent_proc(pid_t child_pid) {$/;"	f	namespace:__anon9
parent_proc	tests/test_net_two_node.cpp	/^static int parent_proc(pid_t child) {$/;"	f	file:
parent_proc	tests/test_poll_network.cpp	/^static int parent_proc(pid_t child) {$/;"	f	file:
parpid	test/test3.cpp	/^int parsigs, parpid, parcum;$/;"	v
parpid	test/test5.cpp	/^child(parpid) int parpid;$/;"	v
parse	commands/mkfs.cpp	/^getline(line, parse) char *parse[MAX_TOKENS];$/;"	v
parse	tools/build.cpp	/^        static Arguments parse(int argc, char *argv[]) {$/;"	f	class:minix::builder::ProgramType::BootImageBuilder::ArgumentParser
parse	tools/mkfs.cpp	/^getline(line, parse) char *parse[MAX_TOKENS];$/;"	v
parse_arguments	tools/fsck.cpp	/^    void parse_arguments(int argc, char *argv[]) {$/;"	f	class:minix::fsck::ZoneLevel::FsckApplication	file:
parse_multiboot_info	kernel.cpp	/^void parse_multiboot_info(uintptr_t mb_info_addr) {$/;"	f
parsigs	test/test3.cpp	/^int parsigs, parpid, parcum;$/;"	v
parsigs	test/test5.cpp	/^int childsigs, parsigs, alarms;$/;"	v
passwd	commands/ls.cpp	/^int passwd;   \/* file descr for \/etc\/passwd or \/etc\/group *\/$/;"	v
passwd	include/grp.hpp	/^    char *passwd; \/\/ Encrypted group password$/;"	m	struct:group
passwd	include/pwd.hpp	/^struct passwd {$/;"	s
patch_bootblock	tools/build.cpp	/^    void patch_bootblock() {$/;"	f	class:minix::builder::ProgramType::BootImageBuilder	file:
patch_fs_init_info	tools/build.cpp	/^    void patch_fs_init_info() {$/;"	f	class:minix::builder::ProgramType::BootImageBuilder	file:
patch_kernel_table	tools/build.cpp	/^    void patch_kernel_table() {$/;"	f	class:minix::builder::ProgramType::BootImageBuilder	file:
patch_ptr	mm/exec.cpp	/^PRIVATE void patch_ptr(char stack[MAX_ISTACK_BYTES], std::size_t base)$/;"	f
path	commands/dosread.cpp	/^char null[MAX_CLUSTER_SIZE], device[] = DRIVE, path[128];$/;"	v
path	commands/mined1.cpp	/^char *path;$/;"	v
path	commands/tar.cpp	/^char path[NAME_SIZE];$/;"	v
path	fs/mount.cpp	/^char *path; \/* pointer to path name *\/$/;"	v
path	include/sh.hpp	/^struct var *path;    \/* search path for commands *\/$/;"	v	typeref:struct:var
path_head	commands/make.cpp	/^struct llist *path_head = NULL;$/;"	v	typeref:struct:llist
path_set	commands/make.cpp	/^int path_set = FALSE;$/;"	v
pathname	commands/tar.cpp	/^char pathname[NAME_SIZE];$/;"	v
pathname	commands/time.cpp	/^char pathname[200];$/;"	v
pathname	fs/param.hpp	29;"	d
pattern	commands/mined2.cpp	/^compile(pattern, program) register char *pattern; \/* Pointer to pattern *\/$/;"	v
pattern	commands/sh2.cpp	/^static char **pattern() {$/;"	f	file:
pause	lib/pause.cpp	/^int pause() { return callm1(MM, PAUSE, 0, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
pc	kernel/type.hpp	/^    xinim::virt_addr_t pc; \/* program counter *\/$/;"	m	struct:pc_psw
pc_at	kernel/glo.hpp	/^EXTERN bool pc_at;    \/* PC-AT type diskette drives (360K\/1.2M) ? - Formerly int *\/$/;"	v
pc_psw	kernel/type.hpp	/^struct pc_psw {$/;"	s
pch	commands/dd.cpp	/^char *pch, *errorp;$/;"	v
pcount	kernel/printer.cpp	/^PUBLIC std::size_t pcount; \/* number of bytes left to print (was int) *\/$/;"	v
pde_t	vmm.h	/^typedef uint32_t pde_t;$/;"	t
peekc	include/sh.hpp	/^    int peekc;$/;"	m	struct:io
peeksym	commands/sh2.cpp	/^static int peeksym = 0;$/;"	v	file:
perprintf	include/stdio.hpp	79;"	d
perror	lib/perror.cpp	/^void perror(const char *s) {$/;"	f
pforked	commands/sh3.cpp	/^int *pforked;$/;"	v
pgform	commands/roff.cpp	/^char *pgform() {$/;"	f
phase1_check_superblock	tools/fsck.cpp	/^    void phase1_check_superblock() {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
phase2_initialize_structures	tools/fsck.cpp	/^    void phase2_initialize_structures() {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
phase3_check_inodes	tools/fsck.cpp	/^    void phase3_check_inodes() {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
phase4_check_directories	tools/fsck.cpp	/^    void phase4_check_directories() {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
phase5_check_bitmaps	tools/fsck.cpp	/^    void phase5_check_bitmaps() {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
phase6_verify_link_counts	tools/fsck.cpp	/^    void phase6_verify_link_counts() {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
phase7_cleanup_and_summary	tools/fsck.cpp	/^    void phase7_cleanup_and_summary() {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
pick_proc	kernel/proc.cpp	/^PUBLIC pick_proc() {$/;"	f
pid	mm/param.hpp	15;"	d
pid	tools/init.cpp	/^int pid[PIDSLOTS];           \/* pids of init's own children *\/$/;"	v
pid0	test/test4.cpp	/^int pid0, pid1, pid2, pid3, s;$/;"	v
pid1	test/test4.cpp	/^int pid0, pid1, pid2, pid3, s;$/;"	v
pid2	test/test4.cpp	/^int pid0, pid1, pid2, pid3, s;$/;"	v
pid3	test/test4.cpp	/^int pid0, pid1, pid2, pid3, s;$/;"	v
pidct	tools/init.cpp	/^int pidct;$/;"	v
pin	commands/sh3.cpp	/^int *pin, *pout;$/;"	v
pipe	lib/pipe.cpp	/^int pipe(int fild[2]) {$/;"	f
pipein	commands/sh3.cpp	/^int pipein, pipeout;$/;"	v
pipeout	commands/sh3.cpp	/^int pipein, pipeout;$/;"	v
pline	commands/grep.cpp	/^static void pline(char *name, int lineno, char buf[]) {$/;"	f	file:
pline	commands/gres.cpp	/^static void pline(regexp *exp, char ibuf[], char *repstr) {$/;"	f	file:
pmflag	commands/grep.cpp	/^int pmflag = 1;  \/* print lines which match *\/$/;"	v
pml4	include/paging.hpp	/^struct pml4 {$/;"	s
pmm_alloc_page	pmm.cpp	/^uintptr_t pmm_alloc_page() {$/;"	f
pmm_free_page	pmm.cpp	/^void pmm_free_page(uintptr_t page_addr) {$/;"	f
pmm_get_free_pages	pmm.cpp	/^size_t pmm_get_free_pages() {$/;"	f
pmm_get_total_pages	pmm.cpp	/^size_t pmm_get_total_pages() {$/;"	f
pmm_get_used_pages	pmm.cpp	/^size_t pmm_get_used_pages() {$/;"	f
pmm_init	pmm.cpp	/^void pmm_init(struct multiboot_tag_mmap* mmap_tag, uintptr_t kernel_start_phys, uintptr_t kernel_end_phys, uintptr_t multiboot_info_addr_phys) {$/;"	f
pmm_mark_region_free	pmm.cpp	/^static void pmm_mark_region_free(uintptr_t base_addr, size_t size_in_bytes) {$/;"	f	file:
pmm_mark_region_used	pmm.cpp	/^static void pmm_mark_region_used(uintptr_t base_addr, size_t size_in_bytes) {$/;"	f	file:
pnmflag	commands/grep.cpp	/^int pnmflag = 0; \/* print lines which don't match *\/$/;"	v
poll_network	kernel/lattice_ipc.cpp	/^void poll_network() {$/;"	f	namespace:lattice
poly	crypto/kyber_impl/poly.h	/^} poly;$/;"	t	typeref:struct:__anon22
poly_add	crypto/kyber_impl/poly.c	/^void poly_add(poly *r, const poly *a, const poly *b)$/;"	f
poly_add	crypto/kyber_impl/poly.h	48;"	d
poly_basemul_montgomery	crypto/kyber_impl/poly.c	/^void poly_basemul_montgomery(poly *r, const poly *a, const poly *b)$/;"	f
poly_basemul_montgomery	crypto/kyber_impl/poly.h	40;"	d
poly_cbd_eta1	crypto/kyber_impl/cbd.c	/^void poly_cbd_eta1(poly *r, const uint8_t buf[KYBER_ETA1*KYBER_N\/4])$/;"	f
poly_cbd_eta1	crypto/kyber_impl/cbd.h	8;"	d
poly_cbd_eta2	crypto/kyber_impl/cbd.c	/^void poly_cbd_eta2(poly *r, const uint8_t buf[KYBER_ETA2*KYBER_N\/4])$/;"	f
poly_cbd_eta2	crypto/kyber_impl/cbd.h	11;"	d
poly_compress	crypto/kyber_impl/poly.c	/^void poly_compress(uint8_t r[KYBER_POLYCOMPRESSEDBYTES], const poly *a)$/;"	f
poly_compress	crypto/kyber_impl/poly.h	15;"	d
poly_decompress	crypto/kyber_impl/poly.c	/^void poly_decompress(poly *r, const uint8_t a[KYBER_POLYCOMPRESSEDBYTES])$/;"	f
poly_decompress	crypto/kyber_impl/poly.h	17;"	d
poly_frombytes	crypto/kyber_impl/poly.c	/^void poly_frombytes(poly *r, const uint8_t a[KYBER_POLYBYTES])$/;"	f
poly_frombytes	crypto/kyber_impl/poly.h	22;"	d
poly_frommsg	crypto/kyber_impl/poly.c	/^void poly_frommsg(poly *r, const uint8_t msg[KYBER_INDCPA_MSGBYTES])$/;"	f
poly_frommsg	crypto/kyber_impl/poly.h	25;"	d
poly_getnoise_eta1	crypto/kyber_impl/poly.c	/^void poly_getnoise_eta1(poly *r, const uint8_t seed[KYBER_SYMBYTES], uint8_t nonce)$/;"	f
poly_getnoise_eta1	crypto/kyber_impl/poly.h	30;"	d
poly_getnoise_eta2	crypto/kyber_impl/poly.c	/^void poly_getnoise_eta2(poly *r, const uint8_t seed[KYBER_SYMBYTES], uint8_t nonce)$/;"	f
poly_getnoise_eta2	crypto/kyber_impl/poly.h	33;"	d
poly_invntt_tomont	crypto/kyber_impl/poly.c	/^void poly_invntt_tomont(poly *r)$/;"	f
poly_invntt_tomont	crypto/kyber_impl/poly.h	38;"	d
poly_ntt	crypto/kyber_impl/poly.c	/^void poly_ntt(poly *r)$/;"	f
poly_ntt	crypto/kyber_impl/poly.h	36;"	d
poly_reduce	crypto/kyber_impl/poly.c	/^void poly_reduce(poly *r)$/;"	f
poly_reduce	crypto/kyber_impl/poly.h	45;"	d
poly_sub	crypto/kyber_impl/poly.c	/^void poly_sub(poly *r, const poly *a, const poly *b)$/;"	f
poly_sub	crypto/kyber_impl/poly.h	50;"	d
poly_tobytes	crypto/kyber_impl/poly.c	/^void poly_tobytes(uint8_t r[KYBER_POLYBYTES], const poly *a)$/;"	f
poly_tobytes	crypto/kyber_impl/poly.h	20;"	d
poly_tomont	crypto/kyber_impl/poly.c	/^void poly_tomont(poly *r)$/;"	f
poly_tomont	crypto/kyber_impl/poly.h	42;"	d
poly_tomsg	crypto/kyber_impl/poly.c	/^void poly_tomsg(uint8_t msg[KYBER_INDCPA_MSGBYTES], const poly *a)$/;"	f
poly_tomsg	crypto/kyber_impl/poly.h	27;"	d
polyvec	crypto/kyber_impl/polyvec.h	/^} polyvec;$/;"	t	typeref:struct:__anon24
polyvec_add	crypto/kyber_impl/polyvec.c	/^void polyvec_add(polyvec *r, const polyvec *a, const polyvec *b)$/;"	f
polyvec_add	crypto/kyber_impl/polyvec.h	33;"	d
polyvec_basemul_acc_montgomery	crypto/kyber_impl/polyvec.c	/^void polyvec_basemul_acc_montgomery(poly *r, const polyvec *a, const polyvec *b)$/;"	f
polyvec_basemul_acc_montgomery	crypto/kyber_impl/polyvec.h	27;"	d
polyvec_compress	crypto/kyber_impl/polyvec.c	/^void polyvec_compress(uint8_t r[KYBER_POLYVECCOMPRESSEDBYTES], const polyvec *a)$/;"	f
polyvec_compress	crypto/kyber_impl/polyvec.h	12;"	d
polyvec_decompress	crypto/kyber_impl/polyvec.c	/^void polyvec_decompress(polyvec *r, const uint8_t a[KYBER_POLYVECCOMPRESSEDBYTES])$/;"	f
polyvec_decompress	crypto/kyber_impl/polyvec.h	14;"	d
polyvec_frombytes	crypto/kyber_impl/polyvec.c	/^void polyvec_frombytes(polyvec *r, const uint8_t a[KYBER_POLYVECBYTES])$/;"	f
polyvec_frombytes	crypto/kyber_impl/polyvec.h	19;"	d
polyvec_invntt_tomont	crypto/kyber_impl/polyvec.c	/^void polyvec_invntt_tomont(polyvec *r)$/;"	f
polyvec_invntt_tomont	crypto/kyber_impl/polyvec.h	24;"	d
polyvec_ntt	crypto/kyber_impl/polyvec.c	/^void polyvec_ntt(polyvec *r)$/;"	f
polyvec_ntt	crypto/kyber_impl/polyvec.h	22;"	d
polyvec_reduce	crypto/kyber_impl/polyvec.c	/^void polyvec_reduce(polyvec *r)$/;"	f
polyvec_reduce	crypto/kyber_impl/polyvec.h	30;"	d
polyvec_tobytes	crypto/kyber_impl/polyvec.c	/^void polyvec_tobytes(uint8_t r[KYBER_POLYVECBYTES], const polyvec *a)$/;"	f
polyvec_tobytes	crypto/kyber_impl/polyvec.h	17;"	d
port_base	kernel/printer.cpp	/^static int port_base;          \/* I\/O port for printer: 0x 378 or 0x3BC *\/$/;"	v	file:
pos	crypto/kyber_impl/fips202.h	/^  unsigned int pos;$/;"	m	struct:__anon23
pos	fs/device.cpp	/^long pos;    \/* byte position *\/$/;"	v
pos_string	commands/mined1.cpp	/^char *pos_string = "\\033";           \/* Absolute cursor position *\/$/;"	v
position	fs/pipe.cpp	/^register file_pos *position; \/* pointer to current file position *\/$/;"	v
post_tree	commands/make.cpp	/^int post_tree = FALSE;$/;"	v
pout	commands/sh3.cpp	/^int *pin, *pout;$/;"	v
pp	commands/sh4.cpp	/^register char *pp;$/;"	v
pqcrypto	crypto/pqcrypto_shared.cpp	/^namespace pqcrypto {$/;"	n	file:
pqcrypto	include/constant_time.hpp	/^namespace pqcrypto {$/;"	n
pqcrypto	include/pqcrypto.hpp	/^namespace pqcrypto {$/;"	n
pqcrypto	kernel/pqcrypto.cpp	/^namespace pqcrypto {$/;"	n	file:
pqcrypto	kernel/pqcrypto.hpp	/^namespace pqcrypto {$/;"	n
pqcrystals_kyber1024_BYTES	crypto/kyber_impl/api.h	55;"	d
pqcrystals_kyber1024_CIPHERTEXTBYTES	crypto/kyber_impl/api.h	52;"	d
pqcrystals_kyber1024_ENCCOINBYTES	crypto/kyber_impl/api.h	54;"	d
pqcrystals_kyber1024_KEYPAIRCOINBYTES	crypto/kyber_impl/api.h	53;"	d
pqcrystals_kyber1024_PUBLICKEYBYTES	crypto/kyber_impl/api.h	51;"	d
pqcrystals_kyber1024_SECRETKEYBYTES	crypto/kyber_impl/api.h	50;"	d
pqcrystals_kyber1024_ref_BYTES	crypto/kyber_impl/api.h	62;"	d
pqcrystals_kyber1024_ref_CIPHERTEXTBYTES	crypto/kyber_impl/api.h	59;"	d
pqcrystals_kyber1024_ref_ENCCOINBYTES	crypto/kyber_impl/api.h	61;"	d
pqcrystals_kyber1024_ref_KEYPAIRCOINBYTES	crypto/kyber_impl/api.h	60;"	d
pqcrystals_kyber1024_ref_PUBLICKEYBYTES	crypto/kyber_impl/api.h	58;"	d
pqcrystals_kyber1024_ref_SECRETKEYBYTES	crypto/kyber_impl/api.h	57;"	d
pqcrystals_kyber512_BYTES	crypto/kyber_impl/api.h	15;"	d
pqcrystals_kyber512_CIPHERTEXTBYTES	crypto/kyber_impl/api.h	12;"	d
pqcrystals_kyber512_ENCCOINBYTES	crypto/kyber_impl/api.h	14;"	d
pqcrystals_kyber512_KEYPAIRCOINBYTES	crypto/kyber_impl/api.h	13;"	d
pqcrystals_kyber512_PUBLICKEYBYTES	crypto/kyber_impl/api.h	11;"	d
pqcrystals_kyber512_SECRETKEYBYTES	crypto/kyber_impl/api.h	10;"	d
pqcrystals_kyber512_ref_BYTES	crypto/kyber_impl/api.h	22;"	d
pqcrystals_kyber512_ref_CIPHERTEXTBYTES	crypto/kyber_impl/api.h	19;"	d
pqcrystals_kyber512_ref_ENCCOINBYTES	crypto/kyber_impl/api.h	21;"	d
pqcrystals_kyber512_ref_KEYPAIRCOINBYTES	crypto/kyber_impl/api.h	20;"	d
pqcrystals_kyber512_ref_PUBLICKEYBYTES	crypto/kyber_impl/api.h	18;"	d
pqcrystals_kyber512_ref_SECRETKEYBYTES	crypto/kyber_impl/api.h	17;"	d
pqcrystals_kyber768_BYTES	crypto/kyber_impl/api.h	35;"	d
pqcrystals_kyber768_CIPHERTEXTBYTES	crypto/kyber_impl/api.h	32;"	d
pqcrystals_kyber768_ENCCOINBYTES	crypto/kyber_impl/api.h	34;"	d
pqcrystals_kyber768_KEYPAIRCOINBYTES	crypto/kyber_impl/api.h	33;"	d
pqcrystals_kyber768_PUBLICKEYBYTES	crypto/kyber_impl/api.h	31;"	d
pqcrystals_kyber768_SECRETKEYBYTES	crypto/kyber_impl/api.h	30;"	d
pqcrystals_kyber768_ref_BYTES	crypto/kyber_impl/api.h	42;"	d
pqcrystals_kyber768_ref_CIPHERTEXTBYTES	crypto/kyber_impl/api.h	39;"	d
pqcrystals_kyber768_ref_ENCCOINBYTES	crypto/kyber_impl/api.h	41;"	d
pqcrystals_kyber768_ref_KEYPAIRCOINBYTES	crypto/kyber_impl/api.h	40;"	d
pqcrystals_kyber768_ref_PUBLICKEYBYTES	crypto/kyber_impl/api.h	38;"	d
pqcrystals_kyber768_ref_SECRETKEYBYTES	crypto/kyber_impl/api.h	37;"	d
pr	commands/stty.cpp	/^static void pr(int f, int n) {$/;"	f	file:
pr_busy	kernel/printer.cpp	/^PUBLIC int pr_busy;        \/* TRUE when printing, else FALSE *\/$/;"	v
pr_fl	commands/ar.cpp	/^BOOL pr_fl;$/;"	v
pr_vec	commands/cc.cpp	/^static void pr_vec(struct arglist *vec) {$/;"	f	file:
pr_warning	commands/make.cpp	/^static int pr_warning(WAIT *s) \/* print a warning, if any *\/$/;"	f	file:
prctl	commands/stty.cpp	/^static void prctl(char c) {$/;"	f	file:
preempt	kernel/schedule.cpp	/^std::optional<xinim::pid_t> Scheduler::preempt() {$/;"	f	class:sched::Scheduler
present	commands/ls.cpp	/^static int present(char let) { return (flags >> (let - 'a')) & 01; }$/;"	f	file:
prev	commands/mined.hpp	/^    struct Line *prev;$/;"	m	struct:ReturnCode::Line	typeref:struct:ReturnCode::Line::Line
prev	include/mined.hpp	/^    struct Line *prev;$/;"	m	struct:ReturnCode::Line	typeref:struct:ReturnCode::Line::Line
prev_ct	kernel/printer.cpp	/^PUBLIC int prev_ct;        \/* value of cum_count 100 msec ago *\/$/;"	v
prev_motor	kernel/floppy.cpp	/^PRIVATE int prev_motor;   \/* which motor was started last *\/$/;"	v
prev_proc	kernel/glo.hpp	/^EXTERN xinim::pid_t prev_proc; \/* previous process - Formerly int *\/$/;"	v
prev_ptr	kernel/clock.cpp	/^PRIVATE struct proc *prev_ptr;            \/* last user process run by clock task *\/$/;"	v	typeref:struct:proc
previous	commands/mined2.cpp	1239;"	d	file:
prevline	commands/uniq.cpp	/^char *nowline, *prevline, buf1[1024], buf2[1024];$/;"	v
prevwds	commands/od.cpp	/^int prevwds[8];$/;"	v
prf	crypto/kyber_impl/symmetric.h	30;"	d
print	commands/ar.cpp	/^static void print(char *str) {$/;"	f	file:
print	commands/dosread.cpp	/^static void print(short fd, char *buffer, short bytes) {$/;"	f	file:
print	commands/ls.cpp	/^static void print(int index, int count, int expand, char *dirname) {$/;"	f	file:
print	commands/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
print	commands/pr.cpp	/^static void print(FILE *filep) {$/;"	f	file:
print	commands/shar.cpp	/^static void print(char *str) {$/;"	f	file:
print	tools/mkfs.cpp	/^                                      lct = 1, disk, fd, print = 0, file = 0, override = 0,$/;"	v
print_buf	mm/putc.cpp	/^PRIVATE char print_buf[BUF_SIZE]; \/* output is buffered here *\/$/;"	v
print_error	tools/fsck.cpp	/^    void print_error(std::string_view error, const PathTracker &path) const {$/;"	f	class:minix::fsck::ZoneLevel::UserInterface
print_fs	commands/mkfs.cpp	/^print_fs() {$/;"	f
print_fs	tools/mkfs.cpp	/^print_fs() {$/;"	f
print_info	tools/fsck.cpp	/^    void print_info(UserInterface &ui) const {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
print_line	commands/ls.cpp	/^static void print_line(struct file *fp) {$/;"	f	file:
print_message	tools/fsck.cpp	/^    void print_message(std::string_view message) const { std::cout << message << std::flush; }$/;"	f	class:minix::fsck::ZoneLevel::UserInterface
print_mode	commands/ar.cpp	/^static void print_mode(int mode) {$/;"	f	file:
print_page	commands/pr.cpp	/^static void print_page(char buf[], int pagenr, int maxcol) {$/;"	f	file:
print_summary	tools/fsck.cpp	/^    void print_summary() {$/;"	f	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
print_time	commands/pr.cpp	/^static void print_time(long t) {$/;"	f	file:
print_time	commands/time.cpp	/^static void print_time(char *mess, long t) {$/;"	f	file:
print_total	commands/ls.cpp	/^static void print_total(int index, int count) {$/;"	f	file:
print_usage	tools/build.cpp	/^        static void print_usage(const char *program_name) {$/;"	f	class:minix::builder::ProgramType::BootImageBuilder::ArgumentParser	file:
print_usage	tools/fsck.cpp	/^    void print_usage(const char *program_name) {$/;"	f	class:minix::fsck::ZoneLevel::FsckApplication	file:
print_warning	tools/fsck.cpp	/^    void print_warning(std::string_view warning) const {$/;"	f	class:minix::fsck::ZoneLevel::UserInterface
printbuf	fs/putc.cpp	/^PRIVATE char printbuf[BUFSIZE]; \/* output is buffered here *\/$/;"	v
printf	commands/mkfs.cpp	53;"	d	file:
printf	fs/const.hpp	69;"	d
printf	kernel/const.hpp	60;"	d
printf	kernel/proc.hpp	16;"	d
printf	lib/fprintf.cpp	/^int printf(const char *fmt, ...) {$/;"	f
printf	mm/const.hpp	24;"	d
printf	tools/mkfs.cpp	47;"	d	file:
printinfo	tools/c86/dos2out.cpp	/^printinfo ()$/;"	f
printk	lib/printk.cpp	/^void printk(char *s, int *arglist) {$/;"	f
prints	lib/prints.cpp	/^void prints(char *s, int *arglist) {$/;"	f
prioritize	tools/migration_dashboard.py	/^def prioritize(files, deps):$/;"	f
private_key	crypto/kyber.hpp	/^        private_key; \/\/\/< Generated private key$/;"	m	struct:pq::kyber::KeyPair
private_key	kernel/pqcrypto.hpp	/^    std::array<std::uint8_t, pqcrystals_kyber512_SECRETKEYBYTES> private_key; \/\/!< Kyber private key$/;"	m	struct:pqcrypto::KeyPair
pro	fs/param.hpp	30;"	d
proc	fs/device.cpp	/^int proc;    \/* in whose address space is buff? *\/$/;"	v
proc	kernel/proc.hpp	/^EXTERN struct proc {$/;"	s
proc	kernel/proc.hpp	/^} proc[NR_TASKS + NR_PROCS];$/;"	v	typeref:struct:proc
proc_	kernel/memory.cpp	/^    int proc_;$/;"	m	class:MessageReply	file:
proc_addr	kernel/proc.hpp	59;"	d
proc_nr	fs/pipe.cpp	/^int proc_nr; \/* process to revive *\/$/;"	v
proc_nr	kernel/printer.cpp	/^static int proc_nr;            \/* user requesting the printing *\/$/;"	v	file:
proc_ptr	kernel/proc.hpp	/^EXTERN struct proc *proc_ptr;                        \/* &proc[cur_proc] *\/$/;"	v	typeref:struct:proc
process	commands/gres.cpp	/^static void process(FILE *inf, regexp *exp, char *repstr) {$/;"	f	file:
process_once	tests/test_svcctl.cpp	/^    void process_once() {$/;"	f	class:MockServiceManager
prog	lib/regexp.cpp	/^char *prog;$/;"	v
prog	lib/regexp.cpp	/^regexp *prog;$/;"	v
prog	test/test10.cpp	/^long prog[300];$/;"	v
progname	commands/grep.cpp	/^char *progname;$/;"	v
progname	commands/gres.cpp	/^char *progname;$/;"	v
program	commands/mined2.cpp	/^REGEX *program;$/;"	v
program	commands/mined2.cpp	/^check_string(program, string, expression) REGEX *program;$/;"	v
program	commands/mined2.cpp	/^finished(program, last_exp) register REGEX *program;$/;"	v
program	commands/mined2.cpp	/^line_check(program, string, method) register REGEX *program;$/;"	v
program	commands/mined2.cpp	/^star(program, end_position, string, expression) REGEX *program;$/;"	v
program	include/regexp.hpp	/^    char program[1];       \/\/\/< Bytecode for the compiled pattern.$/;"	m	struct:regexp
program_names_	tools/build.cpp	/^    static constexpr std::array<const char *, 5> program_names_ = {"kernel", "mm", "fs", "init",$/;"	m	class:minix::builder::ProgramType::BootImageBuilder	file:
programs_	tools/build.cpp	/^        programs_;                     \/\/\/< Information for all 5 programs$/;"	m	class:minix::builder::ProgramType::BootImageBuilder	file:
project	docs/sphinx/conf.py	/^project = "XINIM"  # Name of the project$/;"	v
prompt	include/sh.hpp	/^struct var *prompt;  \/* main prompt *\/$/;"	v	typeref:struct:var
proto	commands/mkfs.cpp	/^FILE *proto;$/;"	v
proto	tools/mkfs.cpp	/^FILE *proto;$/;"	v
prtree	commands/make.cpp	/^static void prtree(void) {$/;"	f	file:
psize	test/test10.cpp	/^int psize;$/;"	v
psw	kernel/type.hpp	/^    std::uint64_t psw;     \/* processor status word *\/$/;"	m	struct:pc_psw
pt_entry	include/paging.hpp	/^struct pt_entry {$/;"	s
pte_get_addr	vmm.h	/^static inline uintptr_t pte_get_addr(pte_t entry) {$/;"	f
pte_set_addr	vmm.h	/^static inline void pte_set_addr(pte_t* entry, uintptr_t addr) {$/;"	f
pte_set_flags	vmm.h	/^static inline void pte_set_flags(pte_t* entry, uint32_t flags) {$/;"	f
pte_t	vmm.h	/^typedef uint32_t pte_t;$/;"	t
ptr	commands/sort.cpp	/^atoi(ptr) register char *ptr;$/;"	v
ptr	commands/sort.cpp	/^get_opts(ptr, field) register char *ptr;$/;"	v
ptr_	include/lib.hpp	/^    SafeBuffer(SafeBuffer &&other) noexcept : size_(other.size_), ptr_(other.ptr_) {$/;"	f	class:SafeBuffer
ptrs	include/paging.hpp	/^    struct page_dir_ptr *ptrs[PT_ENTRIES];$/;"	m	struct:pml4	typeref:struct:pml4::page_dir_ptr
public_key	crypto/kyber.hpp	/^    std::array<std::byte, pqcrystals_kyber512_PUBLICKEYBYTES> public_key; \/\/\/< Generated public key$/;"	m	struct:pq::kyber::KeyPair
public_key	include/pqcrypto.hpp	/^    std::array<std::uint8_t, pqcrystals_kyber512_PUBLICKEYBYTES> public_key; \/\/\/< Kyber public key$/;"	m	struct:pqcrypto::KeyPair
public_key	kernel/pqcrypto.hpp	/^    std::array<std::uint8_t, pqcrystals_kyber512_PUBLICKEYBYTES> public_key;  \/\/!< Kyber public key$/;"	m	struct:pqcrypto::KeyPair
put	lib/prints.cpp	/^static void put(char c) {$/;"	f	file:
put_byte	tools/build.cpp	/^    void put_byte(ByteOffset offset, std::uint8_t value) {$/;"	f	class:minix::builder::ProgramType::ImageFile
put_inode	fs/inode.cpp	/^PUBLIC void put_inode(struct inode *rip) { \/\/ Added void return, modernized params$/;"	f
putc	commands/lpr.cpp	/^static void putc(char c) {$/;"	f	file:
putc	include/stdio.hpp	/^inline int putc(int ch, FILE *iop) {$/;"	f
putch_msg	mm/putc.cpp	/^PRIVATE message putch_msg;        \/* used for message to TTY task *\/$/;"	v
putchar	commands/mined.hpp	/^inline void putchar(int c) { std::putchar(c); }$/;"	f	class:ReturnCode
putchar	commands/mined1.cpp	2234;"	d	file:
putchar	commands/shar.cpp	/^static void putchar(char c) {$/;"	f	file:
putchar	include/mined.hpp	/^inline void putchar(int c) { std::putchar(c); }$/;"	f	class:ReturnCode
putchar	include/stdio.hpp	/^inline int putchar(int c) {$/;"	f
putchmsg	fs/putc.cpp	/^PRIVATE message putchmsg;       \/* used for message to TTY task *\/$/;"	v
putcol	commands/comm.cpp	/^static void putcol(int col, char *buf) {$/;"	f	file:
putd	commands/sum.cpp	/^static void putd(int number, int fw, int zeros) {$/;"	f	file:
puto	commands/dd.cpp	/^static void puto(void) {$/;"	f	file:
puts	include/stdio.hpp	60;"	d
pv	commands/sh5.cpp	/^register int *pv;$/;"	v
pv	commands/sh5.cpp	/^void closepipe(pv) register int *pv;$/;"	v
pw_dir	include/pwd.hpp	/^    char *pw_dir;    \/\/ Path to user's home directory$/;"	m	struct:passwd
pw_gecos	include/pwd.hpp	/^    char *pw_gecos;  \/\/ Additional user information$/;"	m	struct:passwd
pw_gid	include/pwd.hpp	/^    int pw_gid;      \/\/ Primary group identifier$/;"	m	struct:passwd
pw_name	include/pwd.hpp	/^    char *pw_name;   \/\/ User login name$/;"	m	struct:passwd
pw_passwd	include/pwd.hpp	/^    char *pw_passwd; \/\/ Encrypted user password$/;"	m	struct:passwd
pw_shell	include/pwd.hpp	/^    char *pw_shell;  \/\/ Default shell program$/;"	m	struct:passwd
pw_tmp	commands/passwd.cpp	/^char pw_tmp[] = "\/etc\/pwtemp";$/;"	v
pw_uid	include/pwd.hpp	/^    int pw_uid;      \/\/ User identifier$/;"	m	struct:passwd
pwd	lib/getpwent.cpp	/^static struct passwd pwd;$/;"	v	typeref:struct:passwd	file:
pwd_file	commands/passwd.cpp	/^char pwd_file[] = "\/etc\/passwd";$/;"	v
pwdbuf	lib/getpass.cpp	/^static char pwdbuf[9];$/;"	v	file:
q_dep	commands/make.cpp	/^struct llist *targ, *q_how, *q_dep, *targ2;$/;"	v	typeref:struct:
q_how	commands/make.cpp	/^struct llist *targ, *q_how, *q_dep, *targ2;$/;"	v	typeref:struct:
qbuf	lib/itoa.cpp	/^static char qbuf[8];$/;"	v	file:
qflag	commands/date.cpp	/^int qflag;$/;"	v
qflag	commands/sh1.cpp	/^int (*qflag)() = SIG_IGN;$/;"	v
queue	kernel/lattice_ipc.hpp	/^    std::deque<message> queue;$/;"	m	struct:lattice::Channel
queue	kernel/wormhole.hpp	/^    std::vector<uint32_t> queue; \/\/ queued thread ids$/;"	m	struct:fastpath::Endpoint
quit	commands/cat.cpp	/^static void quit(void) {$/;"	f	file:
quit	commands/mined1.cpp	/^FLAG quit = FALSE;           \/* Set when quit character is typed *\/$/;"	v
quit	commands/sort.cpp	/^error(quit, message, arg) register BOOL quit;$/;"	v
quit	commands/split.cpp	/^[[noreturn]] static void quit() {$/;"	f	file:
quitenv	commands/sh1.cpp	/^quitenv() {$/;"	f
quoted	commands/sh4.cpp	/^int quoted;$/;"	v
r	commands/roff.cpp	/^submac(r) int r;$/;"	v
r	lib/regexp.cpp	/^void regdump(r) regexp *r;$/;"	v
r_name	commands/sh2.cpp	/^    char *r_name;$/;"	m	struct:res	file:
r_offset	tools/c86/dos2out.cpp	/^	unsigned int	r_offset;	\/* offset to symbol in load-module *\/$/;"	m	struct:d_reloctab	file:
r_segment	tools/c86/dos2out.cpp	/^	unsigned int	r_segment;	\/* segment relative to zero;$/;"	m	struct:d_reloctab	file:
r_val	commands/sh2.cpp	/^    int r_val;$/;"	m	struct:res	file:
radix	commands/od.cpp	/^outnum(num, radix) int num, radix;$/;"	v
radix	commands/od.cpp	/^outword(val, radix) int val, radix;$/;"	v
radix	commands/od.cpp	/^wdump(words, k, radix) int words[8], k, radix;$/;"	v
rand	lib/rand.cpp	/^int rand(void) {$/;"	f
random_bytes	crypto/kyber.cpp	/^void random_bytes(std::span<std::byte> buffer) {$/;"	f	namespace:pq::kyber::__anon21
randombytes	crypto/kyber_impl/randombytes.c	/^void randombytes(uint8_t *out, size_t outlen) {$/;"	f
randombytes	tests/randombytes_stub.c	/^void randombytes(uint8_t *out, size_t outlen) {$/;"	f
randombytes_buf	tests/sodium_stub.cpp	/^void randombytes_buf(void *buf, size_t size) {$/;"	f
rate	kernel/floppy.cpp	/^PRIVATE int rate[NT] = {0x02, 0x02, 0x01, 0x00};                      \/* 250,300,500 kbps*\/$/;"	v
rc	commands/sum.cpp	/^int rc = 0;$/;"	v
rd_only	fs/param.hpp	31;"	d
rdahed_inode	fs/glo.hpp	/^EXTERN struct inode *rdahed_inode; \/* pointer to inode to read ahead *\/$/;"	v	typeref:struct:inode
rdahedpos	fs/glo.hpp	/^EXTERN file_pos rdahedpos;         \/* position to read ahead *\/$/;"	v
rdwt_err	fs/read.cpp	/^PUBLIC int rdwt_err;   \/* set to ErrorCode::EIO if disk error occurs *\/$/;"	v
rdy_head	kernel/proc.hpp	/^EXTERN struct proc *rdy_head[NR_CPUS][SCHED_QUEUES]; \/* per-CPU ready list heads *\/$/;"	v	typeref:struct:proc
rdy_tail	kernel/proc.hpp	/^EXTERN struct proc *rdy_tail[NR_CPUS][SCHED_QUEUES]; \/* per-CPU ready list tails *\/$/;"	v	typeref:struct:proc
read	include/minix/io/file_operations.hpp	/^    read = 1 << 0,$/;"	m	class:minix::io::OpenMode
read	include/minix/io/stream.hpp	/^    virtual std::expected<size_t, std::error_code> read(std::span<std::byte> buffer) {$/;"	f	class:minix::io::Stream
read	lib/io/src/file_stream.cpp	/^Result<size_t> FileStream::read(std::byte *buffer, size_t length) {$/;"	f	class:minix::io::FileStream
read	lib/io/src/memory_stream.cpp	/^Result<size_t> MemoryStream::read(std::byte *buffer, size_t length) {$/;"	f	class:minix::io::MemoryStream
read	lib/read.cpp	/^ssize_t read(int fd, void *buffer, size_t nbytes) { \/\/ Changed signature$/;"	f
read_ahead	fs/read.cpp	/^PUBLIC void read_ahead() { \/\/ Modernized signature (was already using ())$/;"	f
read_chars	commands/sort.cpp	/^    int read_chars; \/* Nr of chars actually read in buffer*\/$/;"	m	struct:MERGE	file:
read_double_indirect_zones	tools/fsck.cpp	/^    read_double_indirect_zones(diskio::DiskInterface &disk, const SuperBlock &sb,$/;"	f	class:minix::fsck::ZoneLevel::Inode	file:
read_header	mm/exec.cpp	/^PRIVATE int read_header(int fd, int *ft, std::size_t *text_bytes, std::size_t *data_bytes,$/;"	f
read_indirect_zones	tools/fsck.cpp	/^    [[nodiscard]] std::vector<zone_nr> read_indirect_zones(diskio::DiskInterface &disk,$/;"	f	class:minix::fsck::ZoneLevel::Inode	file:
read_map	fs/read.cpp	/^PUBLIC uint16_t read_map(struct inode *rip,$/;"	f
read_only	fs/protect.cpp	/^static std::expected<void, std::error_code> read_only(struct inode *ip) {$/;"	f	file:
read_only_	tools/diskio.hpp	/^    bool read_only_;                  \/\/\/< Read-only mode flag$/;"	m	class:DiskInterface
read_sector	tools/build.cpp	/^    void read_sector(std::size_t sector, SectorBuffer &data) {$/;"	f	class:minix::builder::ProgramType::ImageFile
read_sector	tools/diskio.cpp	/^SectorBuffer DiskInterface::read_sector(SectorAddress sector) {$/;"	f	class:diskio::DiskInterface
read_sector_raw	tools/diskio.cpp	/^SectorBuffer DiskInterface::read_sector_raw(SectorAddress sector) {$/;"	f	class:diskio::DiskInterface
read_sectors	tools/diskio.cpp	/^std::vector<SectorBuffer> DiskInterface::read_sectors(SectorAddress start_sector,$/;"	f	class:diskio::DiskInterface
read_write	fs/read.cpp	/^PUBLIC int read_write(int rw_flag) { \/\/ Modernized signature$/;"	f
readc	commands/sh5.cpp	/^int readc() {$/;"	f
readfile	commands/roff.cpp	/^readfile() {$/;"	f
readline	commands/comm.cpp	/^static int readline(int fno) {$/;"	f	file:
readline	commands/roff.cpp	/^readline() {$/;"	f
readreq	commands/roff.cpp	/^int readreq() {$/;"	f
ready	kernel/proc.cpp	/^PUBLIC void ready(struct proc *rp) {$/;"	f
real_grp_id	fs/param.hpp	15;"	d
real_time	include/minix/fs/const.hpp	/^enum class real_time : std::int64_t {};$/;"	c	namespace:minix::fs
real_user_id	fs/param.hpp	32;"	d
realloc	lib/malloc.cpp	/^char *realloc(char *old, unsigned size) {$/;"	f
realtime	kernel/glo.hpp	/^EXTERN real_time realtime; \/* real time clock (real_time -> xinim::time_t) *\/$/;"	v
rear	fs/buf.hpp	/^EXTERN struct buf* rear;  \/\/\/< MRU (most recently used) buffer.$/;"	v	typeref:struct:buf
receiver	kernel/wormhole.hpp	/^    Thread receiver;     \/\/ receiving thread$/;"	m	struct:fastpath::State
receiver_task	tests/test_lattice_blocking.cpp	/^static void receiver_task(int *rc, message *out) { *rc = lattice_recv(2, out); }$/;"	f	file:
reconnect_tcp	kernel/net_driver.cpp	/^static void reconnect_tcp(Remote &rem) {$/;"	f	namespace:net::__anon16
recv	kernel/net_driver.cpp	/^bool recv(Packet &out) {$/;"	f	namespace:net
recv_blocking	commands/svcctl.cpp	/^static void recv_blocking(message &out) {$/;"	f	namespace:svcctl
reduced_wr	kernel/wini.cpp	/^    int reduced_wr; \/* First cylinder with reduced write current *\/$/;"	m	struct:param	file:
reduced_wr	kernel/xt_wini.cpp	/^    int reduced_wr; \/* First cylinder with reduced write current *\/$/;"	m	struct:param	file:
reg_error	commands/mined2.cpp	1251;"	d	file:
reganch	include/regexp.hpp	/^    char reganch;          \/\/\/< If true, pattern is anchored.$/;"	m	struct:regexp
regbol	lib/regexp.cpp	/^static char *regbol;     \/* Beginning of input, for ^ check. *\/$/;"	v	file:
regcode	lib/regexp.cpp	/^static char *regcode; \/* Code-emit pointer; &regdummy = don't. *\/$/;"	v	file:
regcomp	lib/regexp.cpp	/^regexp *regcomp(const char *exp) {$/;"	f
regdummy	lib/regexp.cpp	/^static char regdummy;$/;"	v	file:
regendp	lib/regexp.cpp	/^static char **regendp;   \/* Ditto for endp. *\/$/;"	v	file:
regerror	commands/grep.cpp	/^static void regerror(const char *s) {$/;"	f	file:
regerror	commands/gres.cpp	/^static void regerror(const char *s) {$/;"	f	file:
regex	commands/mined.hpp	/^struct regex {$/;"	s	class:ReturnCode
regex	include/mined.hpp	/^struct regex {$/;"	s	class:ReturnCode
regexec	lib/regexp.cpp	/^int regexec(regexp *prog, const char *string, bool bolflag) {$/;"	f
regexp	include/regexp.hpp	/^struct regexp {$/;"	s
reginput	lib/regexp.cpp	/^static char *reginput;   \/* String-input pointer. *\/$/;"	v	file:
region	commands/sh1.cpp	/^struct region {$/;"	s	file:
register_file_stream	lib/io/src/stdio_compat.cpp	/^void register_file_stream(FILE *file, Stream *stream) {$/;"	f	namespace:minix::io::compat
register_service	kernel/service.cpp	/^void ServiceManager::register_service(xinim::pid_t pid, const std::vector<xinim::pid_t> &deps,$/;"	f	class:svc::ServiceManager
regmlen	include/regexp.hpp	/^    int regmlen;           \/\/\/< Length of regmust substring.$/;"	m	struct:regexp
regmust	include/regexp.hpp	/^    char *regmust;         \/\/\/< Required substring within the match.$/;"	m	struct:regexp
regnarrate	lib/regexp.cpp	/^int regnarrate = 0;$/;"	v
regnpar	lib/regexp.cpp	/^static int regnpar;    \/* () count. *\/$/;"	v	file:
regparse	lib/regexp.cpp	/^static char *regparse; \/* Input-scan pointer. *\/$/;"	v	file:
regsize	lib/regexp.cpp	/^static long regsize;  \/* Code size. *\/$/;"	v	file:
regstart	include/regexp.hpp	/^    char regstart;         \/\/\/< Required first character, or '\\0'.$/;"	m	struct:regexp
regstartp	lib/regexp.cpp	/^static char **regstartp; \/* Pointer to startp array. *\/$/;"	v	file:
regsub	lib/regsub.cpp	/^void regsub(regexp *prog, const char *source, char *dest) {$/;"	f
rej_uniform	crypto/kyber_impl/indcpa.c	/^static unsigned int rej_uniform(int16_t *r,$/;"	f	file:
release	docs/sphinx/conf.py	/^release = "0.1.0"  # Full version string including patch level$/;"	v
reloc_table	tools/c86/dos2out.cpp	/^	unsigned int	reloc_table;	\/* start of reloc-table in hdr, 1Bh *\/$/;"	m	struct:d_fmt_hdr	file:
rem_dir	commands/rm.cpp	/^static void rem_dir(char *name) {$/;"	f	file:
remove	commands/cc.cpp	86;"	d	file:
remove	commands/mined2.cpp	/^FLAG remove; \/* DELETE if text should be deleted *\/$/;"	v
remove	commands/mined2.cpp	/^move_next_word(remove) FLAG remove;$/;"	v
remove	commands/mined2.cpp	/^move_previous_word(remove) FLAG remove;$/;"	v
remove	commands/mined2.cpp	/^set_up(remove) FLAG remove; \/* DELETE if text should be deleted *\/$/;"	v
remove	commands/rm.cpp	/^static void remove(char *name) {$/;"	f	file:
remove	commands/rmdir.cpp	/^static void remove(char *dirname) {$/;"	f	file:
remove_dependency	kernel/service.cpp	/^void ServiceManager::remove_dependency(xinim::pid_t pid, xinim::pid_t dep) {$/;"	f	class:svc::ServiceManager
rep_fl	commands/ar.cpp	/^BOOL rep_fl;$/;"	v
replacement	commands/mined2.cpp	/^char *replacement; \/* Contains replacement pattern *\/$/;"	v
reply	fs/main.cpp	/^void reply(int whom, int result) {$/;"	f
reply_i1	fs/param.hpp	45;"	d
reply_i1	mm/param.hpp	25;"	d
reply_i2	fs/param.hpp	46;"	d
reply_l1	fs/param.hpp	44;"	d
reply_p1	mm/param.hpp	26;"	d
reply_t1	fs/param.hpp	47;"	d
reply_t2	fs/param.hpp	48;"	d
reply_t3	fs/param.hpp	49;"	d
reply_t4	fs/param.hpp	50;"	d
reply_type	fs/param.hpp	43;"	d
reply_type	mm/param.hpp	24;"	d
report	commands/stty.cpp	/^static void report() {$/;"	f	file:
report_error	tests/test_stream_foundation.cpp	/^static void report_error(const char *name, const std::error_code &ec) {$/;"	f	file:
request	commands/roff.cpp	/^char *request[] = {"ad", "ar", "bl", "bp", "br", "cc", "ce", "de", "ds", "ef", "eh", "fi", "fo",$/;"	v
request	fs/param.hpp	33;"	d
res	commands/sh2.cpp	/^struct res {$/;"	s	file:
resb	boot.S	/^resb 8192 ; Reserve 8KB for the stack$/;"	l
reserved0	kernel/idt64.cpp	/^    u32_t reserved0;$/;"	m	struct:tss64	file:
reserved1	kernel/idt64.cpp	/^    u64_t reserved1;$/;"	m	struct:tss64	file:
reserved2	kernel/idt64.cpp	/^    u64_t reserved2;$/;"	m	struct:tss64	file:
reserved3	kernel/idt64.cpp	/^    u16_t reserved3;$/;"	m	struct:tss64	file:
resize	tools/diskio.hpp	/^    void resize(std::size_t new_size) {$/;"	f	class:SectorBuffer
restab	commands/sh2.cpp	/^} restab[] = {$/;"	v	typeref:struct:res
restart	kernel/mpx64.cpp	/^void restart(void) {$/;"	f
restart_tree	kernel/service.cpp	/^void ServiceManager::restart_tree(xinim::pid_t pid, std::unordered_set<xinim::pid_t> &visited) {$/;"	f	class:svc::ServiceManager
restline	commands/make.cpp	/^char *fword, *restline, line[INMAX], backup[INMAX];$/;"	v
result	commands/mined.hpp	/^    } result;$/;"	m	struct:ReturnCode::regex	typeref:union:ReturnCode::regex::__anon27
result	commands/mined1.cpp	/^int *result;$/;"	v
result	include/mined.hpp	/^    } result;$/;"	m	struct:ReturnCode::regex	typeref:union:ReturnCode::regex::__anon19
rev	commands/rev.cpp	/^static void rev(void) {$/;"	f	file:
rev_scroll	commands/mined1.cpp	/^char *rev_scroll = "\\033~1";         \/* String for reverse scrolling *\/$/;"	v
rev_video	commands/mined1.cpp	/^char *rev_video = "\\033z\\160";       \/* String for starting reverse video *\/$/;"	v
reverse	commands/sort.cpp	/^    BOOL reverse;           \/* TRUE if rev. flag set on this field*\/$/;"	m	struct:FIELD	file:
reverse_scroll	commands/mined2.cpp	/^reverse_scroll() {$/;"	f
reversed	commands/ls.cpp	/^static int reversed(int i, int j, int expand_flag) {$/;"	f	file:
revfl	commands/mined1.cpp	/^bottom_line(revfl, s1, s2, inbuf, statfl) FLAG revfl;$/;"	v
reviving	fs/glo.hpp	/^EXTERN int reviving;               \/* number of pipe processes to be revived *\/$/;"	v
rewind	include/stdio.hpp	66;"	d
rflag	commands/rm.cpp	/^int rflag = 0;$/;"	v
right	include/sh.hpp	/^    struct op *right;$/;"	m	struct:op	typeref:struct:op::op
ring_bell	commands/mined.hpp	184;"	d
ring_bell	include/mined.hpp	177;"	d
rip	fs/link.cpp	/^register struct inode *rip; \/* pointer to inode to be truncated *\/$/;"	v	typeref:struct:inode
rip	fs/pipe.cpp	/^register struct inode *rip;  \/* the inode of the pipe *\/$/;"	v	typeref:struct:inode
rip	fs/stadir.cpp	/^register struct inode *rip; \/* pointer to inode to stat *\/$/;"	v	typeref:struct:inode
rip	fs/super.cpp	/^register struct inode *rip; \/* pointer to inode *\/$/;"	v	typeref:struct:inode
rkprf	crypto/kyber_impl/symmetric.h	31;"	d
rmfiles	test/test10.cpp	/^rmfiles() {$/;"	f
rmp	mm/forkexit.cpp	/^register struct mproc *rmp; \/* pointer to the process to be terminated *\/$/;"	v	typeref:struct:mproc
rng_state	mm/vm.cpp	/^static unsigned long rng_state = 1;$/;"	v	file:
root	commands/dosread.cpp	/^DIRECTORY root[MAX_ROOT_ENTRIES];$/;"	v
root_entries	commands/dosread.cpp	/^short total_clusters, cluster_size, fat_size, root_entries, data_start, sub_entries;$/;"	v
rpipe	commands/mined1.cpp	/^FLAG rpipe = FALSE;          \/* Set if file should be read from stdin *\/$/;"	v
rsp0	kernel/idt64.cpp	/^    u64_t rsp0;$/;"	m	struct:tss64	file:
rsp1	kernel/idt64.cpp	/^    u64_t rsp1;$/;"	m	struct:tss64	file:
rsp2	kernel/idt64.cpp	/^    u64_t rsp2;$/;"	m	struct:tss64	file:
rule	commands/make.cpp	/^    struct llist *rule;$/;"	m	struct:rulerec	typeref:struct:rulerec::llist	file:
rule_ready	commands/make.cpp	/^int sending, def_ready, gdone, rule_send, rule_ready;$/;"	v
rule_send	commands/make.cpp	/^int sending, def_ready, gdone, rule_send, rule_ready;$/;"	v
rulelist	commands/make.cpp	/^struct rulerec *rulelist = NULL;$/;"	v	typeref:struct:rulerec
rulerec	commands/make.cpp	/^struct rulerec {$/;"	s	file:
run	commands/svcctl.cpp	/^int run(std::span<char *> args) {$/;"	f	namespace:svcctl
run	tools/fsck.cpp	/^    int run(int argc, char *argv[]) {$/;"	f	class:minix::fsck::ZoneLevel::FsckApplication
runtrap	commands/sh1.cpp	/^runtrap(i) {$/;"	f
runvec	commands/cc.cpp	/^static int runvec(struct arglist *vec, char *outp) {$/;"	f	file:
runvec2	commands/cc.cpp	/^static int runvec2(struct arglist *vec0, struct arglist *vec1) {$/;"	f	file:
rw_chunk	fs/read.cpp	/^static int rw_chunk(struct inode *rip, int32_t position, std::size_t off, std::size_t chunk,$/;"	f	file:
rw_flag	fs/device.cpp	/^int rw_flag; \/* READING or WRITING *\/$/;"	v
rw_flag	fs/pipe.cpp	/^int rw_flag;                 \/* READING or WRITING *\/$/;"	v
rw_flag	fs/super.cpp	/^int rw_flag;                     \/* READING or WRITING *\/$/;"	v
rw_inode	fs/inode.cpp	/^PUBLIC void rw_inode(struct inode *rip, int rw_flag) { \/\/ Added void return, modernized params$/;"	f
rw_user	fs/read.cpp	/^PUBLIC int rw_user(int s, int u, std::size_t vir, std::size_t bytes, char *buff, int direction) {$/;"	f
rwx	commands/ls.cpp	/^char *rwx[] = {"---", "--x", "-w-", "-wx", "r--", "r-x", "rw-", "rwx",$/;"	v
s	commands/make.cpp	/^    char *s;$/;"	v
s	commands/make.cpp	/^char *s, *p;$/;"	v
s	commands/make.cpp	/^char *s, *where;$/;"	v
s	commands/make.cpp	/^char *s;$/;"	v
s	commands/make.cpp	/^readmakefile(s) char *s;$/;"	v
s	commands/mkfs.cpp	/^char *s;$/;"	v
s	commands/mkfs.cpp	/^pexit(s) char *s;$/;"	v
s	commands/roff.cpp	/^char *s;$/;"	v
s	commands/roff.cpp	/^dehyph(s) char *s;$/;"	v
s	commands/roff.cpp	/^int *i, *s, sdef;$/;"	v
s	commands/roff.cpp	/^spits(s) char *s;$/;"	v
s	commands/roff.cpp	/^tread(s) char *s;$/;"	v
s	commands/sh1.cpp	/^err(s) char *s;$/;"	v
s	commands/sh1.cpp	/^newfile(s) register char *s;$/;"	v
s	commands/sh1.cpp	/^register char *s, *p;$/;"	v
s	commands/sh1.cpp	/^register char *s;$/;"	v
s	commands/sh1.cpp	/^warn(s) register char *s;$/;"	v
s	commands/sh1.cpp	/^xfree(s) register char *s;$/;"	v
s	commands/sh2.cpp	/^    char *s;$/;"	v
s	commands/sh2.cpp	/^yyerror(s) char *s;$/;"	v
s	commands/sh3.cpp	/^getsig(s) char *s;$/;"	v
s	commands/sh3.cpp	/^int (*inbuilt(s))() register char *s;$/;"	v
s	commands/sh3.cpp	/^register int s;$/;"	v
s	commands/sh3.cpp	/^static void badid(s) register char *s;$/;"	v
s	commands/sh3.cpp	/^varput(s, out) register char *s;$/;"	v
s	commands/sh5.cpp	/^markhere(s, iop) register char *s;$/;"	v
s	commands/sh5.cpp	/^register char *s;$/;"	v
s	commands/sh5.cpp	/^void prs(s) register char *s;$/;"	v
s	commands/uniq.cpp	/^char *s;$/;"	v
s	crypto/kyber_impl/fips202.h	/^  uint64_t s[25];$/;"	m	struct:__anon23
s	kernel/klib64.cpp	/^    const int *s = src_off;$/;"	v
s	lib/perror.cpp	/^perror(s) char *s;$/;"	v
s	lib/rindex.cpp	/^register char *s, c;$/;"	v
s	test/test4.cpp	/^int pid0, pid1, pid2, pid3, s;$/;"	v
s	tools/mkfs.cpp	/^char *s;$/;"	v
s	tools/mkfs.cpp	/^pexit(s) char *s;$/;"	v
s1	commands/libpack.cpp	/^register char *s1, *s2;$/;"	v
s1	commands/ls.cpp	/^char *s1, *s2;$/;"	v
s1	commands/make.cpp	/^error(s1) char *s1;$/;"	v
s1	commands/make.cpp	/^error2(s1, s2) char *s1, *s2;$/;"	v
s1	commands/make.cpp	/^panic(s1) char *s1;$/;"	v
s1	commands/make.cpp	/^panic2(s1, s2) char *s1, *s2;$/;"	v
s1	commands/mined1.cpp	/^char *s1, *s2;$/;"	v
s1	commands/sh1.cpp	/^register char *s1, *s2;$/;"	v
s1	commands/stty.cpp	/^char *s1, *s2;$/;"	v
s1	commands/tar.cpp	/^error(s1, s2) char *s1, *s2;$/;"	v
s1	commands/uniq.cpp	/^char *s1, *s2;$/;"	v
s1	lib/regexp.cpp	/^char *s1;$/;"	v
s1	lib/strcat.cpp	/^register char *s1, *s2;$/;"	v
s1	lib/strncat.cpp	/^register char *s1, *s2;$/;"	v
s1	lib/strncmp.cpp	/^register char *s1, *s2;$/;"	v
s1	lib/strncpy.cpp	/^register char *s1, *s2;$/;"	v
s2	commands/libpack.cpp	/^register char *s1, *s2;$/;"	v
s2	commands/ls.cpp	/^char *s1, *s2;$/;"	v
s2	commands/make.cpp	/^error2(s1, s2) char *s1, *s2;$/;"	v
s2	commands/make.cpp	/^panic2(s1, s2) char *s1, *s2;$/;"	v
s2	commands/mined1.cpp	/^char *s1, *s2;$/;"	v
s2	commands/sh1.cpp	/^register char *s1, *s2;$/;"	v
s2	commands/stty.cpp	/^char *s1, *s2;$/;"	v
s2	commands/tar.cpp	/^error(s1, s2) char *s1, *s2;$/;"	v
s2	commands/uniq.cpp	/^char *s1, *s2;$/;"	v
s2	lib/regexp.cpp	/^char *s2;$/;"	v
s2	lib/strcat.cpp	/^register char *s1, *s2;$/;"	v
s2	lib/strncat.cpp	/^register char *s1, *s2;$/;"	v
s2	lib/strncmp.cpp	/^register char *s1, *s2;$/;"	v
s2	lib/strncpy.cpp	/^register char *s1, *s2;$/;"	v
s_call	kernel/mpx64.cpp	/^void s_call(void) {$/;"	f
s_call	kernel/mpx88.cpp	/^PUBLIC void s_call(int function, int src_dest, message *m_ptr) {$/;"	f
s_dev	fs/super.hpp	/^    dev_nr s_dev;                    \/* whose super block is this? *\/$/;"	m	struct:super_block
s_dirt	fs/super.hpp	/^    char s_dirt;                     \/* CLEAN or DIRTY *\/$/;"	m	struct:super_block
s_firstdatazone	fs/super.hpp	/^    zone_nr s_firstdatazone;   \/* number of first data zone *\/$/;"	m	struct:super_block
s_firstdatazone	tools/fsck.cpp	/^    zone_nr s_firstdatazone;$/;"	m	struct:dsb	file:
s_imap	fs/super.hpp	/^    struct buf *s_imap[I_MAP_SLOTS]; \/* pointers to the in-core inode bit map *\/$/;"	m	struct:super_block	typeref:struct:super_block::buf
s_imap_blocks	fs/super.hpp	/^    unshort s_imap_blocks;     \/* # of blocks used by inode bit map *\/$/;"	m	struct:super_block
s_imap_blocks	tools/fsck.cpp	/^    std::uint16_t s_imap_blocks;$/;"	m	struct:dsb	file:
s_imount	fs/super.hpp	/^    struct inode *s_imount;          \/* inode mounted on *\/$/;"	m	struct:super_block	typeref:struct:super_block::inode
s_isup	fs/super.hpp	/^    struct inode *s_isup;            \/* inode for root dir of mounted file sys *\/$/;"	m	struct:super_block	typeref:struct:super_block::inode
s_log_zone_size	fs/super.hpp	/^    short int s_log_zone_size; \/* log2 of blocks\/zone *\/$/;"	m	struct:super_block
s_log_zone_size	tools/fsck.cpp	/^    std::uint16_t s_log_zone_size;$/;"	m	struct:dsb	file:
s_magic	fs/super.hpp	/^    int s_magic;               \/* magic number to recognize super-blocks *\/$/;"	m	struct:super_block
s_magic	tools/fsck.cpp	/^    std::uint16_t s_magic;$/;"	m	struct:dsb	file:
s_max_size	fs/super.hpp	/^    file_pos s_max_size;       \/* maximum file size on this device *\/$/;"	m	struct:super_block
s_max_size64	fs/super.hpp	/^    file_pos64 s_max_size64;   \/* 64-bit maximum file size *\/$/;"	m	struct:super_block
s_maxsize	tools/fsck.cpp	/^    file_pos s_maxsize;$/;"	m	struct:dsb	file:
s_ninodes	fs/super.hpp	/^    inode_nr s_ninodes;        \/* # usable inodes on the minor device *\/$/;"	m	struct:super_block
s_ninodes	tools/fsck.cpp	/^    inode_nr s_ninodes;$/;"	m	struct:dsb	file:
s_nzones	fs/super.hpp	/^    zone_nr s_nzones;          \/* total device size, including bit maps etc *\/$/;"	m	struct:super_block
s_nzones	tools/fsck.cpp	/^    zone_nr s_nzones;$/;"	m	struct:dsb	file:
s_p_day	commands/date.cpp	/^long s_p_day;$/;"	v
s_p_hour	commands/date.cpp	/^long s_p_hour;$/;"	v
s_p_min	commands/date.cpp	/^long s_p_min;$/;"	v
s_p_year	commands/date.cpp	/^long s_p_year;$/;"	v
s_rd_only	fs/super.hpp	/^    char s_rd_only;                  \/* set to 1 iff file sys mounted read only *\/$/;"	m	struct:super_block
s_time	fs/super.hpp	/^    real_time s_time;                \/* time of last update *\/$/;"	m	struct:super_block
s_zmap	fs/super.hpp	/^    struct buf *s_zmap[ZMAP_SLOTS];  \/* pointers to the in-core zone bit map *\/$/;"	m	struct:super_block	typeref:struct:super_block::buf
s_zmap_blocks	fs/super.hpp	/^    unshort s_zmap_blocks;     \/* # of blocks used by zone bit map *\/$/;"	m	struct:super_block
s_zmap_blocks	tools/fsck.cpp	/^    std::uint16_t s_zmap_blocks;$/;"	m	struct:dsb	file:
save	kernel/mpx64.cpp	/^void save(void) {$/;"	f
save	kernel/service.cpp	/^void ServiceManager::save(std::string_view path) const {$/;"	f	class:svc::ServiceManager
save_entry	commands/dosread.cpp	/^DIRECTORY save_entry;$/;"	v
save_to_disk	tools/fsck.cpp	/^    void save_to_disk(diskio::DiskInterface &disk) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
save_to_disk	tools/fsck.cpp	/^    void save_to_disk(diskio::DiskInterface &disk, const SuperBlock &sb) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
save_to_disk	tools/fsck.cpp	/^    void save_to_disk(diskio::DiskInterface &disk, diskio::SectorAddress start_block,$/;"	f	class:minix::fsck::ZoneLevel::Bitmap
sb_	tools/fsck.cpp	/^    struct dsb sb_;$/;"	m	class:minix::fsck::ZoneLevel::SuperBlock	typeref:struct:minix::fsck::ZoneLevel::SuperBlock::dsb	file:
sbrk	lib/brk.cpp	/^char *sbrk(int incr) {$/;"	f
scan	tools/find_knr.py	/^def scan(root: str) -> list[Path]:$/;"	f
scan_clang_features	tools/arch_scan.py	/^def scan_clang_features(text: str) -> List[str]:$/;"	f
scan_code	kernel/tty.cpp	/^PUBLIC scan_code;                                 \/* scan code for '=' saved by bootstrap *\/$/;"	v
scanf	lib/scanf.cpp	/^int scanf(const char *format, ...) {$/;"	f
sched	kernel/proc.cpp	/^PUBLIC void sched() { \/\/ Modernized signature$/;"	f
sched	kernel/schedule.cpp	/^namespace sched {$/;"	n	file:
sched	kernel/schedule.hpp	/^namespace sched {$/;"	n
sched	kernel/service.hpp	/^namespace sched {$/;"	n
sched_ticks	kernel/clock.cpp	/^PRIVATE int sched_ticks = SCHED_RATE;     \/* counter: when 0, call scheduler *\/$/;"	v
scopy	commands/sh4.cpp	377;"	d	file:
scraphere	commands/sh5.cpp	/^scraphere() { herelist = NULL; }$/;"	f
screen	commands/mined1.cpp	/^char screen[SCREEN_SIZE]; \/* Output buffer for "writes" and "reads" *\/$/;"	v
screen_y	commands/mined1.cpp	/^int screen_y;$/;"	v
scroll_screen	console.cpp	/^static void scroll_screen() {$/;"	f	file:
sdef	commands/roff.cpp	/^int *i, *s, sdef;$/;"	v
search	commands/sh1.cpp	/^char search[] = ":\/bin:\/usr\/bin";$/;"	v
search_dir	fs/path.cpp	/^int search_dir(struct inode *ldir_ptr, char string[NAME_SIZE], inode_nr *numb, int flag) {$/;"	f
sec	commands/date.cpp	/^    int year, month, day, hour, min, sec;$/;"	m	struct:__anon25	file:
seconds	mm/param.hpp	16;"	d
secret_key	include/pqcrypto.hpp	/^    std::array<std::uint8_t, pqcrystals_kyber512_SECRETKEYBYTES> secret_key; \/\/\/< Kyber private key$/;"	m	struct:pqcrypto::KeyPair
section	boot.S	/^section .bss$/;"	l
section	boot.S	/^section .multiboot_header$/;"	l
section	boot.S	/^section .text$/;"	l
sectnum	commands/mkfs.cpp	/^dexit(s, sectnum, err) int sectnum, err;$/;"	v
sectnum	tools/mkfs.cpp	/^dexit(s, sectnum, err) int sectnum, err;$/;"	v
sector_	tools/diskio.hpp	/^    SectorAddress sector_;$/;"	m	class:DiskIoError
sector_buffer	tools/bootblok1.cpp	/^    std::array<u8_t, SECTOR_SIZE> sector_buffer;$/;"	m	class:minix::bootloader::BootSector	file:
seed	lib/rand.cpp	/^static long seed = 1L;$/;"	v	file:
seek	commands/dosread.cpp	/^unsigned long seek;$/;"	v
seek	lib/io/src/memory_stream.cpp	/^void MemoryStream::seek(size_t pos) { pos_ = std::min(pos, buffer_.size()); }$/;"	f	class:minix::io::MemoryStream
seen	commands/uniq.cpp	/^int seen;$/;"	v
seeneof	commands/comm.cpp	/^    int seeneof;      \/* an end of file has been seen *\/$/;"	m	struct:file	file:
selector	kernel/idt64.cpp	/^    u16_t selector;$/;"	m	struct:idt_entry	file:
semantic_code_tag	include/psd/vm/semantic_memory.hpp	/^struct semantic_code_tag {};$/;"	s	namespace:psd::vm
semantic_data_tag	include/psd/vm/semantic_memory.hpp	/^struct semantic_data_tag {};$/;"	s	namespace:psd::vm
semantic_heap_tag	include/psd/vm/semantic_memory.hpp	/^struct semantic_heap_tag {};$/;"	s	namespace:psd::vm
semantic_matrix_tag	include/psd/vm/semantic_memory.hpp	/^struct semantic_matrix_tag {};$/;"	s	namespace:psd::vm
semantic_message_tag	include/psd/vm/semantic_memory.hpp	/^struct semantic_message_tag {};$/;"	s	namespace:psd::vm
semantic_region	include/psd/vm/semantic_memory.hpp	/^template <typename SemanticTag> class semantic_region {$/;"	c	namespace:psd::vm
semantic_stack_tag	include/psd/vm/semantic_memory.hpp	/^struct semantic_stack_tag {};$/;"	s	namespace:psd::vm
semantic_traits	include/psd/vm/semantic_memory.hpp	/^template <> struct semantic_traits<semantic_code_tag> {$/;"	s	namespace:psd::vm
semantic_traits	include/psd/vm/semantic_memory.hpp	/^template <> struct semantic_traits<semantic_message_tag> {$/;"	s	namespace:psd::vm
semantic_traits	include/psd/vm/semantic_memory.hpp	/^template <> struct semantic_traits<semantic_stack_tag> {$/;"	s	namespace:psd::vm
semantic_traits	include/psd/vm/semantic_memory.hpp	/^template <typename Tag> struct semantic_traits {$/;"	s	namespace:psd::vm
send	kernel/net_driver.cpp	/^std::errc send(node_t node, std::span<const std::byte> data) {$/;"	f	namespace:net
send_ack	tests/test_svcctl.cpp	/^    void send_ack() {$/;"	f	class:MockServiceManager	file:
send_simple	commands/svcctl.cpp	/^static void send_simple(Message type, xinim::pid_t pid) {$/;"	f	namespace:svcctl
sender	kernel/wormhole.hpp	/^    Thread sender;       \/\/ sending thread$/;"	m	struct:fastpath::State
sending	commands/make.cpp	/^int sending, def_ready, gdone, rule_send, rule_ready;$/;"	v
separator	commands/sort.cpp	/^char separator;      \/* Char that separates fields *\/$/;"	v
sept	commands/cal.cpp	/^    int sept;          \/* Days in September for this month	*\/$/;"	m	struct:__anon29	file:
services	tests/test_svcctl.cpp	/^    std::unordered_map<xinim::pid_t, bool> services; \/\/\/< Running state per service$/;"	m	class:MockServiceManager	file:
set_bit	tools/fsck.cpp	/^    void set_bit(BitNumber bit) {$/;"	f	class:minix::fsck::ZoneLevel::Bitmap
set_busy	commands/mined1.cpp	1143;"	d	file:
set_byte	tools/build.cpp	/^    void set_byte(std::size_t offset, std::uint8_t value) {$/;"	f	class:minix::builder::ProgramType::SectorBuffer
set_first_data_zone	tools/fsck.cpp	/^    void set_first_data_zone(zone_nr zone) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
set_gid	tools/fsck.cpp	/^    void set_gid(std::uint8_t gid) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
set_imap_blocks	tools/fsck.cpp	/^    void set_imap_blocks(std::uint16_t blocks) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
set_inode_count	tools/fsck.cpp	/^    void set_inode_count(inode_nr count) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
set_log_zone_size	tools/fsck.cpp	/^    void set_log_zone_size(std::uint16_t size) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
set_max_file_size	tools/fsck.cpp	/^    void set_max_file_size(file_pos size) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
set_mode	tools/fsck.cpp	/^    void set_mode(std::uint16_t mode) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
set_mtime	tools/fsck.cpp	/^    void set_mtime(std::uint32_t mtime) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
set_nlinks	tools/fsck.cpp	/^    void set_nlinks(std::uint8_t nlinks) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
set_recv_callback	kernel/net_driver.cpp	/^void set_recv_callback(RecvCallback cb) { g_callback = std::move(cb); }$/;"	f	namespace:net
set_restart_limit	kernel/service.cpp	/^void ServiceManager::set_restart_limit(xinim::pid_t pid, std::uint32_t limit) {$/;"	f	class:svc::ServiceManager
set_size	tools/fsck.cpp	/^    void set_size(std::uint32_t size) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
set_time	commands/date.cpp	/^static void set_time(char *t) {$/;"	f	file:
set_uid	tools/fsck.cpp	/^    void set_uid(std::uint16_t uid) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
set_zmap_blocks	tools/fsck.cpp	/^    void set_zmap_blocks(std::uint16_t blocks) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
set_zone	tools/fsck.cpp	/^    void set_zone(std::size_t index, zone_nr zone) {$/;"	f	class:minix::fsck::ZoneLevel::Inode
set_zone_count	tools/fsck.cpp	/^    void set_zone_count(zone_nr count) {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
setdash	commands/sh1.cpp	/^setdash() {$/;"	f
setgid	lib/setgid.cpp	/^int setgid(int grp) { return callm1(MM, SETGID, grp, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
setgrent	lib/getgrent.cpp	/^int setgrent() {$/;"	f
setjmp	include/setjmp.hpp	/^inline int setjmp(jmp_buf env) { return std::setjmp(env); } \/\/ std::setjmp is not noexcept$/;"	f
setmonth	commands/cal.cpp	/^static void setmonth(int year, int month)$/;"	f	file:
setpwent	lib/getpwent.cpp	/^int setpwent(void) {$/;"	f
setuid	lib/setuid.cpp	/^int setuid(int usr) { return callm1(MM, SETUID, usr, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
sfile	commands/cc.cpp	/^USTRING ifile, kfile, sfile, mfile, ofile;$/;"	v
sflag	commands/cmp.cpp	/^unshort lflag, sflag;$/;"	v
sflag	commands/roff.cpp	/^int sflag, hflag, startpage, stoppage;$/;"	v
sg_erase	include/sgtty.hpp	/^    char sg_erase;  \/* erase character *\/$/;"	m	struct:sgttyb
sg_flags	include/sgtty.hpp	/^    int sg_flags;   \/* mode flags *\/$/;"	m	struct:sgttyb
sg_ispeed	include/sgtty.hpp	/^    char sg_ispeed; \/* input speed (not used) *\/$/;"	m	struct:sgttyb
sg_kill	include/sgtty.hpp	/^    char sg_kill;   \/* kill character *\/$/;"	m	struct:sgttyb
sg_ospeed	include/sgtty.hpp	/^    char sg_ospeed; \/* output speed (not used) *\/$/;"	m	struct:sgttyb
sgttyb	include/sgtty.hpp	/^struct sgttyb {$/;"	s
sh	kernel/tty.cpp	/^PRIVATE char sh[] = {0,    033,  '!',  '@',  '#',  '$',  '%',  '^',  '&',  '*',  '(',  ')',$/;"	v
sha3_256	crypto/kyber_impl/fips202.c	/^void sha3_256(uint8_t h[32], const uint8_t *in, size_t inlen)$/;"	f
sha3_256	crypto/kyber_impl/fips202.h	49;"	d
sha3_512	crypto/kyber_impl/fips202.c	/^void sha3_512(uint8_t h[64], const uint8_t *in, size_t inlen)$/;"	f
sha3_512	crypto/kyber_impl/fips202.h	51;"	d
shake128	crypto/kyber_impl/fips202.c	/^void shake128(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)$/;"	f
shake128	crypto/kyber_impl/fips202.h	45;"	d
shake128_absorb	crypto/kyber_impl/fips202.c	/^void shake128_absorb(keccak_state *state, const uint8_t *in, size_t inlen)$/;"	f
shake128_absorb	crypto/kyber_impl/fips202.h	21;"	d
shake128_absorb_once	crypto/kyber_impl/fips202.c	/^void shake128_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen)$/;"	f
shake128_absorb_once	crypto/kyber_impl/fips202.h	27;"	d
shake128_finalize	crypto/kyber_impl/fips202.c	/^void shake128_finalize(keccak_state *state)$/;"	f
shake128_finalize	crypto/kyber_impl/fips202.h	23;"	d
shake128_init	crypto/kyber_impl/fips202.c	/^void shake128_init(keccak_state *state)$/;"	f
shake128_init	crypto/kyber_impl/fips202.h	19;"	d
shake128_squeeze	crypto/kyber_impl/fips202.c	/^void shake128_squeeze(uint8_t *out, size_t outlen, keccak_state *state)$/;"	f
shake128_squeeze	crypto/kyber_impl/fips202.h	25;"	d
shake128_squeezeblocks	crypto/kyber_impl/fips202.c	/^void shake128_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state)$/;"	f
shake128_squeezeblocks	crypto/kyber_impl/fips202.h	29;"	d
shake256	crypto/kyber_impl/fips202.c	/^void shake256(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)$/;"	f
shake256	crypto/kyber_impl/fips202.h	47;"	d
shake256_absorb	crypto/kyber_impl/fips202.c	/^void shake256_absorb(keccak_state *state, const uint8_t *in, size_t inlen)$/;"	f
shake256_absorb	crypto/kyber_impl/fips202.h	34;"	d
shake256_absorb_once	crypto/kyber_impl/fips202.c	/^void shake256_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen)$/;"	f
shake256_absorb_once	crypto/kyber_impl/fips202.h	40;"	d
shake256_finalize	crypto/kyber_impl/fips202.c	/^void shake256_finalize(keccak_state *state)$/;"	f
shake256_finalize	crypto/kyber_impl/fips202.h	36;"	d
shake256_init	crypto/kyber_impl/fips202.c	/^void shake256_init(keccak_state *state)$/;"	f
shake256_init	crypto/kyber_impl/fips202.h	32;"	d
shake256_squeeze	crypto/kyber_impl/fips202.c	/^void shake256_squeeze(uint8_t *out, size_t outlen, keccak_state *state)$/;"	f
shake256_squeeze	crypto/kyber_impl/fips202.h	38;"	d
shake256_squeezeblocks	crypto/kyber_impl/fips202.c	/^void shake256_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state)$/;"	f
shake256_squeezeblocks	crypto/kyber_impl/fips202.h	42;"	d
shell	include/sh.hpp	/^struct var *shell;   \/* shell to interpret command files *\/$/;"	v	typeref:struct:var
shellname	commands/sh1.cpp	/^char shellname[] = "\/bin\/sh";$/;"	v
shift1	kernel/tty.cpp	/^PRIVATE int shift1, shift2, capslock, numlock;    \/* keep track of shift keys *\/$/;"	v
shift2	kernel/tty.cpp	/^PRIVATE int shift1, shift2, capslock, numlock;    \/* keep track of shift keys *\/$/;"	v
shift_count	commands/mined.hpp	/^    unsigned char shift_count;$/;"	m	struct:ReturnCode::Line
shift_count	include/mined.hpp	/^    unsigned char shift_count;$/;"	m	struct:ReturnCode::Line
shndx	multiboot.h	/^    uint32_t shndx; \/\/ String table index$/;"	m	struct:multiboot_tag_elf_sections
shobj	commands/Makefile	/^shobj = sh1.s sh2.s sh3.s sh4.s sh5.s$/;"	m
show	commands/ar.cpp	/^static void show(char c, char *name) {$/;"	f	file:
show	commands/uniq.cpp	/^static void show(char *line, int count) {$/;"	f	file:
show_fl	commands/ar.cpp	/^BOOL show_fl;$/;"	v
show_fl	commands/tar.cpp	/^BOOL show_fl, creat_fl, ext_fl;$/;"	v
si	commands/sort.cpp	/^incr(si, ei) register int si, ei;$/;"	v
sig	fs/param.hpp	34;"	d
sig	mm/param.hpp	17;"	d
sig_info	kernel/type.hpp	/^struct sig_info {$/;"	s
sig_procs	kernel/glo.hpp	/^EXTERN int sig_procs;          \/* number of procs with p_pending != 0 *\/$/;"	v
sig_stuff	kernel/system.cpp	/^PRIVATE char sig_stuff[SIG_PUSH_BYTES]; \/* used to send signals to processes *\/$/;"	v
sigct	test/test3.cpp	/^int sigct, cumsig, errct;$/;"	v
sigmap	test/test5.cpp	/^int sigmap[5] = {9, 10, 11};$/;"	v
signal	lib/signal.cpp	/^sighandler_t signal(int signr, sighandler_t func) {$/;"	f
signame	commands/sh3.cpp	/^static char *signame[] = {$/;"	v	file:
signo	kernel/type.hpp	/^    int signo;$/;"	m	struct:sig_info
sigpcpsw	kernel/type.hpp	/^    struct pc_psw sigpcpsw;$/;"	m	struct:sig_info	typeref:struct:sig_info::pc_psw
sigpip	test/test3.cpp	/^sigpip() {$/;"	f
silentf	commands/make.cpp	/^int silentf = FALSE;$/;"	v
simple	commands/mkfs.cpp	/^                                      simple = 0;$/;"	v
simple	commands/sh2.cpp	/^static struct op *simple() {$/;"	f	file:
simple	tools/mkfs.cpp	/^                                      simple = 0;$/;"	v
size	commands/ls.cpp	/^    long size;$/;"	m	struct:file	file:
size	commands/make.cpp	/^UI size;$/;"	v
size	commands/mined1.cpp	/^unsigned size;$/;"	v
size	commands/sh2.cpp	/^unsigned size;$/;"	v
size	commands/size.cpp	/^static void size(const char *name) {$/;"	f	file:
size	commands/sort.cpp	/^register long size;        \/* Size of file *\/$/;"	v
size	commands/sort.cpp	/^register unsigned size;$/;"	v
size	kernel.cpp	/^    uint32_t size;$/;"	m	struct:multiboot_tag_string	file:
size	multiboot.h	/^    uint32_t size;$/;"	m	struct:multiboot_tag
size	multiboot.h	/^    uint32_t size;$/;"	m	struct:multiboot_tag_basic_meminfo
size	multiboot.h	/^    uint32_t size;$/;"	m	struct:multiboot_tag_elf_sections
size	multiboot.h	/^    uint32_t size;$/;"	m	struct:multiboot_tag_mmap
size	test/test10.cpp	/^int size;$/;"	v
size_fmt	commands/mkfs.cpp	/^char *size_fmt = "%6D";$/;"	v
size_fmt	tools/mkfs.cpp	/^char *size_fmt = "%6D";$/;"	v
size_ok	mm/break.cpp	/^[[nodiscard]] PUBLIC int size_ok(int file_type, std::size_t tc, std::size_t dc, std::size_t sc,$/;"	f
size_t	include/minix/fs/buffer.hpp	/^    [[nodiscard]] auto flush_dirty_buffers() -> std::size_t;$/;"	m	class:minix::fs::BufferPool::std
size_t	include/minix/fs/inode.hpp	/^    [[nodiscard]] auto flush_dirty_inodes() -> std::size_t;$/;"	m	class:minix::fs::InodeType::InodeTable::std
skip	commands/dd.cpp	/^unsigned cbs, bs, skip, nseek, count;$/;"	v
skip_entry	commands/tar.cpp	/^skip_entry() {$/;"	f
skip_page	commands/pr.cpp	/^static int skip_page(int lines, FILE *filep) {$/;"	f	file:
skip_period	lib/getgrent.cpp	/^static void skip_period() {$/;"	f	file:
skip_period	lib/getpwent.cpp	/^static void skip_period(void) {$/;"	f	file:
skipsp	commands/roff.cpp	/^int skipsp() {$/;"	f
slash_fl	commands/dosread.cpp	/^BOOL slash_fl;$/;"	v
sleep	lib/sleep.cpp	/^void sleep(int n) {$/;"	f
slen	lib/perror.cpp	/^static int slen(const char *s) {$/;"	f	file:
slot1	fs/param.hpp	35;"	d
smallest	commands/sort.cpp	/^register MERGE *smallest;$/;"	v
sodium_aead_decrypt	crypto/kyber.cpp	/^std::vector<std::byte> sodium_aead_decrypt($/;"	f	namespace:pq::kyber::__anon21
sodium_aead_encrypt	crypto/kyber.cpp	/^std::vector<std::byte> sodium_aead_encrypt($/;"	f	namespace:pq::kyber::__anon21
sodium_init	tests/sodium_stub.cpp	/^int sodium_init() { return 0; }$/;"	f
sort	commands/ls.cpp	/^static void sort(int index, int count, int expand_flag) {$/;"	f	file:
sort	commands/sort.cpp	/^sort() {$/;"	f
sort_index	commands/ls.cpp	/^short sort_index[NFILE];$/;"	v
sp	fs/super.cpp	/^register struct super_block *sp; \/* pointer to a superblock *\/$/;"	v	typeref:struct:super_block
sp_limit	lib/head.cpp	/^long sp_limit = 0;$/;"	v
sp_limit	lib/minix/head.cpp	/^long sp_limit = 0;$/;"	v
sp_reg	tools/c86/dos2out.cpp	/^	unsigned int	sp_reg;		\/* sp value to be loaded *\/$/;"	m	struct:d_fmt_hdr	file:
spacechars	commands/roff.cpp	/^char spacechars[] = " \\t\\n";$/;"	v
spcl	commands/sh4.cpp	/^static char spcl[] = "[?*";$/;"	v	file:
splimit	kernel/klib88.cpp	/^PUBLIC unsigned splimit = 0;$/;"	v
split	commands/split.cpp	/^static void split() {$/;"	f	file:
squeezesp	commands/make.cpp	/^static void squeezesp(char *to, char *from) {$/;"	f	file:
src	commands/dosread.cpp	/^bcopy(src, dest, bytes) register char *src, *dest;$/;"	v
src	commands/make.cpp	/^char *src, *dest;$/;"	v
src	commands/make.cpp	/^get_element(src, p, dest) char *src, *dest;$/;"	v
src	commands/sort.cpp	/^copy(dest, src) register char *dest, *src;$/;"	v
src	commands/sort.cpp	/^register char *src;                       \/* Source line *\/$/;"	v
src	kernel/lattice_ipc.hpp	/^    xinim::pid_t src; \/\/!< Source process identifier$/;"	m	struct:lattice::Channel
src_click	kernel/klib64.cpp	/^    (void)src_click;$/;"	v
ss_seg	tools/c86/dos2out.cpp	/^	unsigned int	ss_seg;		\/* stack-segment; must be relocated *\/$/;"	m	struct:d_fmt_hdr	file:
sscanf	lib/scanf.cpp	/^int sscanf(const char *str, const char *format, ...) {$/;"	f
st	commands/mv.cpp	/^struct stat st;$/;"	v	typeref:struct:stat
st	commands/tar.cpp	/^register struct stat *st;$/;"	v	typeref:struct:stat
st_atime	commands/make.cpp	/^    TIME st_atime;$/;"	m	struct:stat	file:
st_atime	include/shared/stat_struct.hpp	/^    xinim::time_t st_atime;  \/\/ Was long (xinim::time_t is std::int64_t)$/;"	m	struct:stat
st_ctime	commands/make.cpp	/^    TIME st_ctime;$/;"	m	struct:stat	file:
st_ctime	include/shared/stat_struct.hpp	/^    xinim::time_t st_ctime;  \/\/ Was long$/;"	m	struct:stat
st_dev	commands/make.cpp	/^    short int st_dev;$/;"	m	struct:stat	file:
st_dev	include/shared/stat_struct.hpp	/^    xinim::dev_t st_dev;     \/\/ Was short int$/;"	m	struct:stat
st_gid	commands/make.cpp	/^    short int st_gid;$/;"	m	struct:stat	file:
st_gid	include/shared/stat_struct.hpp	/^    xinim::gid_t st_gid;     \/\/ Was short int$/;"	m	struct:stat
st_ino	commands/make.cpp	/^    unsigned short st_ino;$/;"	m	struct:stat	file:
st_ino	include/shared/stat_struct.hpp	/^    xinim::ino_t st_ino;     \/\/ Was unsigned short$/;"	m	struct:stat
st_mode	commands/make.cpp	/^    unsigned short st_mode;$/;"	m	struct:stat	file:
st_mode	include/shared/stat_struct.hpp	/^    xinim::mode_t st_mode;   \/\/ Was unsigned short$/;"	m	struct:stat
st_mtime	commands/make.cpp	/^    TIME st_mtime;$/;"	m	struct:stat	file:
st_mtime	include/shared/stat_struct.hpp	/^    xinim::time_t st_mtime;  \/\/ Was long$/;"	m	struct:stat
st_nlink	commands/make.cpp	/^    short int st_nlink;$/;"	m	struct:stat	file:
st_nlink	include/shared/stat_struct.hpp	/^    xinim::nlink_t st_nlink; \/\/ Was short int$/;"	m	struct:stat
st_rdev	commands/make.cpp	/^    short int st_rdev;$/;"	m	struct:stat	file:
st_rdev	include/shared/stat_struct.hpp	/^    xinim::dev_t st_rdev;    \/\/ Was short int (assuming device number)$/;"	m	struct:stat
st_size	commands/make.cpp	/^    long st_size;$/;"	m	struct:stat	file:
st_size	include/shared/stat_struct.hpp	/^    xinim::off_t st_size;    \/\/ Was long (xinim::off_t is std::int64_t)$/;"	m	struct:stat
st_uid	commands/make.cpp	/^    short int st_uid;$/;"	m	struct:stat	file:
st_uid	include/shared/stat_struct.hpp	/^    xinim::uid_t st_uid;     \/\/ Was short int$/;"	m	struct:stat
stack	tools/init.cpp	/^char stack[STACKSIZE];$/;"	v
stack_bottom	boot.S	/^stack_bottom:$/;"	l
stack_bytes	mm/param.hpp	18;"	d
stack_fault	mm/break.cpp	/^PRIVATE void stack_fault(int proc_nr) {$/;"	f
stack_ptr	mm/param.hpp	19;"	d
stack_top	boot.S	/^stack_top:$/;"	l
stackpt	fs/table.cpp	/^char *stackpt = &fstack[FS_STACK_BYTES]; \/* initial stack pointer *\/$/;"	v
stackpt	mm/table.cpp	/^char *stackpt = &mm_stack[MM_STACK_BYTES]; \/* initial stack pointer *\/$/;"	v
stackpt	tools/init.cpp	/^char *stackpt = &stack[STACKSIZE];$/;"	v
start	include/vm.hpp	/^    virt_addr64 start; \/\/\/< Inclusive start address.$/;"	m	struct:VmFlags::vm_area
start	lib/head.cpp	/^void start(void) {$/;"	f
start1	commands/sh4.cpp	/^char *start1;$/;"	v
start_file	commands/sort.cpp	/^merge(start_file, limit_file) int start_file, limit_file;$/;"	v
start_line	commands/mined2.cpp	/^delete (start_line, start_textp, end_line, end_textp) register LINE *start_line;$/;"	v
start_line	commands/mined2.cpp	/^yank(start_line, start_textp, end_line, end_textp, remove) LINE *start_line, *end_line;$/;"	v
start_page	commands/pr.cpp	/^short start_page = 1;$/;"	v
start_ptr	commands/mined.hpp	/^    char *start_ptr;$/;"	m	struct:ReturnCode::regex
start_ptr	include/mined.hpp	/^    char *start_ptr;$/;"	m	struct:ReturnCode::regex
start_textp	commands/mined2.cpp	/^char *start_textp, *end_textp;$/;"	v
startl	commands/sh2.cpp	/^static int startl = 1;$/;"	v	file:
startp	include/regexp.hpp	/^    char *startp[NSUBEXP]; \/\/\/< Pointers to start of matches.$/;"	m	struct:regexp
startpage	commands/roff.cpp	/^int sflag, hflag, startpage, stoppage;$/;"	v
stat	commands/make.cpp	/^struct stat {$/;"	s	file:
stat	include/shared/stat_struct.hpp	/^struct stat {$/;"	s
stat	lib/stat.cpp	/^int stat(const char *name, char *buffer) {$/;"	f
stat_file	commands/ls.cpp	/^static int stat_file(char *prefix, struct file *fp) {$/;"	f	file:
stat_file	commands/make.cpp	/^static int stat_file(const char *st, struct stat *ptr) {$/;"	f	file:
stat_visible	commands/mined1.cpp	/^FLAG stat_visible;           \/* Set if status_line is visible *\/$/;"	v
state	commands/mined1.cpp	/^raw_mode(state) FLAG state;$/;"	v
state	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
statfl	commands/mined1.cpp	/^FLAG statfl;$/;"	v
statistics	commands/dd.cpp	/^static void statistics(void) {$/;"	f	file:
statistics_	tools/diskio.hpp	/^    mutable IoStatistics statistics_; \/\/\/< I\/O operation statistics$/;"	m	class:DiskInterface
statistics_	tools/fsck.cpp	/^    FilesystemStatistics statistics_;$/;"	m	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
status	commands/grep.cpp	/^int status = 1;$/;"	v
status	commands/gres.cpp	/^int status = 1;$/;"	v
status	commands/mined.hpp	/^    char status;$/;"	m	struct:ReturnCode::regex
status	include/mined.hpp	/^    char status;$/;"	m	struct:ReturnCode::regex
status	include/sh.hpp	/^    char status;$/;"	m	struct:var
status	mm/param.hpp	20;"	d
status_line	commands/mined.hpp	226;"	d
status_line	include/mined.hpp	219;"	d
std	include/minix/fs_error.hpp	/^namespace std {$/;"	n
std_err	commands/touch.cpp	/^static void std_err(const char *s) { prints("%s", s); }$/;"	f	file:
std_err	lib/stderr.cpp	/^void std_err(const char *s) {$/;"	f
stderr	include/stdio.hpp	46;"	d
stderr	lib/io/src/standard_streams.cpp	/^Stream &stderr() { return stderr_stream; }$/;"	f	namespace:minix::io
stderr2	commands/df.cpp	/^static void stderr2(const char *s1, const char *s2) {$/;"	f	file:
stderr2	commands/rmdir.cpp	/^static void stderr2(const char *s1, const char *s2) {$/;"	f	file:
stderr3	commands/chmem.cpp	/^static void stderr3(const char *s1, const char *s2, const char *s3) {$/;"	f	file:
stderr3	commands/cp.cpp	/^static void stderr3(char *s1, char *s2, char *s3) {$/;"	f	file:
stderr3	commands/mkdir.cpp	/^static void stderr3(const char *s1, const char *s2, const char *s3) {$/;"	f	file:
stderr3	commands/rm.cpp	/^static void stderr3(const char *s1, const char *s2, const char *s3) {$/;"	f	file:
stderr3	commands/size.cpp	/^static void stderr3(const char *s1, const char *s2, const char *s3) {$/;"	f	file:
stdin	include/stdio.hpp	44;"	d
stdin	lib/io/src/standard_streams.cpp	/^Stream &stdin() { return stdin_stream; }$/;"	f	namespace:minix::io
stdout	include/stdio.hpp	45;"	d
stdout	lib/io/src/standard_streams.cpp	/^Stream &stdout() { return stdout_stream; }$/;"	f	namespace:minix::io
steps_per_cyl	kernel/floppy.cpp	/^PRIVATE int steps_per_cyl[NT] = {1, 2, 2, 1};                         \/* 2 = dbl step *\/$/;"	v
stime	lib/stime.cpp	/^int stime(long *top) {$/;"	f
stk	kernel/glo.hpp	/^    int stk[TASK_STACK_BYTES \/ sizeof(int)];$/;"	m	struct:t_stack
stoi	commands/tail.cpp	/^static int stoi(char *s) {$/;"	f	file:
stopOnErr	commands/make.cpp	/^int stopOnErr = TRUE;$/;"	v
stoppage	commands/roff.cpp	/^int sflag, hflag, startpage, stoppage;$/;"	v
store64	crypto/kyber_impl/fips202.c	/^static void store64(uint8_t x[8], uint64_t u) {$/;"	f	file:
str	commands/dosread.cpp	/^register char *str;$/;"	v
str	commands/sort.cpp	/^register char *str;$/;"	v
str	commands/tar.cpp	/^char str[];$/;"	v
str	commands/tar.cpp	/^print(str) register char *str;$/;"	v
str	include/sh.hpp	/^    char *str; \/* identifier for case and for *\/$/;"	m	struct:op
str1	commands/sort.cpp	/^digits(str1, str2, check_sign) register char *str1, *str2;$/;"	v
str2	commands/sort.cpp	/^digits(str1, str2, check_sign) register char *str1, *str2;$/;"	v
strchr	include/regexp.hpp	13;"	d
strcmp	lib/strcmp.cpp	/^int strcmp(char *s1, char *s2) {$/;"	f
strcpy	lib/strcpy.cpp	/^char *strcpy(char *dest, const char *src)$/;"	f
stream	commands/make.cpp	/^FILE *stream;$/;"	v
string	commands/libpack.cpp	/^    char *string;$/;"	m	struct:node	file:
string	commands/make.cpp	/^char *string;$/;"	v
string	commands/mined1.cpp	/^length_of(string) register char *string;$/;"	v
string	commands/mined2.cpp	/^char *location, *string;$/;"	v
string	commands/mined2.cpp	/^char *string;$/;"	v
string	commands/mined2.cpp	/^register char *string;$/;"	v
string	commands/mkfs.cpp	/^special(string) char *string;$/;"	v
string	kernel.cpp	/^    char string[];$/;"	m	struct:multiboot_tag_string	file:
string	lib/regexp.cpp	/^char *string;$/;"	v
string	tools/mkfs.cpp	/^special(string) char *string;$/;"	v
string_print	commands/mined.hpp	189;"	d
string_print	include/mined.hpp	182;"	d
strlen	lib/strlen.cpp	/^int strlen(char *s) {$/;"	f
sub	commands/sh1.cpp	/^register int sub;$/;"	v
sub_entries	commands/dosread.cpp	/^short total_clusters, cluster_size, fat_size, root_entries, data_start, sub_entries;$/;"	v
subr	test/test4.cpp	/^subr() {$/;"	f
succ	commands/mined1.cpp	1141;"	d	file:
suck	commands/roff.cpp	/^int suck() {$/;"	f
suff_head	commands/make.cpp	/^struct llist *suff_head = NULL;$/;"	v	typeref:struct:llist
suffix	commands/split.cpp	/^char *suffix;$/;"	v
sum	commands/sum.cpp	/^static void sum(int fd, const char *fname) {$/;"	f	file:
super_block	fs/super.hpp	/^EXTERN struct super_block {$/;"	s
super_block	fs/super.hpp	/^} super_block[NR_SUPERS];$/;"	v	typeref:struct:super_block
super_user	fs/glo.hpp	/^EXTERN int super_user;             \/* 1 if caller is super_user, else 0 *\/$/;"	v
superblock_	tools/fsck.cpp	/^    SuperBlock superblock_;$/;"	m	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
susp_count	fs/glo.hpp	/^EXTERN int susp_count;             \/* number of procs suspended on pipe *\/$/;"	v
sval	tools/r.cpp	/^static short sval;$/;"	v	file:
svc	kernel/service.cpp	/^namespace svc {$/;"	n	file:
svc	kernel/service.hpp	/^namespace svc {$/;"	n
svcctl	commands/svcctl.cpp	/^namespace svcctl {$/;"	n	file:
svcctl	commands/svcctl.hpp	/^namespace svcctl {$/;"	n
sw	commands/ar.cpp	/^    struct sw {$/;"	s	union:swabber	file:
swabber	commands/ar.cpp	/^union swabber {$/;"	u	file:
swap	commands/ar.cpp	/^static long swap(union swabber *sw_ptr) {$/;"	f	file:
swapped	commands/ar.cpp	/^} swapped;$/;"	v	typeref:union:swabber
switchc	commands/make.cpp	/^char switchc = '\/';   \/* default directory separation char *\/$/;"	v
switchc	commands/make.cpp	/^char switchc = '\\\\';    \/* default directory separation char *\/$/;"	v
sync	lib/sync.cpp	/^int sync() { return callm1(FS, SYNC, 0, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
sync	tools/diskio.cpp	/^void DiskInterface::sync() {$/;"	f	class:diskio::DiskInterface
sys	commands/time.cpp	/^    long user, sys;$/;"	m	struct:time_buf	file:
sys_abort	lib/syslib.cpp	/^void sys_abort() {$/;"	f
sys_call	kernel/proc.cpp	/^PUBLIC void sys_call(int function, int caller, int src_dest, message *m_ptr) {$/;"	f
sys_copy	lib/syslib.cpp	/^void sys_copy(message *mptr) {$/;"	f
sys_exec	lib/syslib.cpp	/^void sys_exec(int proc, char *ptr, std::uint64_t token) {$/;"	f
sys_fork	lib/syslib.cpp	/^void sys_fork(int parent, int child, int pid, std::uint64_t token) {$/;"	f
sys_getsp	lib/syslib.cpp	/^void sys_getsp(int proc, vir_bytes *newsp) {$/;"	f
sys_newmap	lib/syslib.cpp	/^void sys_newmap(int proc, char *ptr) {$/;"	f
sys_sig	lib/syslib.cpp	/^void sys_sig(int proc, int sig, sighandler_t sighandler, std::uint64_t token) {$/;"	f
sys_time	kernel/proc.hpp	/^    real_time sys_time;    \/* sys time in ticks (real_time -> xinim::time_t) *\/$/;"	m	struct:proc
sys_times	lib/syslib.cpp	/^void sys_times(int proc, real_time ptr[4]) {$/;"	f
sys_xit	lib/syslib.cpp	/^void sys_xit(int parent, int proc) {$/;"	f
syscmd	commands/make.cpp	/^char *syscmd;                       \/* the string to send to 'system' *\/$/;"	v
t	commands/roff.cpp	/^char *t, c;$/;"	v
t	commands/roff.cpp	/^writetitle(t) char *t;$/;"	v
t	commands/sh2.cpp	/^register struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^dobreak(t) struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^dochdir(t) register struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^docontinue(t) struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^dodot(t) struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^doeval(t) register struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^doexec(t) register struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^doexit(t) struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^doexport(t) struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^dologin(t) struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^doread(t) struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^doreadonly(t) struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^doset(t) register struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^doshift(t) register struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^dotrap(t) register struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^doumask(t) register struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^dowait(t) struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^register struct op *t;$/;"	v	typeref:struct:op
t	commands/sh3.cpp	/^struct op *t;$/;"	v	typeref:struct:op
t	lib/stb.cpp	/^	    register char *f, *t; register int n;$/;"	v
t1	commands/sh2.cpp	/^register struct op *t1, *t2;$/;"	v	typeref:struct:op
t1	commands/sh2.cpp	/^struct op *t1, *t2;$/;"	v	typeref:struct:op
t1	test/test0.cpp	/^long t1;$/;"	v
t2	commands/sh2.cpp	/^register struct op *t1, *t2;$/;"	v	typeref:struct:
t2	commands/sh2.cpp	/^struct op *t1, *t2;$/;"	v	typeref:struct:
t_brkc	include/sgtty.hpp	/^    char t_brkc;   \/* input delimiter (like nl) *\/$/;"	m	struct:tchars
t_eofc	include/sgtty.hpp	/^    char t_eofc;   \/* EOF (initially CTRL-D) *\/$/;"	m	struct:tchars
t_intrc	include/sgtty.hpp	/^    char t_intrc;  \/* SIGINT char *\/$/;"	m	struct:tchars
t_quitc	include/sgtty.hpp	/^    char t_quitc;  \/* SIGQUIT char *\/$/;"	m	struct:tchars
t_stack	kernel/glo.hpp	/^EXTERN struct t_stack {$/;"	s
t_stack	kernel/glo.hpp	/^} t_stack[NR_TASKS - 1]; \/* task stacks; task = -1 never really runs *\/$/;"	v	typeref:struct:t_stack
t_startc	include/sgtty.hpp	/^    char t_startc; \/* start output (initially CTRL-Q) *\/$/;"	m	struct:tchars
t_stopc	include/sgtty.hpp	/^    char t_stopc;  \/* stop output       (initially CTRL-S) *\/$/;"	m	struct:tchars
tab	commands/mined.hpp	199;"	d
tab	include/mined.hpp	192;"	d
table	commands/libpack.cpp	/^char *table[] = {"push ax",$/;"	v
table	commands/libupack.cpp	/^char *table[] = {"push ax",$/;"	v
table	commands/sort.cpp	/^char table[256] = {$/;"	v
tables	include/paging.hpp	/^    struct page_table *tables[PT_ENTRIES];$/;"	m	struct:page_directory	typeref:struct:page_directory::page_table
tabulate	commands/roff.cpp	/^tabulate() {$/;"	f
tail	commands/mined1.cpp	/^LINE *tail;               \/* Last line in line list *\/$/;"	v
tail	commands/tail.cpp	/^static void tail(FILE *in, int goal) {$/;"	f	file:
talking	include/sh.hpp	/^int talking; \/* interactive (talking-type wireless) *\/$/;"	v
tar_fd	commands/tar.cpp	/^int tar_fd;$/;"	v
tarfile	commands/tar.cpp	/^tarfile() {$/;"	f
targ	commands/make.cpp	/^    char *dep, *targ; \/* order is important because there are defaults *\/$/;"	m	struct:rulerec	file:
targ	commands/make.cpp	/^struct llist *targ, *q_how, *q_dep, *targ2;$/;"	v	typeref:struct:llist
targ2	commands/make.cpp	/^struct llist *targ, *q_how, *q_dep, *targ2;$/;"	v	typeref:struct:
target	commands/make.cpp	/^char *target;$/;"	v
task	fs/device.cpp	/^PRIVATE major, minor, task;$/;"	v
task	fs/pipe.cpp	/^int task; \/* who is proc waiting for? (PIPE = pipe) *\/$/;"	v
task	include/sh.hpp	/^    char task;    \/* reason for pushed IO *\/$/;"	m	struct:io
task_mess	kernel/proc.hpp	/^EXTERN message *task_mess[NR_TASKS + 1]; \/* ptrs to messages for busy tasks *\/$/;"	v
task_nr	fs/device.cpp	/^int task_nr;       \/* which task to call *\/$/;"	v
task_nr	fs/device.cpp	/^int task_nr;    \/* which task *\/$/;"	v
tbuf	lib/times.cpp	/^struct tbuf {$/;"	s	file:
tch	commands/stty.cpp	/^struct tchars tch;$/;"	v	typeref:struct:tchars
tchars	include/sgtty.hpp	/^struct tchars {$/;"	s
tcp_accept_loop	kernel/net_driver.cpp	/^static void tcp_accept_loop() {$/;"	f	namespace:net::__anon16
tcp_child	tests/test_net_driver_ipv6.cpp	/^int tcp_child() {$/;"	f	namespace:__anon11
tcp_fd	kernel/net_driver.cpp	/^    int tcp_fd = -1;$/;"	m	struct:net::__anon16::Remote	file:
tcp_parent	tests/test_net_driver_ipv6.cpp	/^int tcp_parent(pid_t child) {$/;"	f	namespace:__anon11
tell_fs	lib/syslib.cpp	/^int tell_fs(int what, int p1, int p2, int p3) {$/;"	f
teller	commands/roff.cpp	/^long int teller[MAXDEPTH], ftell();$/;"	v
temp_arch	commands/ar.cpp	/^char temp_arch[] = "\/tmp\/ar.XXXXX";$/;"	v
temp_files	commands/sort.cpp	/^char temp_files[] = "\/tmp\/sort.XXXXX.XX";$/;"	v
temparg	include/sh.hpp	/^struct ioarg temparg; \/* temporary for PUSHIO *\/$/;"	v	typeref:struct:ioarg
test	commands/make.cpp	/^char *test;$/;"	v
test00	test/test0.cpp	/^static void test00(void) {$/;"	f	file:
test01	test/test0.cpp	/^static void test01(void) {$/;"	f	file:
test1	test/test9.cpp	/^test1() {$/;"	f
test10	test/test1.cpp	/^test10() {$/;"	f
test11	test/test1.cpp	/^test11() {$/;"	f
test110	test/test11.cpp	/^test110() {$/;"	f
test111	test/test11.cpp	/^test111() {$/;"	f
test2	test/test9.cpp	/^test2() {$/;"	f
test20	test/test2.cpp	/^test20() {$/;"	f
test3	test/test9.cpp	/^test3() {$/;"	f
test4	test/test9.cpp	/^test4() {$/;"	f
test5	test/test9.cpp	/^test5() {$/;"	f
test50	test/test5.cpp	/^test50() {$/;"	f
test51	test/test5.cpp	/^test51() {$/;"	f
test52	test/test5.cpp	/^test52() {$/;"	f
test53	test/test5.cpp	/^test53() {$/;"	f
test54	test/test5.cpp	/^test54() {$/;"	f
test55	test/test5.cpp	/^test55() {$/;"	f
test56	test/test5.cpp	/^test56() {$/;"	f
test57	test/test5.cpp	/^test57() {$/;"	f
test58	test/test5.cpp	/^test58() {$/;"	f
test6	test/test9.cpp	/^test6() {$/;"	f
test60	test/test6.cpp	/^test60() {$/;"	f
test70	test/test7.cpp	/^test70() {$/;"	f
test80	test/test8.cpp	/^test80() {$/;"	f
test90	test/test3.cpp	/^test90() {$/;"	f
test91	test/test3.cpp	/^test91() {$/;"	f
test92	test/test3.cpp	/^test92() {$/;"	f
test_direct_delivery	tests/test_lattice_send_recv.cpp	/^static void test_direct_delivery() {$/;"	f	file:
test_nonblocking_failures	tests/test_lattice_send_recv.cpp	/^static void test_nonblocking_failures() {$/;"	f	file:
test_queued_delivery	tests/test_lattice_send_recv.cpp	/^static void test_queued_delivery() {$/;"	f	file:
testflag	include/stdio.hpp	67;"	d
testnr	test/test0.cpp	/^int testnr;$/;"	v
testnr	test/test7.cpp	/^int testnr;$/;"	v
testnr	test/test8.cpp	/^int testnr;$/;"	v
text	commands/mined.hpp	/^    char *text;$/;"	m	struct:ReturnCode::Line
text	commands/mined1.cpp	/^register char *text;$/;"	v
text	include/mined.hpp	/^    char *text;$/;"	m	struct:ReturnCode::Line
text_buffer	commands/mined1.cpp	/^char text_buffer[MAX_CHARS]; \/* Buffer for modifying text *\/$/;"	v
tfilename	commands/make.cpp	/^char tfilename[50] = "makefile.mac";$/;"	v
thenpart	commands/sh2.cpp	/^static struct op *thenpart() {$/;"	f	file:
this_month	commands/cal.cpp	/^    int this_month;    \/* month number used in 1752 checking	*\/$/;"	m	struct:__anon29	file:
ticket	kernel/quaternion_spinlock.hpp	/^        : lock(spin), ticket(t) {$/;"	f	class:hyper::QuaternionLockGuard
time	lib/time.cpp	/^long time(long *tp) {$/;"	f
time_buf	commands/time.cpp	/^struct time_buf {$/;"	s	file:
time_point_	include/minix/fs/inode.hpp	/^    std::chrono::system_clock::time_point time_point_;$/;"	m	class:minix::fs::InodeType::FileTime
times	lib/times.cpp	/^int times(struct tbuf *buf) {$/;"	f
tm	commands/date.cpp	/^} tm;$/;"	v	typeref:struct:__anon25
tmp	kernel/klib88.cpp	/^PUBLIC unsigned tmp = 0;$/;"	v
tmpa	test/test9.cpp	/^char *tmpa;$/;"	v
tmpdir	commands/cc.cpp	/^char *tmpdir = "\/tmp";$/;"	v
tmpname	commands/cc.cpp	/^char tmpname[15];$/;"	v
to	commands/mined1.cpp	/^copy_string(to, from) register char *to;$/;"	v
to	commands/mined2.cpp	/^bcopy(from, to, bytes) register char *from, *to;$/;"	v
to	commands/mkfs.cpp	/^copy(from, to, count) char *from, *to;$/;"	v
to	commands/tar.cpp	/^int from, to;$/;"	v
to	tools/mkfs.cpp	/^copy(from, to, count) char *from, *to;$/;"	v
to_bytes	tests/test_lattice_ipc.cpp	/^static std::vector<std::byte> to_bytes(std::string_view text) {$/;"	f	file:
today	commands/cal.cpp	/^static int getdate(int week, int wday) register int today;$/;"	v
too_long	commands/mined2.cpp	/^char *too_long = "Regular expression too long";$/;"	v
top	lib/malloc.cpp	/^static char *bottom, *top;$/;"	v	file:
top_line	commands/mined1.cpp	/^LINE *top_line;           \/* First line of screen *\/$/;"	v
topfiles	commands/ls.cpp	/^int topfiles; \/* nr of files in ls command *\/$/;"	v
tot_mem	mm/main.cpp	/^static uint64_t tot_mem;    \/\/ PRIVATE phys_clicks -> static uint64_t$/;"	v	file:
total_blocks	commands/tar.cpp	/^int total_blocks;$/;"	v
total_clusters	commands/dosread.cpp	/^short total_clusters, cluster_size, fat_size, root_entries, data_start, sub_entries;$/;"	v
total_pages	pmm.cpp	/^static size_t total_pages = 0;$/;"	v	file:
touch	include/minix/fs/inode.hpp	/^    void touch() {$/;"	f	class:minix::fs::InodeType::Inode
tp	commands/sh2.cpp	/^static struct op *tp;$/;"	v	typeref:struct:op	file:
tp	fs/param.hpp	36;"	d
trap	include/sh.hpp	/^char *trap[NSIG];$/;"	v
trapcc	commands/cc.cpp	/^static void trapcc(int sig) {$/;"	f	file:
trapset	include/sh.hpp	/^int trapset; \/* trap pending *\/$/;"	v
tree_and_quit	commands/make.cpp	/^int tree_and_quit = FALSE;$/;"	v
trp	kernel/mpx64.cpp	/^void trp(void) {$/;"	f
truncate	include/minix/io/file_operations.hpp	/^    truncate = 1 << 4,$/;"	m	class:minix::io::OpenMode
try_path	commands/time.cpp	/^static void try_path(const char *path) {$/;"	f	file:
tss64	kernel/idt64.cpp	/^struct tss64 {$/;"	s	file:
tty	commands/roff.cpp	/^struct sgttyb tty;$/;"	v	typeref:struct:sgttyb
tty_attribute	kernel/tty.cpp	/^    int tty_attribute;               \/* current attribute byte << 8 *\/$/;"	m	struct:tty_struct	file:
tty_buf	kernel/tty.cpp	/^PRIVATE char tty_buf[TTY_BUF_SIZE];               \/* scratch buffer to\/from user space *\/$/;"	v
tty_busy	kernel/tty.cpp	/^    char tty_busy;      \/* 1 when output in progress, else 0 *\/$/;"	m	struct:tty_struct	file:
tty_column	kernel/tty.cpp	/^    int tty_column;     \/* current column number (0-origin) *\/$/;"	m	struct:tty_struct	file:
tty_copy_buf	kernel/tty.cpp	/^PRIVATE char tty_copy_buf[2 * MAX_OVERRUN];       \/* copy buf used to avoid races *\/$/;"	v
tty_cum	kernel/tty.cpp	/^    std::size_t tty_cum;     \/* # chars copied to tty_outqueue so far (was int) *\/$/;"	m	struct:tty_struct	file:
tty_devstart	kernel/tty.cpp	/^    int (*tty_devstart)();           \/* routine to start actual device output *\/$/;"	m	struct:tty_struct	file:
tty_driver_buf	kernel/tty.cpp	/^PRIVATE char tty_driver_buf[2 * MAX_OVERRUN + 2]; \/* driver collects chars here *\/$/;"	v
tty_echar	kernel/tty.cpp	/^    char tty_echar;                  \/* first character following an ESC *\/$/;"	m	struct:tty_struct	file:
tty_eof	kernel/tty.cpp	/^    char tty_eof;   \/* char used to stop output  (init CTRL-D) *\/$/;"	m	struct:tty_struct	file:
tty_erase	kernel/tty.cpp	/^    char tty_erase; \/* char used to erase 1 char (init ^H) *\/$/;"	m	struct:tty_struct	file:
tty_esc_state	kernel/tty.cpp	/^    char tty_esc_state;              \/* 0=normal, 1 = ESC seen, 2 = ESC + x seen *\/$/;"	m	struct:tty_struct	file:
tty_escaped	kernel/tty.cpp	/^    char tty_escaped;   \/* 1 when '\\' just seen, else 0 *\/$/;"	m	struct:tty_struct	file:
tty_in_vir	kernel/tty.cpp	/^    char *tty_in_vir;        \/* virtual address where data is to go (char* is fine for address) *\/$/;"	m	struct:tty_struct	file:
tty_incaller	kernel/tty.cpp	/^    char tty_incaller;       \/* process that made the call (usually FS) *\/$/;"	m	struct:tty_struct	file:
tty_incount	kernel/tty.cpp	/^    int tty_incount;                \/* # chars in tty_inqueue *\/$/;"	m	struct:tty_struct	file:
tty_inhead	kernel/tty.cpp	/^    char *tty_inhead;               \/* pointer to place where next char goes *\/$/;"	m	struct:tty_struct	file:
tty_inhibited	kernel/tty.cpp	/^    char tty_inhibited; \/* 1 when CTRL-S just seen (stops output) *\/$/;"	m	struct:tty_struct	file:
tty_inleft	kernel/tty.cpp	/^    std::size_t tty_inleft;  \/* how many chars are still needed (was int) *\/$/;"	m	struct:tty_struct	file:
tty_inproc	kernel/tty.cpp	/^    char tty_inproc;         \/* process that wants to read from tty *\/$/;"	m	struct:tty_struct	file:
tty_inqueue	kernel/tty.cpp	/^    char tty_inqueue[TTY_IN_BYTES]; \/* array used to store the characters *\/$/;"	m	struct:tty_struct	file:
tty_intail	kernel/tty.cpp	/^    char *tty_intail;               \/* pointer to next char to be given to prog *\/$/;"	m	struct:tty_struct	file:
tty_intr	kernel/tty.cpp	/^    char tty_intr;  \/* char used to send SIGINT  (init DEL) *\/$/;"	m	struct:tty_struct	file:
tty_ioport	kernel/tty.cpp	/^    int tty_ioport; \/* I\/O port number for this terminal *\/$/;"	m	struct:tty_struct	file:
tty_kill	kernel/tty.cpp	/^    char tty_kill;  \/* char used to erase a line (init @) *\/$/;"	m	struct:tty_struct	file:
tty_lfct	kernel/tty.cpp	/^    int tty_lfct;                   \/* # line feeds in tty_inqueue *\/$/;"	m	struct:tty_struct	file:
tty_makebreak	kernel/tty.cpp	/^    char tty_makebreak; \/* 1 for terminals that interrupt twice\/key *\/$/;"	m	struct:tty_struct	file:
tty_mode	kernel/tty.cpp	/^    int tty_mode;       \/* terminal mode set by IOCTL *\/$/;"	m	struct:tty_struct	file:
tty_org	kernel/tty.cpp	/^    int tty_org;                     \/* location in RAM where 6845 base points *\/$/;"	m	struct:tty_struct	file:
tty_otcaller	kernel/tty.cpp	/^    char tty_otcaller;       \/* process that made the call (usually FS) *\/$/;"	m	struct:tty_struct	file:
tty_out_vir	kernel/tty.cpp	/^    char *tty_out_vir;       \/* virtual address where data comes from (char* is fine for address) *\/$/;"	m	struct:tty_struct	file:
tty_outleft	kernel/tty.cpp	/^    std::size_t tty_outleft; \/* # chars yet to be copied to tty_outqueue (was int) *\/$/;"	m	struct:tty_struct	file:
tty_outproc	kernel/tty.cpp	/^    char tty_outproc;        \/* process that wants to write to tty *\/$/;"	m	struct:tty_struct	file:
tty_phys	kernel/tty.cpp	/^    uint64_t tty_phys;       \/* physical address where data comes from (phys_bytes -> uint64_t) *\/$/;"	m	struct:tty_struct	file:
tty_quit	kernel/tty.cpp	/^    char tty_quit;  \/* char used for core dump   (init CTRL-\\) *\/$/;"	m	struct:tty_struct	file:
tty_ramqueue	kernel/tty.cpp	/^    int tty_ramqueue[TTY_RAM_WORDS]; \/* buffer for video RAM *\/$/;"	m	struct:tty_struct	file:
tty_row	kernel/tty.cpp	/^    int tty_row;        \/* current row (0 at bottom of screen) *\/$/;"	m	struct:tty_struct	file:
tty_rwords	kernel/tty.cpp	/^    int tty_rwords;                  \/* number of WORDS (not bytes) in outqueue *\/$/;"	m	struct:tty_struct	file:
tty_struct	kernel/tty.cpp	/^PRIVATE struct tty_struct {$/;"	s	file:
tty_struct	kernel/tty.cpp	/^} tty_struct[NR_TTYS];$/;"	v	typeref:struct:tty_struct
tty_vid	kernel/tty.cpp	/^    int tty_vid;                     \/* current position of cursor in video RAM *\/$/;"	m	struct:tty_struct	file:
tty_waiting	kernel/tty.cpp	/^    char tty_waiting;   \/* 1 when output process waiting for reply *\/$/;"	m	struct:tty_struct	file:
tty_xoff	kernel/tty.cpp	/^    char tty_xoff;  \/* char used to stop output  (init CTRL-S) *\/$/;"	m	struct:tty_struct	file:
tty_xon	kernel/tty.cpp	/^    char tty_xon;   \/* char used to start output (init CTRL-Q)*\/$/;"	m	struct:tty_struct	file:
twin	commands/time.cpp	/^static void twin(int n, char *p) {$/;"	f	file:
type	commands/sh2.cpp	/^int type, mark;$/;"	v
type	commands/tar.cpp	/^int type;$/;"	v
type	include/sh.hpp	/^    OpType type;           \/* operation type, see below *\/$/;"	m	struct:op
type	kernel.cpp	/^    uint32_t type;$/;"	m	struct:multiboot_tag_string	file:
type	multiboot.h	/^    uint32_t type;$/;"	m	struct:multiboot_mmap_entry
type	multiboot.h	/^    uint32_t type;$/;"	m	struct:multiboot_tag
type	multiboot.h	/^    uint32_t type;$/;"	m	struct:multiboot_tag_basic_meminfo
type	multiboot.h	/^    uint32_t type;$/;"	m	struct:multiboot_tag_elf_sections
type	multiboot.h	/^    uint32_t type;$/;"	m	struct:multiboot_tag_mmap
type_attr	kernel/idt64.cpp	/^    u8_t type_attr;$/;"	m	struct:idt_entry	file:
typed_expression	commands/mined2.cpp	/^char typed_expression[LINE_LEN]; \/* Holds previous expr. *\/$/;"	v
types	fs/cache.cpp	/^✅ All buffer cache primitives have now been elevated into a modern C++23 implementation, complete with RAII semantics (`BufferGuard`), strong `enum class` usage for block types, rigorous error handling, and clear semantic modularization.$/;"	v	typeref:class:lock
u	commands/make.cpp	/^int u;                  \/* uptodate *\/$/;"	v
u	commands/sh1.cpp	/^register unsigned u;$/;"	v
u	commands/sh5.cpp	/^void prn(u) unsigned u;$/;"	v
udp_child	tests/test_net_driver_ipv6.cpp	/^int udp_child() {$/;"	f	namespace:__anon11
udp_parent	tests/test_net_driver_ipv6.cpp	/^int udp_parent(pid_t child) {$/;"	f	namespace:__anon11
udp_recv_loop	kernel/net_driver.cpp	/^static void udp_recv_loop() {$/;"	f	namespace:net::__anon16
uflag	commands/uniq.cpp	/^int uflag = 1; \/* default is union of -d and -u outputs *\/$/;"	v
ui_	tools/fsck.cpp	/^    UserInterface ui_;$/;"	m	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
uid	include/minix/fs/const.hpp	/^enum class uid : std::uint16_t {};$/;"	c	namespace:minix::fs
umap	commands/mkfs.cpp	/^char umap[(N_BLOCKS + 8) \/ 8]; \/* bit map tells if block read yet *\/$/;"	v
umap	tools/mkfs.cpp	/^char umap[(N_BLOCKS + 8) \/ 8]; \/* bit map tells if block read yet *\/$/;"	v
umask	lib/umask.cpp	/^int umask(int complmode) { return callm1(FS, UMASK, complmode, 0, 0, NIL_PTR, NIL_PTR, NIL_PTR); }$/;"	f
umount	lib/umount.cpp	/^int umount(const char *name) { return callm3(FS, UMOUNT, 0, const_cast<char *>(name)); }$/;"	f
umsg	commands/comm.cpp	/^static char *umsg = "Usage: comm [-[123]] file1 file2\\n";$/;"	v	file:
unblock	kernel/schedule.cpp	/^void Scheduler::unblock(xinim::pid_t pid) {$/;"	f	class:sched::Scheduler
unbuffered	commands/cat.cpp	/^int unbuffered;                       \/* non-zero for unbuffered operation *\/$/;"	v
unget	commands/sh5.cpp	/^void unget(c) {$/;"	f
uniq	commands/sort.cpp	/^BOOL uniq = FALSE;$/;"	v
unlink	lib/unlink.cpp	/^int unlink(const char *name) { return callm3(FS, UNLINK, 0, const_cast<char *>(name)); }$/;"	f
unm24	kernel/tty.cpp	/^PRIVATE char unm24[] = {$/;"	v
unpack88	commands/libupack.cpp	/^static int unpack88(char *inp, char *outp) {$/;"	f	file:
unpack_ciphertext	crypto/kyber_impl/indcpa.c	/^static void unpack_ciphertext(polyvec *b, poly *v, const uint8_t c[KYBER_INDCPA_BYTES])$/;"	f	file:
unpack_pk	crypto/kyber_impl/indcpa.c	/^static void unpack_pk(polyvec *pk,$/;"	f	file:
unpack_sk	crypto/kyber_impl/indcpa.c	/^static void unpack_sk(polyvec *sk, const uint8_t packedsk[KYBER_INDCPA_SECRETKEYBYTES])$/;"	f	file:
unready	kernel/proc.cpp	/^PUBLIC void unready(struct proc *rp) {$/;"	f
unregister_service	kernel/service.cpp	/^void ServiceManager::unregister_service(xinim::pid_t pid) {$/;"	f	class:svc::ServiceManager
unsh	kernel/tty.cpp	/^PRIVATE char unsh[] = {0,    033,  '1',  '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',  '0',$/;"	v
update	include/minix/fs/inode.hpp	/^    void update() { time_point_ = std::chrono::system_clock::now(); }$/;"	f	class:minix::fs::InodeType::FileTime
update_time	fs/param.hpp	37;"	d
uptodate	commands/make.cpp	/^    int uptodate;$/;"	m	struct:defnrec	file:
usage	commands/ar.cpp	/^static void usage(void) { error(TRUE, "Usage: ar [adprtxv] archive [file] ...", NIL_PTR); }$/;"	f	file:
usage	commands/cal.cpp	/^static void usage(char *s) {$/;"	f	file:
usage	commands/chmem.cpp	/^static void usage(void) {$/;"	f	file:
usage	commands/cmp.cpp	/^static void usage(void) {$/;"	f	file:
usage	commands/comm.cpp	/^static void usage(void) {$/;"	f	file:
usage	commands/cp.cpp	/^static void usage(void) {$/;"	f	file:
usage	commands/date.cpp	/^static void usage(void) {$/;"	f	file:
usage	commands/dosread.cpp	/^static void usage(char *prog_name) {$/;"	f	file:
usage	commands/grep.cpp	/^static void usage() {$/;"	f	file:
usage	commands/head.cpp	/^static void usage() {$/;"	f	file:
usage	commands/kill.cpp	/^static void usage() {$/;"	f	file:
usage	commands/ln.cpp	/^static int usage() {$/;"	f	file:
usage	commands/mount.cpp	/^static void usage(void) {$/;"	f	file:
usage	commands/od.cpp	/^usage() { std_err("Usage: od [-bcdhox] [file] [ [+] offset [.] [b] ]"); }$/;"	f
usage	commands/rm.cpp	/^static void usage(void) {$/;"	f	file:
usage	commands/split.cpp	/^[[noreturn]] static void usage() {$/;"	f	file:
usage	commands/tar.cpp	/^char usage[] = "Usage: tar [cxt] tarfile [files].";$/;"	v
usage	commands/touch.cpp	/^static void usage() {$/;"	f	file:
usage	commands/umount.cpp	/^[[noreturn]] static void usage() {$/;"	f	file:
usage	commands/wc.cpp	/^[[noreturn]] static void usage() {$/;"	f	file:
usagemsg	commands/gres.cpp	/^char *usagemsg = "Usage: gres [-g] search replace [file ...]\\n";$/;"	v
usecnt	commands/mkfs.cpp	/^    int usecnt;$/;"	m	struct:cache	file:
usecnt	tools/mkfs.cpp	/^    int usecnt;$/;"	m	struct:cache	file:
used_pages	pmm.cpp	/^static size_t used_pages = 0;$/;"	v	file:
user	commands/time.cpp	/^    long user, sys;$/;"	m	struct:time_buf	file:
user_addr	fs/stadir.cpp	/^char *user_addr;            \/* user space address where stat buf goes *\/$/;"	v
user_path	fs/glo.hpp	/^EXTERN char user_path[MAX_PATH]; \/* storage for user path name *\/$/;"	v
user_time	kernel/proc.hpp	/^    real_time user_time;   \/* user time in ticks (real_time -> xinim::time_t) *\/$/;"	m	struct:proc
usr_id	mm/param.hpp	21;"	d
usrid	commands/mkfs.cpp	/^int mode, usrid, grpid;$/;"	v
usrid	tools/mkfs.cpp	/^int mode, usrid, grpid;$/;"	v
utime	lib/utime.cpp	/^int utime(const char *name, long timp[2]) {$/;"	f
utime_file	fs/param.hpp	38;"	d
utime_length	fs/param.hpp	39;"	d
v	commands/sh3.cpp	/^char *c, **v, **envp;$/;"	v
v_flag	commands/cc.cpp	/^int v_flag = 0;$/;"	v
val	commands/od.cpp	/^byte(val, c) int val;$/;"	v
val	commands/od.cpp	/^outword(val, radix) int val, radix;$/;"	v
val	commands/sh1.cpp	/^char *val, *name;$/;"	v
val	commands/sh1.cpp	/^char *val;$/;"	v
val	lib/regexp.cpp	/^char *val;$/;"	v
validate	tools/bootblok1.cpp	/^    void validate() const {$/;"	f	class:minix::bootloader::BootSector
validate	tools/fsck.cpp	/^    [[nodiscard]] bool validate(UserInterface &ui, const PathTracker &path,$/;"	f	class:minix::fsck::ZoneLevel::DirectoryEntry
validate	tools/fsck.cpp	/^    [[nodiscard]] bool validate(const SuperBlock &sb, UserInterface &ui,$/;"	f	class:minix::fsck::ZoneLevel::Inode
validate	tools/fsck.cpp	/^    void validate() const {$/;"	f	class:minix::fsck::ZoneLevel::SuperBlock
validate_sector_address	tools/diskio.cpp	/^void DiskInterface::validate_sector_address(SectorAddress sector) const {$/;"	f	class:diskio::DiskInterface
value	include/sh.hpp	/^    char *value;$/;"	m	struct:var
value	tools/build.cpp	/^    std::size_t value;$/;"	m	struct:minix::builder::ByteOffset	file:
value	tools/diskio.hpp	/^    std::uint64_t value; \/\/\/< Raw sector address value$/;"	m	struct:diskio::SectorAddress
value	tools/fsck.cpp	/^    std::uint32_t value;$/;"	m	struct:minix::fsck::ZoneLevel::BitNumber	file:
value_	tools/bootblok1.cpp	/^    T value_;$/;"	m	class:optional	file:
var	include/sh.hpp	/^struct var {$/;"	s
vargv	kernel/dmp.cpp	/^int vargv; \/\/ Used in set_name, seems to hold a virtual address temporarily$/;"	v
vec	crypto/kyber_impl/polyvec.h	/^  poly vec[KYBER_K];$/;"	m	struct:__anon24
vectab	lib/signal.cpp	/^sighandler_t vectab[NR_SIGS]; \/* array of functions to catch signals *\/$/;"	v
vector	commands/tr.cpp	/^unsigned char vector[ASCII + 1];$/;"	v
verbose	commands/ar.cpp	/^BOOL verbose;$/;"	v
verify	crypto/kyber_impl/verify.c	/^int verify(const uint8_t *a, const uint8_t *b, size_t len)$/;"	f
verify	crypto/kyber_impl/verify.h	8;"	d
version	docs/sphinx/conf.py	/^version = "0.1"  # Short version string$/;"	v
vga_buffer	console.cpp	/^volatile unsigned short* vga_buffer = (unsigned short*)0xB8000;$/;"	v
vga_entry_color	console.h	/^static inline uint8_t vga_entry_color(uint8_t fg, uint8_t bg) {$/;"	f
vid_base	kernel/tty.cpp	/^PRIVATE unsigned vid_base; \/* base of video ram (0xB000 or 0xB800) *\/$/;"	v
vid_mask	kernel/tty.cpp	/^PUBLIC int vid_mask;       \/* 037777 for color (16K) or 07777 for mono *\/$/;"	v
vid_port	kernel/tty.cpp	/^PRIVATE int vid_port;      \/* I\/O port for accessing 6845 *\/$/;"	v
vid_retrace	kernel/tty.cpp	/^PRIVATE vid_retrace;       \/* how many characters to display per burst *\/$/;"	v
virgin	fs/pipe.cpp	/^int virgin;                  \/* 1 if no data transferred yet, else 0 *\/$/;"	v
vlist	include/sh.hpp	/^struct var *vlist; \/* dictionary *\/$/;"	v	typeref:struct:var
vm	include/psd/vm/semantic_memory.hpp	/^namespace psd::vm {$/;"	n	class:psd
vm_area	include/vm.hpp	/^struct vm_area {$/;"	s	class:VmFlags
vm_proc	include/vm.hpp	/^    vm_proc() : areas(VM_MAX_AREAS) {}$/;"	f	struct:VmFlags::vm_proc
vm_proc	include/vm.hpp	/^struct vm_proc {$/;"	s	class:VmFlags
vmm_enable_paging	vmm.cpp	/^void vmm_enable_paging() {$/;"	f
vmm_get_page_directory_physical_addr	vmm.cpp	/^uintptr_t vmm_get_page_directory_physical_addr() {$/;"	f
vmm_get_pte	vmm.cpp	/^pte_t* vmm_get_pte(uintptr_t virtual_addr, bool create_if_missing) {$/;"	f
vmm_init	vmm.cpp	/^void vmm_init(uintptr_t kernel_phys_start, uintptr_t kernel_phys_end,$/;"	f
vmm_load_page_directory	vmm.cpp	/^void vmm_load_page_directory(uintptr_t page_dir_phys_addr) {$/;"	f
vmm_map_page	vmm.cpp	/^bool vmm_map_page(uintptr_t virtual_addr, uintptr_t physical_addr, uint32_t flags) {$/;"	f
vmm_unmap_page	vmm.cpp	/^void vmm_unmap_page(uintptr_t virtual_addr) {$/;"	f
vp	commands/sh1.cpp	/^void export(vp) struct var *vp;$/;"	v	typeref:struct:var
vp	commands/sh1.cpp	/^void nameval(vp, val, name) register struct var *vp;$/;"	v	typeref:struct:var
vp	commands/sh1.cpp	/^void ronly(vp) struct var *vp;$/;"	v	typeref:struct:var
vp	commands/sh1.cpp	/^void setval(vp, val) struct var *vp;$/;"	v	typeref:struct:var
w	commands/sh3.cpp	/^char *w;$/;"	v
w1	commands/od.cpp	/^int *w1, *w2;$/;"	v
w2	commands/od.cpp	/^int *w1, *w2;$/;"	v
w_bsize	include/sh.hpp	/^    short w_bsize;$/;"	m	struct:wdblock
w_buf	commands/make.cpp	/^char w_buf[W_BUFLEN];$/;"	v
w_count	commands/make.cpp	/^int w_count;$/;"	v
w_first	commands/make.cpp	/^int w_first;$/;"	v
w_mac2	commands/make.cpp	/^static int w_mac2(char *w_word, FILE *stream, struct llist *n) {$/;"	f	file:
w_macros	commands/make.cpp	/^static int w_macros(char *list) {$/;"	f	file:
w_mess	kernel/at_wini.cpp	/^PRIVATE message w_mess; \/* message buffer for in and out *\/$/;"	v
w_mess	kernel/wini.cpp	/^PRIVATE message w_mess; \/* message buffer for in and out *\/$/;"	v
w_mess	kernel/xt_wini.cpp	/^PRIVATE message w_mess; \/* message buffer for in and out *\/$/;"	v
w_need_reset	kernel/at_wini.cpp	/^PRIVATE int w_need_reset = FALSE; \/* set to 1 when controller must be reset *\/$/;"	v
w_need_reset	kernel/wini.cpp	/^PRIVATE int w_need_reset = FALSE; \/* set to 1 when controller must be reset *\/$/;"	v
w_need_reset	kernel/xt_wini.cpp	/^PRIVATE int w_need_reset = FALSE; \/* set to 1 when controller must be reset *\/$/;"	v
w_nword	include/sh.hpp	/^    short w_nword;$/;"	m	struct:wdblock
w_words	include/sh.hpp	/^    char *w_words[1];$/;"	m	struct:wdblock
wait	lib/wait.cpp	/^int wait(int *status) {$/;"	f
waitawhile	commands/roff.cpp	/^waitawhile() {$/;"	f
walk	tools/classify_style.py	/^def walk(root: str) -> str:$/;"	f
warn2	commands/make.cpp	/^static void warn2(char *s1, char *s2) {$/;"	f	file:
watch_dog	kernel/clock.cpp	/^PRIVATE int (*watch_dog[NR_TASKS + 1])(); \/* watch_dog functions to call *\/$/;"	v
wb	commands/sh4.cpp	/^register struct wdblock *wb;$/;"	v	typeref:struct:wdblock
wb	commands/sh4.cpp	/^struct wdblock *wb;$/;"	v	typeref:struct:wdblock
wbp	commands/sh4.cpp	/^register struct wdblock **wbp;$/;"	v	typeref:struct:wdblock
wcount	commands/wc.cpp	/^long wcount; \/* Count of words *\/$/;"	v
wd	commands/sh4.cpp	/^char *wd;$/;"	v
wdblock	include/sh.hpp	/^struct wdblock {$/;"	s
wdlist	include/sh.hpp	/^struct wdblock *wdlist;$/;"	v	typeref:struct:wdblock
we	commands/sh4.cpp	/^globname(we, pp) char *we;$/;"	v
weekday	commands/cal.cpp	/^constexpr std::string_view weekday = " S  M Tu  W Th  F  S";$/;"	v
wflag	commands/wc.cpp	/^int wflag; \/* Count words *\/$/;"	v
whence	fs/param.hpp	40;"	d
where	commands/make.cpp	/^char *s, *where;$/;"	v
where	commands/make.cpp	/^get_stripped_line(where, len, stream) char *where;$/;"	v
where	commands/make.cpp	/^getline(stream, where) char *where;$/;"	v
whichtest	test/test9.cpp	/^int whichtest;$/;"	v
white	commands/libpack.cpp	/^int white = 0;$/;"	v
white_space	commands/mined.hpp	205;"	d
white_space	include/mined.hpp	198;"	d
who	fs/glo.hpp	/^EXTERN int who;                  \/* caller's proc number *\/$/;"	v
whoami	commands/make.cpp	/^char *whoami = "Make";$/;"	v
width	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
width	commands/pr.cpp	/^short width = kDefaultWidth;$/;"	v
winchester_task	kernel/at_wini.cpp	/^PUBLIC winchester_task() {$/;"	f
wini	kernel/at_wini.cpp	/^PRIVATE struct wini {     \/* main drive struct, one entry per drive *\/$/;"	s	file:
wini	kernel/at_wini.cpp	/^} wini[NR_DEVICES];$/;"	v	typeref:struct:wini
wini	kernel/wini.cpp	/^PRIVATE struct wini {             \/* main drive struct, one entry per drive *\/$/;"	s	file:
wini	kernel/wini.cpp	/^} wini[NR_DEVICES];$/;"	v	typeref:struct:wini
wini	kernel/xt_wini.cpp	/^PRIVATE struct wini {             \/* main drive struct, one entry per drive *\/$/;"	s	file:
wini	kernel/xt_wini.cpp	/^} wini[NR_DEVICES];$/;"	v	typeref:struct:wini
wipe_inode	fs/inode.cpp	/^PUBLIC void wipe_inode(struct inode *rip) { \/\/ Added void return, modernized params$/;"	f
wn_address	kernel/at_wini.cpp	/^    vir_bytes wn_address; \/* user virtual address *\/$/;"	m	struct:wini	file:
wn_address	kernel/wini.cpp	/^    std::size_t wn_address;       \/* user virtual address (was vir_bytes) *\/$/;"	m	struct:wini	file:
wn_address	kernel/xt_wini.cpp	/^    vir_bytes wn_address;         \/* user virtual address *\/$/;"	m	struct:wini	file:
wn_count	kernel/at_wini.cpp	/^    int wn_count;         \/* byte count *\/$/;"	m	struct:wini	file:
wn_count	kernel/wini.cpp	/^    std::size_t wn_count;         \/* byte count (was int) *\/$/;"	m	struct:wini	file:
wn_count	kernel/xt_wini.cpp	/^    int wn_count;                 \/* byte count *\/$/;"	m	struct:wini	file:
wn_ctlbyte	kernel/at_wini.cpp	/^    int wn_ctlbyte;       \/* control byte (steprate) *\/$/;"	m	struct:wini	file:
wn_cylinder	kernel/at_wini.cpp	/^    int wn_cylinder;      \/* cylinder number addressed *\/$/;"	m	struct:wini	file:
wn_cylinder	kernel/wini.cpp	/^    int wn_cylinder;              \/* cylinder number addressed *\/$/;"	m	struct:wini	file:
wn_cylinder	kernel/xt_wini.cpp	/^    int wn_cylinder;              \/* cylinder number addressed *\/$/;"	m	struct:wini	file:
wn_drive	kernel/at_wini.cpp	/^    int wn_drive;         \/* drive number addressed *\/$/;"	m	struct:wini	file:
wn_drive	kernel/wini.cpp	/^    int wn_drive;                 \/* drive number addressed *\/$/;"	m	struct:wini	file:
wn_drive	kernel/xt_wini.cpp	/^    int wn_drive;                 \/* drive number addressed *\/$/;"	m	struct:wini	file:
wn_head	kernel/at_wini.cpp	/^    int wn_head;          \/* head number addressed *\/$/;"	m	struct:wini	file:
wn_head	kernel/wini.cpp	/^    int wn_head;                  \/* head number addressed *\/$/;"	m	struct:wini	file:
wn_head	kernel/xt_wini.cpp	/^    int wn_head;                  \/* head number addressed *\/$/;"	m	struct:wini	file:
wn_heads	kernel/at_wini.cpp	/^    int wn_heads;         \/* maximum number of heads *\/$/;"	m	struct:wini	file:
wn_heads	kernel/wini.cpp	/^    int wn_heads;                 \/* maximum number of heads *\/$/;"	m	struct:wini	file:
wn_heads	kernel/xt_wini.cpp	/^    int wn_heads;                 \/* maximum number of heads *\/$/;"	m	struct:wini	file:
wn_low	kernel/at_wini.cpp	/^    long wn_low;          \/* lowest cylinder of partition *\/$/;"	m	struct:wini	file:
wn_low	kernel/wini.cpp	/^    uint64_t wn_low;              \/* lowest cylinder of partition (was long, now block offset) *\/$/;"	m	struct:wini	file:
wn_low	kernel/xt_wini.cpp	/^    long wn_low;                  \/* lowest cylinder of partition *\/$/;"	m	struct:wini	file:
wn_maxsec	kernel/at_wini.cpp	/^    int wn_maxsec;        \/* maximum number of sectors per track *\/$/;"	m	struct:wini	file:
wn_opcode	kernel/at_wini.cpp	/^    int wn_opcode;        \/* DISK_READ or DISK_WRITE *\/$/;"	m	struct:wini	file:
wn_opcode	kernel/wini.cpp	/^    int wn_opcode;                \/* DISK_READ or DISK_WRITE *\/$/;"	m	struct:wini	file:
wn_opcode	kernel/xt_wini.cpp	/^    int wn_opcode;                \/* DISK_READ or DISK_WRITE *\/$/;"	m	struct:wini	file:
wn_precomp	kernel/at_wini.cpp	/^    int wn_precomp;       \/* write precompensation cylinder \/ 4 *\/$/;"	m	struct:wini	file:
wn_procnr	kernel/at_wini.cpp	/^    int wn_procnr;        \/* which proc wanted this operation? *\/$/;"	m	struct:wini	file:
wn_procnr	kernel/wini.cpp	/^    int wn_procnr;                \/* which proc wanted this operation? *\/$/;"	m	struct:wini	file:
wn_procnr	kernel/xt_wini.cpp	/^    int wn_procnr;                \/* which proc wanted this operation? *\/$/;"	m	struct:wini	file:
wn_results	kernel/wini.cpp	/^    char wn_results[MAX_RESULTS]; \/* the controller can give lots of output *\/$/;"	m	struct:wini	file:
wn_results	kernel/xt_wini.cpp	/^    char wn_results[MAX_RESULTS]; \/* the controller can give lots of output *\/$/;"	m	struct:wini	file:
wn_sector	kernel/at_wini.cpp	/^    int wn_sector;        \/* sector addressed *\/$/;"	m	struct:wini	file:
wn_sector	kernel/wini.cpp	/^    int wn_sector;                \/* sector addressed *\/$/;"	m	struct:wini	file:
wn_sector	kernel/xt_wini.cpp	/^    int wn_sector;                \/* sector addressed *\/$/;"	m	struct:wini	file:
wn_size	kernel/at_wini.cpp	/^    long wn_size;         \/* size of partition in blocks *\/$/;"	m	struct:wini	file:
wn_size	kernel/wini.cpp	/^    uint64_t wn_size;             \/* size of partition in blocks (was long) *\/$/;"	m	struct:wini	file:
wn_size	kernel/xt_wini.cpp	/^    long wn_size;                 \/* size of partition in blocks *\/$/;"	m	struct:wini	file:
wordlist	commands/sh2.cpp	/^static char **wordlist() {$/;"	f	file:
words	commands/od.cpp	/^bdump(words, k, c) int words[8];$/;"	v
words	commands/od.cpp	/^int **words;$/;"	v
words	commands/od.cpp	/^wdump(words, k, radix) int words[8], k, radix;$/;"	v
words	include/sh.hpp	/^    char **words;          \/* arguments to a command *\/$/;"	m	struct:op
wp	commands/sh2.cpp	/^    char **wp;$/;"	m	union:__anon26	file:
wp	commands/sh2.cpp	/^char **wp;$/;"	v
wp	commands/sh3.cpp	/^char **wp;$/;"	v
wp	commands/sh3.cpp	/^static void echo(wp) register char **wp;$/;"	v
wp	commands/sh3.cpp	/^static void rdexp(wp, f, key) register char **wp;$/;"	v
wp	commands/sh4.cpp	/^char **wp;$/;"	v
wr_precomp	kernel/wini.cpp	/^    int wr_precomp; \/* First cylinder with write precompensation *\/$/;"	m	struct:param	file:
wr_precomp	kernel/xt_wini.cpp	/^    int wr_precomp; \/* First cylinder with write precompensation *\/$/;"	m	struct:param	file:
writable	commands/mined1.cpp	/^FLAG writable;               \/* Set if file cannot be written *\/$/;"	v
write	include/minix/io/file_operations.hpp	/^    write = 1 << 1,$/;"	m	class:minix::io::OpenMode
write	include/minix/io/stream.hpp	/^    virtual std::expected<size_t, std::error_code> write(std::span<const std::byte> buffer) {$/;"	f	class:minix::io::Stream
write	lib/io/src/file_stream.cpp	/^Result<size_t> FileStream::write(const std::byte *buffer, size_t length) {$/;"	f	class:minix::io::FileStream
write	lib/io/src/memory_stream.cpp	/^Result<size_t> MemoryStream::write(const std::byte *buffer, size_t length) {$/;"	f	class:minix::io::MemoryStream
write	lib/write.cpp	/^ssize_t write(int fd, const void *buffer, size_t nbytes) {$/;"	f
write	tools/build.cpp	/^    std::size_t write(const std::uint8_t *data, std::size_t bytes) {$/;"	f	class:minix::builder::ProgramType::SectorBuffer
write_data	tools/build.cpp	/^    void write_data(const std::uint8_t *data, std::size_t size) {$/;"	f	class:minix::builder::ProgramType::ImageFile
write_map	fs/write.cpp	/^static int write_map(struct inode *rip, int32_t position, uint16_t new_zone) {$/;"	f	file:
write_sector	tools/build.cpp	/^    void write_sector(std::size_t sector, const SectorBuffer &data) {$/;"	f	class:minix::builder::ProgramType::ImageFile
write_sector	tools/diskio.cpp	/^void DiskInterface::write_sector(SectorAddress sector, const SectorBuffer &buffer) {$/;"	f	class:diskio::DiskInterface
write_sector_raw	tools/diskio.cpp	/^void DiskInterface::write_sector_raw(SectorAddress sector, const SectorBuffer &buffer) {$/;"	f	class:diskio::DiskInterface
write_sectors	tools/diskio.cpp	/^void DiskInterface::write_sectors(SectorAddress start_sector,$/;"	f	class:diskio::DiskInterface
write_to_file	tools/bootblok1.cpp	/^    void write_to_file(const fs::path &file_path) const {$/;"	f	class:minix::bootloader::BootSector
writeback_cache	tools/diskio.cpp	/^void DiskInterface::writeback_cache() {$/;"	f	class:diskio::DiskInterface
writebreak	commands/roff.cpp	/^writebreak() {$/;"	f
writefl	commands/mined1.cpp	/^FLAG writefl, changed;$/;"	v
wrl	tools/r.cpp	/^static void wrl(int fd, long address) {$/;"	f	file:
wtotal	commands/wc.cpp	/^long wtotal; \/* Total count of words *\/$/;"	v
x	commands/mined1.cpp	/^int x, y;                    \/* x, y coordinates on screen *\/$/;"	v
x_coord	commands/mined1.cpp	/^display(x_coord, y_coord, line, count) int x_coord, y_coord;$/;"	v
x_coord	commands/mined1.cpp	/^int x_coord;$/;"	v
x_scan	commands/make.cpp	/^static int x_scan(char *src, int pos, char *dest) {$/;"	f	file:
xbuf	commands/libpack.cpp	/^char xbuf[BUFSIZ + 2];$/;"	v
xchar	include/sh.hpp	/^    char xchar;   \/* for `'s *\/$/;"	m	struct:io
xflag	commands/od.cpp	/^int bflag, cflag, dflag, oflag, xflag, hflag, linenr, width, state, ever;$/;"	v
xinim	include/xinim/core_types.hpp	/^namespace xinim {$/;"	n
xof_absorb	crypto/kyber_impl/symmetric.h	28;"	d
xof_squeezeblocks	crypto/kyber_impl/symmetric.h	29;"	d
xof_state	crypto/kyber_impl/symmetric.h	/^typedef keccak_state xof_state;$/;"	t
y	commands/mined1.cpp	/^int x, y;                    \/* x, y coordinates on screen *\/$/;"	v
y_coord	commands/mined1.cpp	/^display(x_coord, y_coord, line, count) int x_coord, y_coord;$/;"	v
yank_file	commands/mined1.cpp	/^char yank_file[] = "\/tmp\/mined.XXXXXX";$/;"	v
yank_status	commands/mined1.cpp	/^FLAG yank_status = NOT_VALID; \/* Status of yank_file *\/$/;"	v
year	commands/date.cpp	/^    int year, month, day, hour, min, sec;$/;"	m	struct:__anon25	file:
yield_to	kernel/schedule.cpp	/^void Scheduler::yield_to(xinim::pid_t target) {$/;"	f	class:sched::Scheduler
yylval	commands/sh2.cpp	/^static YYSTYPE yylval;$/;"	v	file:
yynerrs	include/sh.hpp	/^int yynerrs; \/* yacc *\/$/;"	v
yyparse	commands/sh2.cpp	/^int yyparse() {$/;"	f
z	commands/mkfs.cpp	/^add_zone(n, z, bytes, cur_time) int n, z;$/;"	v
z	kernel/quaternion_spinlock.hpp	/^        : w(sw), x(sx), y(sy), z(sz) {}$/;"	f	struct:hyper::Quaternion
z	tools/mkfs.cpp	/^add_zone(n, z, bytes, cur_time) int n, z;$/;"	v
zero	commands/mkfs.cpp	/^char zero[BLOCK_SIZE], *lastp;$/;"	v
zero	kernel/idt64.cpp	/^    u32_t zero;$/;"	m	struct:idt_entry	file:
zero	multiboot.h	/^    uint32_t zero; \/\/ Reserved, must be zero$/;"	m	struct:multiboot_mmap_entry
zero	test/test5.cpp	/^int zero[1024];$/;"	v
zero	tools/mkfs.cpp	/^char zero[BLOCK_SIZE], *lastp;$/;"	v
zero_block	fs/write.cpp	/^PUBLIC void zero_block(struct buf *bp) { \/\/ Assuming void return$/;"	f
zetas	crypto/kyber_impl/ntt.c	/^const int16_t zetas[128] = {$/;"	v
zetas	crypto/kyber_impl/ntt.h	7;"	d
zilch	test/test7.cpp	/^int zilch[5000];$/;"	v
zlock_decrypt	kernel/sedenion.hpp	/^[[nodiscard]] inline std::array<uint8_t, 16> zlock_decrypt(const Sedenion &pub, const Sedenion &c) {$/;"	f	namespace:hyper
zlock_encrypt	kernel/sedenion.hpp	/^[[nodiscard]] inline Sedenion zlock_encrypt(const Sedenion &pub, std::span<const uint8_t, 16> m) {$/;"	f	namespace:hyper
zoff	commands/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
zoff	tools/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
zone_bitmap_	tools/fsck.cpp	/^    Bitmap zone_bitmap_;$/;"	m	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
zone_nr	include/minix/fs/const.hpp	/^enum class zone_nr : std::uint32_t {};$/;"	c	namespace:minix::fs
zone_shift	commands/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
zone_shift	tools/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
zone_size	commands/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
zone_size	tools/mkfs.cpp	/^int next_zone, next_inode, zone_size, zone_shift = 0, zoff, nrblocks, inode_offset, nrinodes,$/;"	v
zone_usage_	tools/fsck.cpp	/^    std::vector<bool> zone_usage_;$/;"	m	class:minix::fsck::ZoneLevel::FilesystemChecker	file:
zones	commands/mkfs.cpp	/^super(zones, inodes) int zones, inodes;$/;"	v
zones	tools/mkfs.cpp	/^super(zones, inodes) int zones, inodes;$/;"	v
zpair_generate	kernel/sedenion.hpp	/^[[nodiscard]] inline ZPair zpair_generate() {$/;"	f	namespace:hyper
zzerr	commands/sh2.cpp	/^static void zzerr() { yyerror("syntax error"); }$/;"	f	file:
~BufferGuard	include/minix/fs/buffer.hpp	/^    ~BufferGuard() {$/;"	f	class:minix::fs::BufferGuard
~DiskInterface	tools/diskio.cpp	/^DiskInterface::~DiskInterface() {$/;"	f	class:diskio::DiskInterface
~ImageFile	tools/build.cpp	/^    ~ImageFile() {$/;"	f	class:minix::builder::ProgramType::ImageFile
~QuaternionLockGuard	kernel/quaternion_spinlock.hpp	/^    ~QuaternionLockGuard() { lock.unlock(ticket); }$/;"	f	class:hyper::QuaternionLockGuard
~SafeBuffer	include/lib.hpp	/^    ~SafeBuffer() { safe_free(ptr_); }$/;"	f	class:SafeBuffer
~ScopedPortLock	kernel/at_wini.cpp	/^    ~ScopedPortLock() { unlock(); }$/;"	f	class:ScopedPortLock
~ScopedPortLock	kernel/wini.cpp	/^    ~ScopedPortLock() { unlock(); }$/;"	f	class:ScopedPortLock
~ScopedPortLock	kernel/xt_wini.cpp	/^    ~ScopedPortLock() { unlock(); }$/;"	f	class:ScopedPortLock
~ServiceManager	kernel/service.cpp	/^ServiceManager::~ServiceManager() { save(); }$/;"	f	class:svc::ServiceManager
